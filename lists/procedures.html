<!-- -*- mode: jinja2 -*- -->

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
      <meta name="description" content="Discontinuous Galerkin solver with explicit time stepping.">
    <meta name="author" content="University of Siegen" >
    <link rel="icon" href="../favicon.png">

    <title>All Procedures &ndash; Ateles
</title>

    <!-- Bootstrap -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet"
          integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"
            integrity="sha384-YvpcrYf0tY3lHB60NNkmXc5s9fDVZLESaAA55NDzOxhy9GkcIdslK1eN7N6jIeHz" crossorigin="anonymous"></script>
    <!-- Font Awesome -->
    <link href="../css/fontawesome.min.css" rel="stylesheet">
    <link href="../css/brands.min.css" rel="stylesheet">
    <link href="../css/regular.min.css" rel="stylesheet">
    <link href="../css/solid.min.css" rel="stylesheet">
    <link href="../css/v4-font-face.min.css" rel="stylesheet">
    <link href="../css/v4-shims.min.css" rel="stylesheet">
    <!-- MathJax -->
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        TeX: { equationNumbers: { autoNumber: "AMS" } }
      });
    </script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.9/MathJax.js?config=TeX-AMS-MML_HTMLorMML" async
            integrity="sha256-DViIOMYdwlM/axqoGDPeUyf0urLoHMN4QACBKyB58Uw=" crossorigin="anonymous"></script>
    <!-- Other scripts and stylesheets -->
    <link href="../css/local.css" rel="stylesheet">
    <link href="../css/pygments.css" rel="stylesheet">
    <script src="../js/svg-pan-zoom.min.js"></script>
  </head>

  <body>

    <!-- Fixed navbar -->
    <div class="container-fluid mb-sm-4 mb-xl-2">
      <nav class="navbar navbar-expand-lg navbar-dark bg-dark fixed-top">
        <div class="container">
          <a class="navbar-brand" href="../index.html">Ateles </a>
          <button type="button" class="navbar-toggler" data-bs-toggle="collapse" data-bs-target="#navbar"
                  aria-expanded="false" aria-controls="navbar" aria-label="Toggle navigation">
                  <span class="navbar-toggler-icon">
          </button>

          <div id="navbar" class="navbar-collapse collapse">
            <ul class="navbar-nav">
                <li class="nav-item"><a class="nav-link" href="../page/index.html">Documentation</a></li>
                  <li class="nav-item">
                    <a class="nav-link" href="../lists/files.html">Source Files</a>
                  </li>
                <li class="nav-item">
                  <a class="nav-link" href="../lists/modules.html">Modules</a>
                </li>
                <li class="nav-item">
                  <a class="nav-link" href="../lists/procedures.html">Procedures</a>
                </li>
                <li class="nav-item">
                  <a class="nav-link" href="../lists/absint.html">Abstract Interfaces</a>
                </li>
                <li class="nav-item">
                  <a class="nav-link" href="../lists/types.html">Derived Types</a>
                </li>
                <li class="nav-item">
                  <a class="nav-link" href="../lists/programs.html">Programs</a>
                </li>
            </ul>
              <div class="d-flex align-items-end flex-grow-1">
                <form action="../search.html" role="search" class="ms-auto">
                  <input type="text" class="form-control" aria-label="Search" placeholder="Search" name="q" id="tipue_search_input" autocomplete="off" required>
                </form>
              </div>
          </div><!--/.nav-collapse -->
        </div>
      </nav>
    </div>

    <div class="container">
      <div class="row">
        <div class="col-lg-12" id='text'>
			 <h1>Procedures</h1>
			 <table class="table table-striped">
			 <thead><tr><th>Procedure</th><th>Location</th><th>Procedure Type</th><th>Description</th></tr></thead>
			 <tbody>
			   <tr>
                 <td><a href='../proc/alpha.html'>alpha</a></td>
                 <td><a href='../module/ply_split_legendre_module.html'>ply_split_legendre_module</a></td>
                 <td>Function</td>
                 <td><p>Coefficient alpha from the recursive formulation of Legendre polynomials,
for the Legendre mode 'mode'.</p><a href="../proc/alpha.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/alpha_beta.html'>alpha_beta</a></td>
                 <td><a href='../module/ply_split_legendre_module.html'>ply_split_legendre_module</a></td>
                 <td>Function</td>
                 <td><p>Prodcut of alpha(numerator) * beta(denominator) / alpha(denominator) as
needed by the Clenshaw algorithm in ply_split_legendre_matrix.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/alpha_frac.html'>alpha_frac</a></td>
                 <td><a href='../module/ply_split_legendre_module.html'>ply_split_legendre_module</a></td>
                 <td>Function</td>
                 <td><p>Quotient of two alpha values.</p><a href="../proc/alpha_frac.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/alt_get_penaltyip.html'>alt_get_penaltyIP</a></td>
                 <td><a href='../module/atl_modg_navierstokes_kernel_module.html'>atl_modg_navierstokes_kernel_module</a></td>
                 <td>Function</td>
                 <td><p>Return the penalty parameter for the IP discretizations of higher order
equations.</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/append.html'>append</a></td>
                 <td><a href='../module/ply_dynarray_project_module.html'>ply_dynarray_project_module</a></td>
                 <td>Interface</td>
                 <td><p>append a value to the dynamic array
and return its position.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/append_advection_1d_consvars.html'>append_advection_1d_consVars</a></td>
                 <td><a href='../module/atl_eqn_advection_1d_var_module.html'>atl_eqn_advection_1d_var_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Append conservative variables for Euler equations.</p><a href="../proc/append_advection_1d_consvars.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/append_da_projection.html'>append_da_projection</a></td>
                 <td><a href='../module/ply_dynarray_project_module.html'>ply_dynarray_project_module</a></td>
                 <td>Subroutine</td>
                 <td><p>appending a value to the dynamic array</p><a href="../proc/append_da_projection.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/append_da_vecprojection.html'>append_da_vecprojection</a></td>
                 <td><a href='../module/ply_dynarray_project_module.html'>ply_dynarray_project_module</a></td>
                 <td>Subroutine</td>
                 <td><p>appending a sorted list of values to the dynamic array</p><a href="../proc/append_da_vecprojection.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/append_heat_1d_consvars.html'>append_heat_1d_consVars</a></td>
                 <td><a href='../module/atl_eqn_heat_1d_var_module.html'>atl_eqn_heat_1d_var_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Append conservative variables for Heat equations.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/append_heat_2d_consvars.html'>append_heat_2d_consVars</a></td>
                 <td><a href='../module/atl_eqn_heat_2d_var_module.html'>atl_eqn_heat_2d_var_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Append conservative variables for Heat equations.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/append_heat_consvars.html'>append_heat_consVars</a></td>
                 <td><a href='../module/atl_eqn_heat_var_module.html'>atl_eqn_heat_var_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Append conservative variables for Heat equations.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/append_rans_2d_derivedvars.html'>append_rans_2d_derivedVars</a></td>
                 <td><a href='../module/atl_eqn_filnvrstk_var_module.html'>atl_eqn_filNvrStk_var_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../interface/assignment(=).html'>assignment(=)</a></td>
                 <td><a href='../module/ply_prj_header_module.html'>ply_prj_header_module</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../interface/assignment(=)~2.html'>assignment(=)</a></td>
                 <td><a href='../module/ply_fxt_header_module.html'>ply_fxt_header_module</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../interface/assignment(=)~3.html'>assignment(=)</a></td>
                 <td><a href='../module/ply_polybaseexc_module.html'>ply_polyBaseExc_module</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../interface/assignment(=)~4.html'>assignment(=)</a></td>
                 <td><a href='../module/ply_l2p_module.html'>ply_l2p_module</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../interface/assignment(=)~5.html'>assignment(=)</a></td>
                 <td><a href='../module/ply_l2p_header_module.html'>ply_l2p_header_module</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../interface/assignment(=)~6.html'>assignment(=)</a></td>
                 <td><a href='../module/ply_dynarray_project_module.html'>ply_dynarray_project_module</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../interface/assignment(=)~7.html'>assignment(=)</a></td>
                 <td><a href='../module/ply_fpt_header_module.html'>ply_fpt_header_module</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../interface/assignment(=)~8.html'>assignment(=)</a></td>
                 <td><a href='../module/ply_poly_project_module.html'>ply_poly_project_module</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../interface/assignment(=)~9.html'>assignment(=)</a></td>
                 <td><a href='../module/ply_nodes_header_module.html'>ply_nodes_header_module</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../interface/assignment(=)~10.html'>assignment(=)</a></td>
                 <td><a href='../module/ply_legfpt_module.html'>ply_legFpt_module</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../interface/atl_acoustic_2d_numflux.html'>atl_acoustic_2d_numflux</a></td>
                 <td><a href='../module/atl_acoustic_2d_flux_module.html'>atl_acoustic_2d_flux_module</a></td>
                 <td>Interface</td>
                 <td><p>Interface for fluxes of acoustic equations.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_acoustic_2d_numflux_cube_vec.html'>atl_acoustic_2d_numflux_cube_vec</a></td>
                 <td><a href='../module/atl_acoustic_2d_flux_module.html'>atl_acoustic_2d_flux_module</a></td>
                 <td>Subroutine</td>
                 <td><p>calculate flux of pure acoustic equation directly on the face-vector</p><a href="../proc/atl_acoustic_2d_numflux_cube_vec.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_acoustic_2d_numflux_onedir.html'>atl_acoustic_2d_numFlux_oneDir</a></td>
                 <td><a href='../module/atl_acoustic_2d_flux_module.html'>atl_acoustic_2d_flux_module</a></td>
                 <td>Function</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_acoustic_2d_physflux.html'>atl_acoustic_2d_physFlux</a></td>
                 <td><a href='../module/atl_acoustic_2d_flux_module.html'>atl_acoustic_2d_flux_module</a></td>
                 <td>Function</td>
                 <td><p>Function for physical flux of the acoustic equation F, 1D?
Since it is 1d, there need to be passed the correct background velocity (u0
for F - flux in x direction, v0 for G - flux in y direction, w0 for H -
flux in z direction)</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/atl_acoustic_numflux.html'>atl_acoustic_numflux</a></td>
                 <td><a href='../module/atl_acoustic_numflux_module.html'>atl_acoustic_numflux_module</a></td>
                 <td>Interface</td>
                 <td><p>Interface for fluxes of acoustic equations.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_acoustic_numflux_cube_vec.html'>atl_acoustic_numflux_cube_vec</a></td>
                 <td><a href='../module/atl_acoustic_numflux_module.html'>atl_acoustic_numflux_module</a></td>
                 <td>Subroutine</td>
                 <td><p>calculate flux of pure acoustic equation directly on the face-vector</p><a href="../proc/atl_acoustic_numflux_cube_vec.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_acoustic_numflux_onedir.html'>atl_acoustic_numFlux_oneDir</a></td>
                 <td><a href='../module/atl_acoustic_numflux_module.html'>atl_acoustic_numflux_module</a></td>
                 <td>Function</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_acoustic_physflux.html'>atl_acoustic_physFlux</a></td>
                 <td><a href='../module/atl_acoustic_physflux_module.html'>atl_acoustic_physflux_module</a></td>
                 <td>Function</td>
                 <td><p>Function for physical flux of the acoustic equation F, 1D?
Since it is 1d, there need to be passed the correct background velocity (u0
for F - flux in x direction, v0 for G - flux in y direction, w0 for H -
flux in z direction)</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_addtimers.html'>atl_addTimers</a></td>
                 <td><a href='../module/atl_timer_module.html'>atl_timer_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Setup timers to assess the runtime of various parts of Ateles.</p><a href="../proc/atl_addtimers.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_addtimers_perelem.html'>atl_addTimers_perElem</a></td>
                 <td><a href='../module/atl_timer_module.html'>atl_timer_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Setup timers to assess the runtime of various parts of Ateles.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_alloc_temp.html'>atl_alloc_temp</a></td>
                 <td><a href='../module/atl_initialize_module.html'>atl_initialize_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Allocate temporary arrays.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_allocate_sourcedata.html'>atl_allocate_sourceData</a></td>
                 <td><a href='../module/atl_source_module.html'>atl_source_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_append_acoustic_2d_vars.html'>atl_append_acoustic_2d_vars</a></td>
                 <td><a href='../module/atl_eqn_acoustic_2d_var_module.html'>atl_eqn_acoustic_2d_var_module</a></td>
                 <td>Subroutine</td>
                 <td><p>\brief append the variables for acoustic simulations
the acoustic equation only has 'primitive' variables or different speaking,
the equation describe the pertubation in primitive variables</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_append_acoustic_vars.html'>atl_append_acoustic_vars</a></td>
                 <td><a href='../module/atl_eqn_acoustic_var_module.html'>atl_eqn_acoustic_var_module</a></td>
                 <td>Subroutine</td>
                 <td><p>append the variables for acoustic simulations</p><a href="../proc/atl_append_acoustic_vars.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_append_euler_1d_consvars.html'>atl_append_euler_1d_consVars</a></td>
                 <td><a href='../module/atl_eqn_euler_1d_var_module.html'>atl_eqn_euler_1d_var_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Append conservative variables for Euler equations.</p><a href="../proc/atl_append_euler_1d_consvars.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_append_euler_1d_derivedvars.html'>atl_append_euler_1d_derivedVars</a></td>
                 <td><a href='../module/atl_eqn_euler_1d_var_module.html'>atl_eqn_euler_1d_var_module</a></td>
                 <td>Subroutine</td>
                 <td><p>append / set data of derived quantities</p><a href="../proc/atl_append_euler_1d_derivedvars.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_append_euler_1d_primvars.html'>atl_append_euler_1d_primVars</a></td>
                 <td><a href='../module/atl_eqn_euler_1d_var_module.html'>atl_eqn_euler_1d_var_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Append primitive variables for euler equation</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_append_euler_2d_consvars.html'>atl_append_euler_2d_consVars</a></td>
                 <td><a href='../module/atl_eqn_euler_2d_var_module.html'>atl_eqn_euler_2d_var_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Append conservative variables for Euler equations.</p><a href="../proc/atl_append_euler_2d_consvars.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_append_euler_2d_derivedvars.html'>atl_append_euler_2d_derivedVars</a></td>
                 <td><a href='../module/atl_eqn_euler_2d_var_module.html'>atl_eqn_euler_2d_var_module</a></td>
                 <td>Subroutine</td>
                 <td><p>append / set data of derived quantities</p><a href="../proc/atl_append_euler_2d_derivedvars.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_append_euler_2d_primvars.html'>atl_append_euler_2d_primVars</a></td>
                 <td><a href='../module/atl_eqn_euler_2d_var_module.html'>atl_eqn_euler_2d_var_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Append primitive variables for euler equation</p><a href="../proc/atl_append_euler_2d_primvars.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_append_euler_consvars.html'>atl_append_euler_consVars</a></td>
                 <td><a href='../module/atl_eqn_euler_var_module.html'>atl_eqn_euler_var_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Append conservative variables for Euler equations.</p><a href="../proc/atl_append_euler_consvars.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_append_euler_derivedvars.html'>atl_append_euler_derivedVars</a></td>
                 <td><a href='../module/atl_eqn_euler_var_module.html'>atl_eqn_euler_var_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Append / set methods and data to compute derived quantities to the
variable system.</p><a href="../proc/atl_append_euler_derivedvars.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_append_euler_primvars.html'>atl_append_euler_primVars</a></td>
                 <td><a href='../module/atl_eqn_euler_var_module.html'>atl_eqn_euler_var_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Append primitive variables for euler equation</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_append_lineareuler_2d_derivedvars.html'>atl_append_lineareuler_2d_derivedVars</a></td>
                 <td><a href='../module/atl_eqn_lineareuler_2d_var_module.html'>atl_eqn_LinearEuler_2d_var_module</a></td>
                 <td>Subroutine</td>
                 <td><p>append / set data of derived quantities</p><a href="../proc/atl_append_lineareuler_2d_derivedvars.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_append_lineareuler_2d_vars.html'>atl_append_LinearEuler_2d_vars</a></td>
                 <td><a href='../module/atl_eqn_lineareuler_2d_var_module.html'>atl_eqn_LinearEuler_2d_var_module</a></td>
                 <td>Subroutine</td>
                 <td><p>append the variables for LinearEuler simulations</p><a href="../proc/atl_append_lineareuler_2d_vars.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_append_lineareuler_derivedvars.html'>atl_append_lineareuler_derivedVars</a></td>
                 <td><a href='../module/atl_eqn_lineareuler_var_module.html'>atl_eqn_LinearEuler_var_module</a></td>
                 <td>Subroutine</td>
                 <td><p>append / set data of derived quantities</p><a href="../proc/atl_append_lineareuler_derivedvars.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_append_lineareuler_vars.html'>atl_append_linearEuler_vars</a></td>
                 <td><a href='../module/atl_eqn_lineareuler_var_module.html'>atl_eqn_LinearEuler_var_module</a></td>
                 <td>Subroutine</td>
                 <td><p>append the variables for LinearEuler simulations</p><a href="../proc/atl_append_lineareuler_vars.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_append_maxwell_2d_vars.html'>atl_append_maxwell_2d_vars</a></td>
                 <td><a href='../module/atl_eqn_maxwell_2d_var_module.html'>atl_eqn_maxwell_2d_var_module</a></td>
                 <td>Subroutine</td>
                 <td><p>append the variables for electrodynamic simulations</p><a href="../proc/atl_append_maxwell_2d_vars.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_append_maxwell_vars.html'>atl_append_maxwell_vars</a></td>
                 <td><a href='../module/atl_eqn_maxwell_var_module.html'>atl_eqn_maxwell_var_module</a></td>
                 <td>Subroutine</td>
                 <td><p>append the variables for electrodynamic simulations</p><a href="../proc/atl_append_maxwell_vars.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_append_maxwelldivcorr_vars.html'>atl_append_maxwellDivCorr_vars</a></td>
                 <td><a href='../module/atl_eqn_maxwelldivcorr_var_module.html'>atl_eqn_maxwelldivcorr_var_module</a></td>
                 <td>Subroutine</td>
                 <td><p>append the variables for electrodynamic simulations that include</p><a href="../proc/atl_append_maxwelldivcorr_vars.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_append_nerplanck_vars.html'>atl_append_nerplanck_vars</a></td>
                 <td><a href='../module/atl_eqn_nerplanck_var_module.html'>atl_eqn_nerplanck_var_module</a></td>
                 <td>Subroutine</td>
                 <td><p>append the variables for diffusion simulations</p><a href="../proc/atl_append_nerplanck_vars.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_append_newmaterialvars.html'>atl_append_newMaterialVars</a></td>
                 <td><a href='../module/atl_materialini_module.html'>atl_materialIni_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Adds the configured material variables to the variable system.</p><a href="../proc/atl_append_newmaterialvars.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_append_newsourcevars.html'>atl_append_newSourceVars</a></td>
                 <td><a href='../module/atl_source_module.html'>atl_source_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_append_nvrstk_derivedvars.html'>atl_append_nvrstk_derivedVars</a></td>
                 <td><a href='../module/atl_eqn_nvrstk_var_module.html'>atl_eqn_nvrstk_var_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Append / set methods and data to compute derived quantities to the
variable system.</p><a href="../proc/atl_append_nvrstk_derivedvars.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_append_rans_consvars.html'>atl_append_rans_consVars</a></td>
                 <td><a href='../module/atl_eqn_filnvrstk_var_module.html'>atl_eqn_filNvrStk_var_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_append_rans_primvars.html'>atl_append_rans_primVars</a></td>
                 <td><a href='../module/atl_eqn_filnvrstk_var_module.html'>atl_eqn_filNvrStk_var_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_assign_elem_varprop.html'>atl_assign_elem_varProp</a></td>
                 <td><a href='../module/atl_materialini_module.html'>atl_materialIni_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Assign reference to spacetime functions to the affected elements. This
means: The position of the variable in the variable system, which reflects
the spacetime function is determined and assigned to the element_list.</p><a href="../proc/atl_assign_elem_varprop.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_assign_face_matprp.html'>atl_assign_face_matPrp</a></td>
                 <td><a href='../module/atl_materialini_module.html'>atl_materialIni_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Define material properties for the faces of all fluid elements and inherit
the face material property to all ghost elements on the finer level.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_averagefluxeuler_1d.html'>atl_averageFluxEuler_1d</a></td>
                 <td><a href='../module/atl_averageflux_1d_module.html'>atl_averageFlux_1d_module</a></td>
                 <td>Subroutine</td>
                 <td><p>A most basic flux function which uses the average of both sides for
1D Euler.</p><a href="../proc/atl_averagefluxeuler_1d.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_banner.html'>atl_banner</a></td>
                 <td><a href='../module/atl_aux_module.html'>atl_aux_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Prominently let the user now, what he actually is running right now.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_bc_state_set_frompoint.html'>atl_bc_state_set_fromPoint</a></td>
                 <td><a href='../module/atl_bc_state_module.html'>atl_bc_state_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Define the method to set the solverData_evalElem routine for stfuns.</p><a href="../proc/atl_bc_state_set_frompoint.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_bubblesortarray.html'>atl_bubbleSortArray</a></td>
                 <td><a href='../module/atl_aux_module.html'>atl_aux_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Bubble sorting of array of real numbers of size n</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_cflcheck_euler.html'>atl_cflCheck_euler</a></td>
                 <td><a href='../module/atl_physcheck_module.html'>atl_physCheck_module</a></td>
                 <td>Function</td>
                 <td><p>Routine to check if the physicle values of the state are physically
meaningful or not for the Euler and Linear Euler equation, checking
the cfl for a fixed timestep</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_cflcheck_navier.html'>atl_cflCheck_navier</a></td>
                 <td><a href='../module/atl_physcheck_module.html'>atl_physCheck_module</a></td>
                 <td>Function</td>
                 <td><p>Routine to check if the physicle values of the state are physically
meaningful or not for the Navier-Stokes equation, checking the cfl
for a fixed timestep</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_cheb_spectral_visc_1d.html'>atl_cheb_spectral_visc_1d</a></td>
                 <td><a href='../module/atl_stabilize_module.html'>atl_stabilize_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Damp the modal coefficients of the state vector by a given spectral
viscosity method.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_check_val.html'>atl_check_val</a></td>
                 <td><a href='../module/atl_physcheck_module.html'>atl_physCheck_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Routine to check if the physical values of a state are physically
meaningful or not.</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/atl_compute_rhs.html'>atl_compute_rhs</a></td>
                 <td><a href='../module/atl_compute_module.html'>atl_compute_module</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_cons_positivity_preserv.html'>atl_cons_positivity_preserv</a></td>
                 <td><a href='../module/atl_stabilize_module.html'>atl_stabilize_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Apply conservative limitation of denisty and energy to ensure positivity
for density and pressure.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_cons_positivity_preserv_2d.html'>atl_cons_positivity_preserv_2d</a></td>
                 <td><a href='../module/atl_stabilize_module.html'>atl_stabilize_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Apply conservative limitation of denisty and energy to ensure positivity
for density and pressure.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_covolume.html'>atl_covolume</a></td>
                 <td><a href='../module/atl_stabilize_module.html'>atl_stabilize_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Covolume filtering for 3D equation.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_covolume_1d.html'>atl_covolume_1d</a></td>
                 <td><a href='../module/atl_stabilize_module.html'>atl_stabilize_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Covolume filtering for 1D equation.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_covolume_2d.html'>atl_covolume_2d</a></td>
                 <td><a href='../module/atl_stabilize_module.html'>atl_stabilize_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Covolume filtering for 2D equation.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_covolume_to_primal_projection.html'>atl_covolume_to_primal_projection</a></td>
                 <td><a href='../module/atl_covolume_projection_module.html'>atl_covolume_projection_module</a></td>
                 <td>Function</td>
                 <td><p>Project two co-volume elements onto single a single element.</p><a href="../proc/atl_covolume_to_primal_projection.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_covolume_to_primal_projection_1d.html'>atl_covolume_to_primal_projection_1d</a></td>
                 <td><a href='../module/atl_covolume_projection_module.html'>atl_covolume_projection_module</a></td>
                 <td>Function</td>
                 <td><p>Project two co-volume elements onto single a single element.</p><a href="../proc/atl_covolume_to_primal_projection_1d.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_covolume_to_primal_projection_2d.html'>atl_covolume_to_primal_projection_2d</a></td>
                 <td><a href='../module/atl_covolume_projection_module.html'>atl_covolume_projection_module</a></td>
                 <td>Function</td>
                 <td><p>Project two co-volume elements onto single a single element.</p><a href="../proc/atl_covolume_to_primal_projection_2d.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_covolume_tocovolume.html'>atl_covolume_tocovolume</a></td>
                 <td><a href='../module/atl_stabilize_module.html'>atl_stabilize_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Recursive routine to project the state from primal mesh to covolume mesh.</p><a href="../proc/atl_covolume_tocovolume.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_covolume_tocovolume_1d.html'>atl_covolume_tocovolume_1d</a></td>
                 <td><a href='../module/atl_stabilize_module.html'>atl_stabilize_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Recursive routine to project the state from primal mesh to covolume mesh.</p><a href="../proc/atl_covolume_tocovolume_1d.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_covolume_tocovolume_2d.html'>atl_covolume_tocovolume_2d</a></td>
                 <td><a href='../module/atl_stabilize_module.html'>atl_stabilize_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Recursive routine to project the state from primal mesh to covolume mesh.</p><a href="../proc/atl_covolume_tocovolume_2d.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_create_fortranvar.html'>atl_create_fortranVar</a></td>
                 <td><a href='../module/atl_varsys_module.html'>atl_varSys_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine creates hard coded variables which are required by ateles.</p><a href="../proc/atl_create_fortranvar.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_create_materialboundarylist.html'>atl_create_materialBoundaryList</a></td>
                 <td><a href='../module/atl_materialini_module.html'>atl_materialIni_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Create separate compute list for constant-constant, constant-variable (or
vice versa) and variable-variable material parameter compute faces on this
rank.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_create_materialcomputelist.html'>atl_create_materialComputeList</a></td>
                 <td><a href='../module/atl_materialini_module.html'>atl_materialIni_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Create separate compute list for constant-constant, constant-variable (or
vice versa) and variable-variable material parameter compute faces on this
rank.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_create_materialelemlist.html'>atl_create_materialElemList</a></td>
                 <td><a href='../module/atl_materialini_module.html'>atl_materialIni_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Subroutine to create element index list for constant and non-constant
material parameters.</p><a href="../proc/atl_create_materialelemlist.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_deallocate_sourcedata.html'>atl_deallocate_sourceData</a></td>
                 <td><a href='../module/atl_source_module.html'>atl_source_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Deallocates the array for storing the sourceData for the currentLevel</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_define_schemestencil.html'>atl_define_SchemeStencil</a></td>
                 <td><a href='../module/atl_scheme_module.html'>atl_scheme_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Subroutine do define a specific stencil for a certain scheme.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_derivekineticenergy.html'>atl_deriveKineticEnergy</a></td>
                 <td><a href='../module/atl_eqn_euler_derive_module.html'>atl_eqn_euler_derive_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_derivelambda2.html'>atl_deriveLambda2</a></td>
                 <td><a href='../module/atl_eqn_euler_derive_module.html'>atl_eqn_euler_derive_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine evaluates the lambda2 criterion. The input is the nodal value</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_derivemachnumber.html'>atl_deriveMachNumber</a></td>
                 <td><a href='../module/atl_eqn_euler_derive_module.html'>atl_eqn_euler_derive_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_derivepressure.html'>atl_derivePressure</a></td>
                 <td><a href='../module/atl_eqn_euler_derive_module.html'>atl_eqn_euler_derive_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_derivepressure~2.html'>atl_derivePressure</a></td>
                 <td><a href='../module/atl_eqn_filnvrstk_derive_module.html'>atl_eqn_filNvrStk_derive_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_derivepressure_1d.html'>atl_derivePressure_1d</a></td>
                 <td><a href='../module/atl_eqn_euler_1d_derive_module.html'>atl_eqn_euler_1d_derive_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_derivepressure_2d.html'>atl_derivePressure_2d</a></td>
                 <td><a href='../module/atl_eqn_euler_2d_derive_module.html'>atl_eqn_euler_2d_derive_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_deriveqcriterion.html'>atl_deriveQcriterion</a></td>
                 <td><a href='../module/atl_eqn_euler_derive_module.html'>atl_eqn_euler_derive_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine evaluates the q_criterion. The input is the nodal value of</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_derivespeedofsound.html'>atl_deriveSpeedOfSound</a></td>
                 <td><a href='../module/atl_eqn_euler_derive_module.html'>atl_eqn_euler_derive_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_derivetemperature.html'>atl_deriveTemperature</a></td>
                 <td><a href='../module/atl_eqn_euler_derive_module.html'>atl_eqn_euler_derive_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_dividevecbyscal.html'>atl_divideVecByScal</a></td>
                 <td><a href='../module/atl_operator_module.html'>atl_operator_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_division.html'>atl_division</a></td>
                 <td><a href='../module/atl_operator_module.html'>atl_operator_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_dump_acoustic_eqn.html'>atl_dump_acoustic_eqn</a></td>
                 <td><a href='../module/atl_eqn_acoustic_module.html'>atl_eqn_acoustic_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_dump_materialfun.html'>atl_dump_materialFun</a></td>
                 <td><a href='../module/atl_materialfun_module.html'>atl_materialFun_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Dump material description to lua file</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_dumptimers.html'>atl_dumptimers</a></td>
                 <td><a href='../module/atl_timer_module.html'>atl_timer_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Performance results are written to a file for statistical review
 The file-format is simple can be evaluated with gnuplot</p><a href="../proc/atl_dumptimers.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_dumpweights.html'>atl_dumpWeights</a></td>
                 <td><a href='../module/atl_weights_module.html'>atl_weights_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Dump weights to a file.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_eqn_acoustic_init.html'>atl_eqn_acoustic_init</a></td>
                 <td><a href='../module/atl_eqn_acoustic_hlp_module.html'>atl_eqn_acoustic_hlp_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Initialization of the Acoustic equation.</p><a href="../proc/atl_eqn_acoustic_init.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_eqn_acoustic_load_bc.html'>atl_eqn_acoustic_load_bc</a></td>
                 <td><a href='../module/atl_eqn_acoustic_hlp_module.html'>atl_eqn_acoustic_hlp_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Reading boundary conditions for the acoustic equations.</p><a href="../proc/atl_eqn_acoustic_load_bc.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_eqn_advection_1d_init.html'>atl_eqn_advection_1d_init</a></td>
                 <td><a href='../module/atl_eqn_advection_1d_hlp_module.html'>atl_eqn_advection_1d_hlp_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Initialization of the linearized Euler equations.</p><a href="../proc/atl_eqn_advection_1d_init.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_eqn_advection_1d_load_bc.html'>atl_eqn_advection_1d_load_bc</a></td>
                 <td><a href='../module/atl_eqn_advection_1d_hlp_module.html'>atl_eqn_advection_1d_hlp_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Reading boundary conditions for the advection equations in 1D.</p><a href="../proc/atl_eqn_advection_1d_load_bc.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_eqn_euler_1d_cons2prim.html'>atl_eqn_euler_1d_cons2prim</a></td>
                 <td><a href='../module/atl_eqn_euler_1d_derive_module.html'>atl_eqn_euler_1d_derive_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Convert conservative to primitive variables.</p><a href="../proc/atl_eqn_euler_1d_cons2prim.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_eqn_euler_1d_cons2prim_elems.html'>atl_eqn_euler_1d_cons2prim_elems</a></td>
                 <td><a href='../module/atl_eqn_euler_1d_derive_module.html'>atl_eqn_euler_1d_derive_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Convert conservative to primitive variables.</p><a href="../proc/atl_eqn_euler_1d_cons2prim_elems.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_eqn_euler_1d_prim2cons.html'>atl_eqn_euler_1d_prim2cons</a></td>
                 <td><a href='../module/atl_eqn_euler_1d_derive_module.html'>atl_eqn_euler_1d_derive_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Convert primitive varibales to conservative variables.</p><a href="../proc/atl_eqn_euler_1d_prim2cons.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_eqn_euler_1d_prim2cons_elems.html'>atl_eqn_euler_1d_prim2cons_elems</a></td>
                 <td><a href='../module/atl_eqn_euler_1d_derive_module.html'>atl_eqn_euler_1d_derive_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Convert primitive varibales to conservative variables.</p><a href="../proc/atl_eqn_euler_1d_prim2cons_elems.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_eqn_euler_2d_cons2prim.html'>atl_eqn_euler_2d_cons2prim</a></td>
                 <td><a href='../module/atl_eqn_euler_2d_derive_module.html'>atl_eqn_euler_2d_derive_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Convert conservative to primitive variables.</p><a href="../proc/atl_eqn_euler_2d_cons2prim.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_eqn_euler_2d_cons2prim_elems.html'>atl_eqn_euler_2d_cons2prim_elems</a></td>
                 <td><a href='../module/atl_eqn_euler_2d_derive_module.html'>atl_eqn_euler_2d_derive_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Convert conservative to primitive variables.</p><a href="../proc/atl_eqn_euler_2d_cons2prim_elems.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_eqn_euler_2d_cons2prim_grad.html'>atl_eqn_euler_2d_cons2prim_grad</a></td>
                 <td><a href='../module/atl_eqn_euler_2d_derive_module.html'>atl_eqn_euler_2d_derive_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Convert conservative to primitive variables including the gradients.
(instate(npnts, nScalars+nScalars)</p><a href="../proc/atl_eqn_euler_2d_cons2prim_grad.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_eqn_euler_2d_cons2primtemp.html'>atl_eqn_euler_2d_cons2primTemp</a></td>
                 <td><a href='../module/atl_eqn_euler_2d_derive_module.html'>atl_eqn_euler_2d_derive_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Convert conservative to primitive variables (including temperature
instead of pressure).</p><a href="../proc/atl_eqn_euler_2d_cons2primtemp.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_eqn_euler_2d_cons2primvel.html'>atl_eqn_euler_2d_cons2primVel</a></td>
                 <td><a href='../module/atl_eqn_euler_2d_derive_module.html'>atl_eqn_euler_2d_derive_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Convert conservative to conservative variables (including velocity
instead of momentum).</p><a href="../proc/atl_eqn_euler_2d_cons2primvel.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_eqn_euler_2d_prim2cons.html'>atl_eqn_euler_2d_prim2cons</a></td>
                 <td><a href='../module/atl_eqn_euler_2d_derive_module.html'>atl_eqn_euler_2d_derive_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Convert primitive varibales to conservative variables.</p><a href="../proc/atl_eqn_euler_2d_prim2cons.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_eqn_euler_2d_prim2cons_elems.html'>atl_eqn_euler_2d_prim2cons_elems</a></td>
                 <td><a href='../module/atl_eqn_euler_2d_derive_module.html'>atl_eqn_euler_2d_derive_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Convert primitive varibales to conservative variables.</p><a href="../proc/atl_eqn_euler_2d_prim2cons_elems.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_eqn_euler_2d_prim2cons_grad.html'>atl_eqn_euler_2d_prim2cons_grad</a></td>
                 <td><a href='../module/atl_eqn_euler_2d_derive_module.html'>atl_eqn_euler_2d_derive_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_eqn_euler_2d_primtemp2cons.html'>atl_eqn_euler_2d_primTemp2cons</a></td>
                 <td><a href='../module/atl_eqn_euler_2d_derive_module.html'>atl_eqn_euler_2d_derive_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Convert primitive varibales (including temperature instead
of pressure) to conservative variables.</p><a href="../proc/atl_eqn_euler_2d_primtemp2cons.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_eqn_euler_2d_primvel2cons.html'>atl_eqn_euler_2d_primVel2cons</a></td>
                 <td><a href='../module/atl_eqn_euler_2d_derive_module.html'>atl_eqn_euler_2d_derive_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Convert conservative varibales (including velocity instead
of temperature) to conservative variables.</p><a href="../proc/atl_eqn_euler_2d_primvel2cons.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_eqn_euler_cons2prim.html'>atl_eqn_euler_cons2prim</a></td>
                 <td><a href='../module/atl_eqn_euler_derive_module.html'>atl_eqn_euler_derive_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Convert conservative to primitive variables.</p><a href="../proc/atl_eqn_euler_cons2prim.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_eqn_euler_cons2prim_elems.html'>atl_eqn_euler_cons2prim_elems</a></td>
                 <td><a href='../module/atl_eqn_euler_derive_module.html'>atl_eqn_euler_derive_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Convert conservative to primitive variables.</p><a href="../proc/atl_eqn_euler_cons2prim_elems.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_eqn_euler_cons2prim_grad.html'>atl_eqn_euler_cons2prim_grad</a></td>
                 <td><a href='../module/atl_eqn_euler_derive_module.html'>atl_eqn_euler_derive_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Convert conservative to primitive variables including the gradients.</p><a href="../proc/atl_eqn_euler_cons2prim_grad.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_eqn_euler_cons2primtemp.html'>atl_eqn_euler_cons2primTemp</a></td>
                 <td><a href='../module/atl_eqn_euler_derive_module.html'>atl_eqn_euler_derive_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Convert conservative to primitive variables (including temperature
instead of pressure).</p><a href="../proc/atl_eqn_euler_cons2primtemp.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_eqn_euler_cons2primvel.html'>atl_eqn_euler_cons2primVel</a></td>
                 <td><a href='../module/atl_eqn_euler_derive_module.html'>atl_eqn_euler_derive_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Convert conservative to conservative variables (including velocity
instead of momentum).</p><a href="../proc/atl_eqn_euler_cons2primvel.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_eqn_euler_implicit_pen.html'>atl_eqn_euler_implicit_pen</a></td>
                 <td><a href='../module/atl_eqn_euler_hlp_module.html'>atl_eqn_euler_hlp_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Solve the equation system with just the penalization terms to find an
implicit update for the IMEX timestepping procedure.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_eqn_euler_init.html'>atl_eqn_euler_init</a></td>
                 <td><a href='../module/atl_eqn_euler_hlp_module.html'>atl_eqn_euler_hlp_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Initialization of the Euler equation.</p><a href="../proc/atl_eqn_euler_init.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_eqn_euler_load_bc.html'>atl_eqn_euler_load_bc</a></td>
                 <td><a href='../module/atl_eqn_euler_hlp_module.html'>atl_eqn_euler_hlp_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Reading boundary conditions for the euler equations.</p><a href="../proc/atl_eqn_euler_load_bc.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_eqn_euler_prim2cons.html'>atl_eqn_euler_prim2cons</a></td>
                 <td><a href='../module/atl_eqn_euler_derive_module.html'>atl_eqn_euler_derive_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Convert primitive varibales to conservative variables.</p><a href="../proc/atl_eqn_euler_prim2cons.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_eqn_euler_prim2cons_elems.html'>atl_eqn_euler_prim2cons_elems</a></td>
                 <td><a href='../module/atl_eqn_euler_derive_module.html'>atl_eqn_euler_derive_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Convert primitive varibales to conservative variables.</p><a href="../proc/atl_eqn_euler_prim2cons_elems.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_eqn_euler_prim2cons_grad.html'>atl_eqn_euler_prim2cons_grad</a></td>
                 <td><a href='../module/atl_eqn_euler_derive_module.html'>atl_eqn_euler_derive_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Convert primitive varibales to conservative variables including their
gradients.</p><a href="../proc/atl_eqn_euler_prim2cons_grad.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_eqn_euler_primtemp2cons.html'>atl_eqn_euler_primTemp2cons</a></td>
                 <td><a href='../module/atl_eqn_euler_derive_module.html'>atl_eqn_euler_derive_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Convert primitive varibales (including temperature instead
of pressure) to conservative variables.</p><a href="../proc/atl_eqn_euler_primtemp2cons.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_eqn_euler_primvel2cons.html'>atl_eqn_euler_primVel2cons</a></td>
                 <td><a href='../module/atl_eqn_euler_derive_module.html'>atl_eqn_euler_derive_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Convert conservative varibales (including velocity instead
of temperature) to conservative variables.</p><a href="../proc/atl_eqn_euler_primvel2cons.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_eqn_filtered_nvrstk_init.html'>atl_eqn_filtered_nvrstk_init</a></td>
                 <td><a href='../module/atl_eqn_filnvrstk_hlp_module.html'>atl_eqn_filnvrStk_hlp_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Initialization of the Navier-Stokes equations.</p><a href="../proc/atl_eqn_filtered_nvrstk_init.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_eqn_getfilnvrstkfluxes.html'>atl_eqn_getFilNvrStkFluxes</a></td>
                 <td><a href='../module/atl_eqn_filnvrstk_hlp_module.html'>atl_eqn_filnvrStk_hlp_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_eqn_heat_init.html'>atl_eqn_heat_init</a></td>
                 <td><a href='../module/atl_eqn_heat_hlp_module.html'>atl_eqn_heat_hlp_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Initialization of the Heat equation.</p><a href="../proc/atl_eqn_heat_init.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_eqn_heat_load_bc.html'>atl_eqn_heat_load_bc</a></td>
                 <td><a href='../module/atl_eqn_heat_hlp_module.html'>atl_eqn_heat_hlp_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Reading boundary conditions for the Heat equation.</p><a href="../proc/atl_eqn_heat_load_bc.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_eqn_lineareuler_init.html'>atl_eqn_linearEuler_init</a></td>
                 <td><a href='../module/atl_eqn_lineareuler_hlp_module.html'>atl_eqn_LinearEuler_hlp_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Initialization of the linearized Euler equations.</p><a href="../proc/atl_eqn_lineareuler_init.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_eqn_lineareuler_load_bc.html'>atl_eqn_LinearEuler_load_bc</a></td>
                 <td><a href='../module/atl_eqn_lineareuler_hlp_module.html'>atl_eqn_LinearEuler_hlp_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Reading boundary conditions for the LinearEuler equations.</p><a href="../proc/atl_eqn_lineareuler_load_bc.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_eqn_maxwell_2d_cons2prim.html'>atl_eqn_maxwell_2d_cons2prim</a></td>
                 <td><a href='../module/atl_eqn_maxwell_2d_derive_module.html'>atl_eqn_maxwell_2d_derive_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Convert conservative to primitive variables.</p><a href="../proc/atl_eqn_maxwell_2d_cons2prim.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_eqn_maxwell_2d_prim2cons.html'>atl_eqn_maxwell_2d_prim2cons</a></td>
                 <td><a href='../module/atl_eqn_maxwell_2d_derive_module.html'>atl_eqn_maxwell_2d_derive_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Convert primitive varibales to conservative variables.</p><a href="../proc/atl_eqn_maxwell_2d_prim2cons.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_eqn_maxwell_cons2prim.html'>atl_eqn_maxwell_cons2prim</a></td>
                 <td><a href='../module/atl_eqn_maxwell_derive_module.html'>atl_eqn_maxwell_derive_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Convert conservative to primitive variables.</p><a href="../proc/atl_eqn_maxwell_cons2prim.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_eqn_maxwell_implicit_pen.html'>atl_eqn_maxwell_implicit_pen</a></td>
                 <td><a href='../module/atl_eqn_maxwell_hlp_module.html'>atl_eqn_maxwell_hlp_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Solve the equation system with just the penalization terms to find an
implicit update for the IMEX timestepping procedure.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_eqn_maxwell_init.html'>atl_eqn_maxwell_init</a></td>
                 <td><a href='../module/atl_eqn_maxwell_hlp_module.html'>atl_eqn_maxwell_hlp_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Initialization of the Maxwell equations.</p><a href="../proc/atl_eqn_maxwell_init.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_eqn_maxwell_load_bc.html'>atl_eqn_maxwell_load_bc</a></td>
                 <td><a href='../module/atl_eqn_maxwell_hlp_module.html'>atl_eqn_maxwell_hlp_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Subroutine to load boundary conditions for Maxwell equations from
 a Lua configuration file.</p><a href="../proc/atl_eqn_maxwell_load_bc.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_eqn_maxwell_prim2cons.html'>atl_eqn_maxwell_prim2cons</a></td>
                 <td><a href='../module/atl_eqn_maxwell_derive_module.html'>atl_eqn_maxwell_derive_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Convert primitive varibales to conservative variables.</p><a href="../proc/atl_eqn_maxwell_prim2cons.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_eqn_maxwelldivcor_load_bc.html'>atl_eqn_maxwellDivCor_load_bc</a></td>
                 <td><a href='../module/atl_eqn_maxwell_hlp_module.html'>atl_eqn_maxwell_hlp_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Subroutine to load boundary conditions for Maxwell equations with divergence correction from
 a Lua configuration file. For the correction in E-field dirichlet bc and for correction in B-field
 neumann bc are defined.</p><a href="../proc/atl_eqn_maxwelldivcor_load_bc.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_eqn_maxwelldivcorr_cons2prim.html'>atl_eqn_maxwelldivcorr_cons2prim</a></td>
                 <td><a href='../module/atl_eqn_maxwelldivcorr_derive_module.html'>atl_eqn_maxwelldivcorr_derive_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Convert conservative to primitive variables.</p><a href="../proc/atl_eqn_maxwelldivcorr_cons2prim.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_eqn_maxwelldivcorr_prim2cons.html'>atl_eqn_maxwelldivcorr_prim2cons</a></td>
                 <td><a href='../module/atl_eqn_maxwelldivcorr_derive_module.html'>atl_eqn_maxwelldivcorr_derive_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Convert primitive varibales to conservative variables.</p><a href="../proc/atl_eqn_maxwelldivcorr_prim2cons.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_eqn_nvrstk_init.html'>atl_eqn_nvrstk_init</a></td>
                 <td><a href='../module/atl_eqn_nvrstk_hlp_module.html'>atl_eqn_nvrstk_hlp_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Initialization of the Navier-Stokes equations.</p><a href="../proc/atl_eqn_nvrstk_init.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_eqn_nvrstk_load_bc.html'>atl_eqn_nvrstk_load_bc</a></td>
                 <td><a href='../module/atl_eqn_nvrstk_hlp_module.html'>atl_eqn_nvrstk_hlp_module</a></td>
                 <td>Subroutine</td>
                 <td><p>VK! density for viscous terms
VKbc_state_gradient(1,1) = bc_state(1)
VKkvp%key = trim(bc_state_gradient(1,1)%state_name)
VKcall append( me = bc_varDict_gradient, val = kvp )</p><a href="../proc/atl_eqn_nvrstk_load_bc.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_eqn_rans_2d_cons2prim_elems.html'>atl_eqn_rans_2d_cons2prim_elems</a></td>
                 <td><a href='../module/atl_eqn_filnvrstk_derive_module.html'>atl_eqn_filNvrStk_derive_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Convert conservative to primitive variables.</p><a href="../proc/atl_eqn_rans_2d_cons2prim_elems.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_eqn_rans_2d_prim2cons_elems.html'>atl_eqn_rans_2d_prim2cons_elems</a></td>
                 <td><a href='../module/atl_eqn_filnvrstk_derive_module.html'>atl_eqn_filNvrStk_derive_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Convert primitive varibales to conservative variables.</p><a href="../proc/atl_eqn_rans_2d_prim2cons_elems.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_eqn_rans_cons2prim_elems.html'>atl_eqn_rans_cons2prim_elems</a></td>
                 <td><a href='../module/atl_eqn_filnvrstk_derive_module.html'>atl_eqn_filNvrStk_derive_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Convert conservative to primitive variables.</p><a href="../proc/atl_eqn_rans_cons2prim_elems.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_eqn_rans_load_bc.html'>atl_eqn_rans_load_bc</a></td>
                 <td><a href='../module/atl_eqn_filnvrstk_hlp_module.html'>atl_eqn_filnvrStk_hlp_module</a></td>
                 <td>Subroutine</td>
                 <td><p>VK    allocate(bc_normal_vec_gradient(2))
VK    allocate(bc_trafo_gradient(2))</p><a href="../proc/atl_eqn_rans_load_bc.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_eqn_rans_prim2cons_elems.html'>atl_eqn_rans_prim2cons_elems</a></td>
                 <td><a href='../module/atl_eqn_filnvrstk_derive_module.html'>atl_eqn_filNvrStk_derive_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Convert primitive varibales to conservative variables.</p><a href="../proc/atl_eqn_rans_prim2cons_elems.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_eqn_update_background.html'>atl_eqn_update_background</a></td>
                 <td><a href='../module/atl_eqn_lineareuler_module.html'>atl_eqn_LinearEuler_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Routine which updates the background since it is a temporal function and</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_eqn_write.html'>atl_eqn_write</a></td>
                 <td><a href='../module/atl_equation_init_module.html'>atl_equation_init_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_equation_evaluate_source_modal.html'>atl_equation_evaluate_source_modal</a></td>
                 <td><a href='../module/atl_equation_source_module.html'>atl_equation_source_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_equation_evaluate_source_nodal.html'>atl_equation_evaluate_source_nodal</a></td>
                 <td><a href='../module/atl_equation_source_module.html'>atl_equation_source_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_ere_dump_solstate.html'>atl_ere_dump_solState</a></td>
                 <td><a href='../module/atl_exact_riemann_euler_module.html'>atl_exact_riemann_euler_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_ere_eval_onedge.html'>atl_ere_eval_onEdge</a></td>
                 <td><a href='../module/atl_exact_riemann_euler_module.html'>atl_exact_riemann_euler_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Evaluate the state on the edge using the exact riemann solver</p><a href="../proc/atl_ere_eval_onedge.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_ere_init.html'>atl_ere_init</a></td>
                 <td><a href='../module/atl_exact_riemann_euler_module.html'>atl_exact_riemann_euler_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Compute the exact solution of the Riemann problem for the Euler equation.</p><a href="../proc/atl_ere_init.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_ere_init_consts.html'>atl_ere_init_consts</a></td>
                 <td><a href='../module/atl_exact_riemann_euler_module.html'>atl_exact_riemann_euler_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Set the general constants for the exact riemann solver.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_ere_sample.html'>atl_ere_sample</a></td>
                 <td><a href='../module/atl_exact_riemann_euler_module.html'>atl_exact_riemann_euler_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Evaluate the solution to the 1D Riemann problem for a given sample point s.</p><a href="../proc/atl_ere_sample.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_eval_force.html'>atl_eval_force</a></td>
                 <td><a href='../module/atl_eqn_acoustic_var_module.html'>atl_eqn_acoustic_var_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_eval_massinjection.html'>atl_eval_massInjection</a></td>
                 <td><a href='../module/atl_eqn_acoustic_var_module.html'>atl_eqn_acoustic_var_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_eval_source_currentdensity.html'>atl_eval_source_currentDensity</a></td>
                 <td><a href='../module/atl_eqn_maxwell_var_module.html'>atl_eqn_maxwell_var_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_eval_source_currentdensity_2d.html'>atl_eval_source_currentDensity_2d</a></td>
                 <td><a href='../module/atl_eqn_maxwell_2d_var_module.html'>atl_eqn_maxwell_2d_var_module</a></td>
                 <td>Subroutine</td>
                 <td><p>evaluate "currentDensity" source</p><a href="../proc/atl_eval_source_currentdensity_2d.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_eval_source_force.html'>atl_eval_source_force</a></td>
                 <td><a href='../module/atl_eqn_acoustic_var_module.html'>atl_eqn_acoustic_var_module</a></td>
                 <td>Subroutine</td>
                 <td><p>evaluate "currentDensity" source</p><a href="../proc/atl_eval_source_force.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_eval_source_force_2d.html'>atl_eval_source_force_2D</a></td>
                 <td><a href='../module/atl_eqn_acoustic_2d_var_module.html'>atl_eqn_acoustic_2d_var_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_eval_source_massinjection.html'>atl_eval_source_massInjection</a></td>
                 <td><a href='../module/atl_eqn_acoustic_var_module.html'>atl_eqn_acoustic_var_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_eval_source_massinjection_2d.html'>atl_eval_source_massInjection_2D</a></td>
                 <td><a href='../module/atl_eqn_acoustic_2d_var_module.html'>atl_eqn_acoustic_2d_var_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_eval_source_spongelayer.html'>atl_eval_source_spongeLayer</a></td>
                 <td><a href='../module/atl_eqn_sponge_module.html'>atl_eqn_sponge_module</a></td>
                 <td>Subroutine</td>
                 <td><p>PV: Create a unit test for this routine and compare it to the
version before the new varSys</p><a href="../proc/atl_eval_source_spongelayer.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_eval_source_spongelayer_2d.html'>atl_eval_source_spongeLayer_2d</a></td>
                 <td><a href='../module/atl_eqn_sponge_module.html'>atl_eqn_sponge_module</a></td>
                 <td>Subroutine</td>
                 <td><p>PV: Create a unit test for this routine and compare it to the
version before the new varSys</p><a href="../proc/atl_eval_source_spongelayer_2d.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_eval_sponge.html'>atl_eval_sponge</a></td>
                 <td><a href='../module/atl_eqn_sponge_module.html'>atl_eqn_sponge_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_evalelemmaterial.html'>atl_evalElemMaterial</a></td>
                 <td><a href='../module/atl_materialini_module.html'>atl_materialIni_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Evaluates the material properties for all elements contained
 in the computeElems variable of the material_desc datatype.</p><a href="../proc/atl_evalelemmaterial.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_evalfacematerial.html'>atl_evalFaceMaterial</a></td>
                 <td><a href='../module/atl_materialini_module.html'>atl_materialIni_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Subroutine to evaluate the material properties on the nodes
of the compute faces (left and right element's trace).</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_evallegendretenspoly1d.html'>atl_evalLegendreTensPoly1d</a></td>
                 <td><a href='../module/atl_modg_1d_basis_module.html'>atl_modg_1d_basis_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_evallegendretenspoly2d.html'>atl_evalLegendreTensPoly2d</a></td>
                 <td><a href='../module/atl_modg_2d_basis_module.html'>atl_modg_2d_basis_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_extend_covol_face.html'>atl_extend_covol_face</a></td>
                 <td><a href='../module/atl_covolume_boundary_module.html'>atl_covolume_boundary_module</a></td>
                 <td>Function</td>
                 <td><p>Lift face data to volume data.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_extend_covol_face_1d.html'>atl_extend_covol_face_1d</a></td>
                 <td><a href='../module/atl_covolume_boundary_module.html'>atl_covolume_boundary_module</a></td>
                 <td>Function</td>
                 <td><p>Lift face data to volume data.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_extend_covol_face_2d.html'>atl_extend_covol_face_2d</a></td>
                 <td><a href='../module/atl_covolume_boundary_module.html'>atl_covolume_boundary_module</a></td>
                 <td>Function</td>
                 <td><p>Lift face data to volume data.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_fill_bcindex.html'>atl_fill_BCIndex</a></td>
                 <td><a href='../module/atl_boundary_module.html'>atl_boundary_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_fill_sourceindex.html'>atl_fill_sourceIndex</a></td>
                 <td><a href='../module/atl_source_module.html'>atl_source_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Create source elements list for given source variable</p><a href="../proc/atl_fill_sourceindex.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_finalize_program.html'>atl_finalize_program</a></td>
                 <td><a href='../module/atl_program_module.html'>atl_program_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_flux_initgodunov.html'>atl_flux_initGodunov</a></td>
                 <td><a href='../module/atl_godunovflux_module.html'>atl_GodunovFlux_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_generic_fromconst_getelement.html'>atl_generic_fromConst_getElement</a></td>
                 <td><a href='../module/atl_varsys_module.html'>atl_varSys_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Routine to obtain a modal representation for a variable, which is only
available in nodal form, like space-time functions.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_generic_frommodal_getelement.html'>atl_generic_fromModal_getElement</a></td>
                 <td><a href='../module/atl_derive_module.html'>atl_derive_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine prepares the data for variable derivation or operators. It
gathers all input variables from the variable system, oversamples and
projects them into nodal space, calls the function with the actual
calculation and projects the results back into modal space.
As these projections are common to all elementwise variable accesses, this
generic routine does all necessary operations in a generic way.</p><a href="../proc/atl_generic_frommodal_getelement.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_generic_fromnodal_getelement.html'>atl_generic_fromNodal_getElement</a></td>
                 <td><a href='../module/atl_varsys_module.html'>atl_varSys_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Routine to obtain a modal representation for a variable, which is only
 available in nodal form, like space-time functions.</p><a href="../proc/atl_generic_fromnodal_getelement.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_get_cpl_elemtimers.html'>atl_get_cpl_elemTimers</a></td>
                 <td><a href='../module/atl_timer_module.html'>atl_timer_module</a></td>
                 <td>Function</td>
                 <td><p>This function returns local modular variable atl_elemTimers to apesmate</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_get_elemtimers.html'>atl_get_elemTimers</a></td>
                 <td><a href='../module/atl_timer_module.html'>atl_timer_module</a></td>
                 <td>Function</td>
                 <td><p>This function returns local modular variable atl_elemTimers to apesmate</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_get_lower_bound_turb_disscipation.html'>atl_get_lower_bound_turb_disscipation</a></td>
                 <td><a href='../module/atl_eqn_filnvrstk_var_module.html'>atl_eqn_filNvrStk_var_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_get_new_varsys_data_ptr.html'>atl_get_new_varSys_data_ptr</a></td>
                 <td><a href='../module/atl_varsys_module.html'>atl_varSys_module</a></td>
                 <td>Function</td>
                 <td><p>Routine to get a pointer to a new instance of atl_varSys_data_type to be
 used as method data for a variable in the variable system.</p><a href="../proc/atl_get_new_varsys_data_ptr.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_get_numberofelemsperlevel.html'>atl_get_numberOfElemsPerLevel</a></td>
                 <td><a href='../module/atl_cube_elem_module.html'>atl_cube_elem_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Subroutine to count the number of elements per level.</p><a href="../proc/atl_get_numberofelemsperlevel.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_get_numbndelems.html'>atl_get_numBndElems</a></td>
                 <td><a href='../module/atl_boundary_module.html'>atl_boundary_module</a></td>
                 <td>Function</td>
                 <td><p>Get the number of (virtual) boundary elements for each level and each
direction.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_get_penaltyip_2d.html'>atl_get_penaltyIP_2d</a></td>
                 <td><a href='../module/atl_modg_2d_navierstokes_kernel_module.html'>atl_modg_2d_navierstokes_kernel_module</a></td>
                 <td>Function</td>
                 <td><p>Return the penalty parameter for the IP discretizations of higher order
equations.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_get_points_from_bc.html'>atl_get_points_from_BC</a></td>
                 <td><a href='../module/atl_boundary_module.html'>atl_boundary_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Get all the surface points for a specific boundary.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_get_pointwise_velocity_gradient_2d.html'>atl_get_pointwise_velocity_gradient_2D</a></td>
                 <td><a href='../module/atl_eqn_filnvrstk_var_module.html'>atl_eqn_filNvrStk_var_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_get_pointwise_visc_stress_tensor_2d.html'>atl_get_pointwise_visc_stress_tensor_2D</a></td>
                 <td><a href='../module/atl_eqn_filnvrstk_var_module.html'>atl_eqn_filNvrStk_var_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_get_timerhandles.html'>atl_get_timerHandles</a></td>
                 <td><a href='../module/atl_timer_module.html'>atl_timer_module</a></td>
                 <td>Function</td>
                 <td><p>This function returns local modular variable atl_timerHandles to apesmate</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_get_timestep.html'>atl_get_timestep</a></td>
                 <td><a href='../module/atl_calc_time_module.html'>atl_calc_time_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Subrountine which gather all calls to get the timestep for the current
iteration</p><a href="../proc/atl_get_timestep.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_geteulerfluxes.html'>atl_getEulerFluxes</a></td>
                 <td><a href='../module/atl_eqn_euler_hlp_module.html'>atl_eqn_euler_hlp_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_geteulerlinind.html'>atl_getEulerLinInd</a></td>
                 <td><a href='../module/atl_eqn_euler_hlp_module.html'>atl_eqn_euler_hlp_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Getting the linearization indicator for Euler equations from the config.</p><a href="../proc/atl_geteulerlinind.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_getlineareulerfluxes.html'>atl_getLinearEulerFluxes</a></td>
                 <td><a href='../module/atl_eqn_lineareuler_hlp_module.html'>atl_eqn_LinearEuler_hlp_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_getmaterialforelement.html'>atl_getMaterialForElement</a></td>
                 <td><a href='../module/atl_materialini_module.html'>atl_materialIni_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine implements the getElement interface for material variables.</p><a href="../proc/atl_getmaterialforelement.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_getmaterialforpoint.html'>atl_getMaterialForPoint</a></td>
                 <td><a href='../module/atl_materialini_module.html'>atl_materialIni_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine implements the getPoint interface for material variables.</p><a href="../proc/atl_getmaterialforpoint.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_getmaxpropspeed.html'>atl_getMaxPropSpeed</a></td>
                 <td><a href='../module/atl_eqn_maxwell_var_module.html'>atl_eqn_maxwell_var_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Determines maximum propagation speed, i.e. the speed of light depends only
on material parameters.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_getmaxpropspeeddivcor.html'>atl_getMaxPropSpeedDivCor</a></td>
                 <td><a href='../module/atl_eqn_maxwelldivcorr_var_module.html'>atl_eqn_maxwelldivcorr_var_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Determines maximum propagation speed for Maxwell equation
with divergence cleaning (hyperbolic), i.e. the speed of light depends only
on material parameters.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_getweights.html'>atl_getWeights</a></td>
                 <td><a href='../module/atl_weights_module.html'>atl_weights_module</a></td>
                 <td>Subroutine</td>
                 <td><p>boundary timer should only be measured for boundary elements
VK    setBnd = tem_getTimerVal( timerHandle = atl_timerHandles%setBnd)
VK    readBC = tem_getTimerVal( timerHandle = atl_timerHandles%readBC)</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_global_time_integration_load.html'>atl_global_time_integration_load</a></td>
                 <td><a href='../module/atl_global_time_integration_module.html'>atl_global_time_integration_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Routine to load the timestepping scheme from the config.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_godunoveuler.html'>atl_GodunovEuler</a></td>
                 <td><a href='../module/atl_godunovflux_module.html'>atl_GodunovFlux_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Godunov flux for the Euler equation.</p><a href="../proc/atl_godunoveuler.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_godunoveuler1d.html'>atl_GodunovEuler1D</a></td>
                 <td><a href='../module/atl_godunovflux_module.html'>atl_GodunovFlux_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Godunov flux for the 1D Euler equation.</p><a href="../proc/atl_godunoveuler1d.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_godunoveuler2d.html'>atl_GodunovEuler2D</a></td>
                 <td><a href='../module/atl_godunovflux_module.html'>atl_GodunovFlux_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Godunov flux for the 2D Euler equation.</p><a href="../proc/atl_godunoveuler2d.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_hlleuler.html'>atl_HLLEuler</a></td>
                 <td><a href='../module/atl_hlleflux_module.html'>atl_hlleFlux_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate the HLL flux given the left an right state.</p><a href="../proc/atl_hlleuler.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_hlleuler1d.html'>atl_HLLEuler1D</a></td>
                 <td><a href='../module/atl_hlleflux_module.html'>atl_hlleFlux_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate the 1D HLL flux given the left an right state.</p><a href="../proc/atl_hlleuler1d.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_hlleuler2d.html'>atl_HLLEuler2D</a></td>
                 <td><a href='../module/atl_hlleflux_module.html'>atl_hlleFlux_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate the 2D HLL flux given the left an right state.</p><a href="../proc/atl_hlleuler2d.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_ini_cons_positivity_preserv.html'>atl_ini_cons_positivity_preserv</a></td>
                 <td><a href='../module/atl_cons_positivity_preserv_module.html'>atl_cons_positivity_preserv_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Subroutine to load configuration file options for the conservative
positivity preserving limiter.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_ini_covolume.html'>atl_ini_covolume</a></td>
                 <td><a href='../module/atl_covolume_module.html'>atl_covolume_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Subroutine to load configuration file options for the
covolume filter method.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_ini_positivity_preserv.html'>atl_ini_positivity_preserv</a></td>
                 <td><a href='../module/atl_positivity_preserv_module.html'>atl_positivity_preserv_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Subroutine to load configuration file options for the spectral
viscosity method.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_ini_spectral_visc.html'>atl_ini_spectral_visc</a></td>
                 <td><a href='../module/atl_spectral_viscosity_module.html'>atl_spectral_viscosity_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Subroutine to load configuration file options for the spectral
viscosity method.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_ini_stabilization.html'>atl_ini_stabilization</a></td>
                 <td><a href='../module/atl_stabilization_module.html'>atl_stabilization_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_init_acoustic_2d_sourceterms.html'>atl_init_acoustic_2d_sourceTerms</a></td>
                 <td><a href='../module/atl_eqn_acoustic_2d_var_module.html'>atl_eqn_acoustic_2d_var_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Init source terms for flow simulations.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_init_acoustic_2d_vars.html'>atl_init_acoustic_2d_vars</a></td>
                 <td><a href='../module/atl_eqn_acoustic_2d_var_module.html'>atl_eqn_acoustic_2d_var_module</a></td>
                 <td>Subroutine</td>
                 <td><p>\brief init the variables for acoustic equation</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_init_acoustic_sourceterms.html'>atl_init_acoustic_sourceTerms</a></td>
                 <td><a href='../module/atl_eqn_acoustic_var_module.html'>atl_eqn_acoustic_var_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Init source terms for flow simulations.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_init_acoustic_vars.html'>atl_init_acoustic_vars</a></td>
                 <td><a href='../module/atl_eqn_acoustic_var_module.html'>atl_eqn_acoustic_var_module</a></td>
                 <td>Subroutine</td>
                 <td><p>init the variables for acoustic equation</p><a href="../proc/atl_init_acoustic_vars.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_init_advection_1d_vars.html'>atl_init_advection_1d_vars</a></td>
                 <td><a href='../module/atl_eqn_advection_1d_var_module.html'>atl_eqn_advection_1d_var_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Init the variable system for simulations of advection equation.</p><a href="../proc/atl_init_advection_1d_vars.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_init_bndlist.html'>atl_init_bndList</a></td>
                 <td><a href='../module/atl_boundary_module.html'>atl_boundary_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Subroutine to create the levelwise list of boundaries.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_init_cellstatebuffer.html'>atl_init_cellStateBuffer</a></td>
                 <td><a href='../module/atl_parallel_module.html'>atl_parallel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Initialize the parallel module to make it usable in ATELES.</p><a href="../proc/atl_init_cellstatebuffer.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_init_cube_container.html'>atl_init_cube_container</a></td>
                 <td><a href='../module/atl_cube_container_module.html'>atl_cube_container_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Method to initialize a cube mesh by tree and boundary
 definitions obtained by treelm.</p><a href="../proc/atl_init_cube_container.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_init_cube_elem.html'>atl_init_cube_elem</a></td>
                 <td><a href='../module/atl_cube_elem_module.html'>atl_cube_elem_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Initialize the cubic elements.</p><a href="../proc/atl_init_cube_elem.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_init_elem_bnd.html'>atl_init_elem_bnd</a></td>
                 <td><a href='../module/atl_boundary_module.html'>atl_boundary_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Creates boundary informations for the faces.</p><a href="../proc/atl_init_elem_bnd.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_init_elem_container.html'>atl_init_elem_container</a></td>
                 <td><a href='../module/atl_container_module.html'>atl_container_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Initialize the container module.</p><a href="../proc/atl_init_elem_container.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_init_equation.html'>atl_init_equation</a></td>
                 <td><a href='../module/atl_equation_init_module.html'>atl_equation_init_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This subroutine reads the equation system to solve from the configuration.</p><a href="../proc/atl_init_equation.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_init_euler_1d_sourceterms.html'>atl_init_euler_1d_sourceTerms</a></td>
                 <td><a href='../module/atl_eqn_euler_1d_var_module.html'>atl_eqn_euler_1d_var_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine initializes possible source variables and returns the filled
up list of the poss_srcVars</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_init_euler_1d_vars.html'>atl_init_euler_1d_vars</a></td>
                 <td><a href='../module/atl_eqn_euler_1d_var_module.html'>atl_eqn_euler_1d_var_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Init the variable system for Euler (inviscid) flow simulations.</p><a href="../proc/atl_init_euler_1d_vars.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_init_euler_2d_sourceterms.html'>atl_init_euler_2d_sourceTerms</a></td>
                 <td><a href='../module/atl_eqn_euler_2d_var_module.html'>atl_eqn_euler_2d_var_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine initializes possible source variables and returns the filled
up list of the poss_srcVars</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_init_euler_2d_vars.html'>atl_init_euler_2d_vars</a></td>
                 <td><a href='../module/atl_eqn_euler_2d_var_module.html'>atl_eqn_euler_2d_var_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Init the variable system for Euler (inviscid) flow simulations.</p><a href="../proc/atl_init_euler_2d_vars.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_init_euler_material.html'>atl_init_euler_material</a></td>
                 <td><a href='../module/atl_eqn_euler_var_module.html'>atl_eqn_euler_var_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Adds the properties of the expected source terms to the list of possible
variables to extract these expected variables later on from the
configuration file.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_init_euler_sourceterms.html'>atl_init_euler_sourceTerms</a></td>
                 <td><a href='../module/atl_eqn_euler_var_module.html'>atl_eqn_euler_var_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Init source terms for flow simulations.
This routine initializes possible source variables and returns the filled
up list of the poss_srcVars</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_init_euler_vars.html'>atl_init_euler_vars</a></td>
                 <td><a href='../module/atl_eqn_euler_var_module.html'>atl_eqn_euler_var_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Init the variable system for Euler (inviscid) flow simulations.</p><a href="../proc/atl_init_euler_vars.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_init_explicit_ssprk.html'>atl_init_explicit_ssprk</a></td>
                 <td><a href='../module/atl_ssprk2_module.html'>atl_ssprk2_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Routine to initialize explicit runge kutta scheme for timestepping.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_init_expliciteuler.html'>atl_init_explicitEuler</a></td>
                 <td><a href='../module/atl_fwdeuler_module.html'>atl_fwdEuler_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Initialize explicit euler scheme for timestepping.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_init_explicitlocalpredictorglobalcorrector.html'>atl_init_explicitLocalPredictorGlobalCorrector</a></td>
                 <td><a href='../module/atl_predcor_cerk4_module.html'>atl_predcor_cerk4_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Routine to initialize explicit runge kutta scheme for timestepping.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_init_explicitrungekutta.html'>atl_init_explicitRungeKutta</a></td>
                 <td><a href='../module/atl_rk4_module.html'>atl_rk4_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Routine to initialize explicit runge kutta scheme for timestepping.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_init_explicitrungekuttataylor.html'>atl_init_explicitRungeKuttaTaylor</a></td>
                 <td><a href='../module/atl_rktaylor_module.html'>atl_rktaylor_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Routine to initialize explicit runge kutta taylor scheme for timestepping.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_init_face_bnd.html'>atl_init_face_bnd</a></td>
                 <td><a href='../module/atl_boundary_module.html'>atl_boundary_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Creates boundary informations for the faces.</p><a href="../proc/atl_init_face_bnd.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../interface/atl_init_facedata.html'>atl_init_facedata</a></td>
                 <td><a href='../module/atl_facedata_module.html'>atl_facedata_module</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_init_facedata_asym.html'>atl_init_facedata_asym</a></td>
                 <td><a href='../module/atl_facedata_module.html'>atl_facedata_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Initializes the face data by a given set of faces (asymmetrically).</p><a href="../proc/atl_init_facedata_asym.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_init_facedata_sym.html'>atl_init_facedata_sym</a></td>
                 <td><a href='../module/atl_facedata_module.html'>atl_facedata_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Initializes the face data by a given set of faces.</p><a href="../proc/atl_init_facedata_sym.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_init_facerep.html'>atl_init_facerep</a></td>
                 <td><a href='../module/atl_facedata_module.html'>atl_facedata_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Initializes the face data by a given set of faces.</p><a href="../proc/atl_init_facerep.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_init_facestatebuffer.html'>atl_init_faceStateBuffer</a></td>
                 <td><a href='../module/atl_parallel_module.html'>atl_parallel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>initializes the face buffers for communication.</p><a href="../proc/atl_init_facestatebuffer.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_init_filnvrstk_sourceterms.html'>atl_init_filNvrStk_sourceTerms</a></td>
                 <td><a href='../module/atl_eqn_filnvrstk_var_module.html'>atl_eqn_filNvrStk_var_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Init source terms for flow simulations.
This routine initializes possible source variables and returns the filled
up list of the poss_srcVars</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_init_global_time_integration.html'>atl_init_global_time_integration</a></td>
                 <td><a href='../module/atl_global_time_integration_module.html'>atl_global_time_integration_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Routine to init the timestepping scheme.</p><a href="../proc/atl_init_global_time_integration.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_init_heat_1d_vars.html'>atl_init_heat_1d_vars</a></td>
                 <td><a href='../module/atl_eqn_heat_1d_var_module.html'>atl_eqn_heat_1d_var_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Init the variable system for simulations of Heat equation.</p><a href="../proc/atl_init_heat_1d_vars.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_init_heat_2d_vars.html'>atl_init_heat_2d_vars</a></td>
                 <td><a href='../module/atl_eqn_heat_2d_var_module.html'>atl_eqn_heat_2d_var_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Init the variable system for simulations of Heat equation.</p><a href="../proc/atl_init_heat_2d_vars.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_init_heat_vars.html'>atl_init_heat_vars</a></td>
                 <td><a href='../module/atl_eqn_heat_var_module.html'>atl_eqn_heat_var_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Init the variable system for simulations of Heat equation.</p><a href="../proc/atl_init_heat_vars.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_init_imexrungekutta.html'>atl_init_imexRungeKutta</a></td>
                 <td><a href='../module/atl_imexrk_module.html'>atl_imexrk_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Routine to initialize IMEX Runge-Kutta scheme for timestepping.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_init_kerneldata.html'>atl_init_kerneldata</a></td>
                 <td><a href='../module/atl_kerneldata_module.html'>atl_kerneldata_module</a></td>
                 <td>Subroutine</td>
                 <td><p>init routine for the kerneldata type.</p><a href="../proc/atl_init_kerneldata.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_init_lineareuler_2d_vars.html'>atl_init_LinearEuler_2d_vars</a></td>
                 <td><a href='../module/atl_eqn_lineareuler_2d_var_module.html'>atl_eqn_LinearEuler_2d_var_module</a></td>
                 <td>Subroutine</td>
                 <td><p>init the variables for LinearEuler equation</p><a href="../proc/atl_init_lineareuler_2d_vars.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_init_lineareuler_vars.html'>atl_init_LinearEuler_vars</a></td>
                 <td><a href='../module/atl_eqn_lineareuler_var_module.html'>atl_eqn_LinearEuler_var_module</a></td>
                 <td>Subroutine</td>
                 <td><p>init the variables for LinearEuler equation</p><a href="../proc/atl_init_lineareuler_vars.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_init_lineuler_sourceterms.html'>atl_init_lineuler_sourceTerms</a></td>
                 <td><a href='../module/atl_eqn_lineareuler_var_module.html'>atl_eqn_LinearEuler_var_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Init source terms for flow simulations.
This routine initializes possible source variables and returns the filled
up list of the poss_srcVars</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_init_materialparams.html'>atl_init_materialParams</a></td>
                 <td><a href='../module/atl_materialini_module.html'>atl_materialIni_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Read the configuration for the material paramters for Maxwell equations
from configuration files and init the material parameter datatype.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_init_maxwell_2d_sourceterms.html'>atl_init_maxwell_2d_sourceTerms</a></td>
                 <td><a href='../module/atl_eqn_maxwell_2d_var_module.html'>atl_eqn_maxwell_2d_var_module</a></td>
                 <td>Subroutine</td>
                 <td><p>init source terms for electrodynamic simulations.</p><a href="../proc/atl_init_maxwell_2d_sourceterms.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_init_maxwell_2d_vars.html'>atl_init_maxwell_2d_vars</a></td>
                 <td><a href='../module/atl_eqn_maxwell_2d_var_module.html'>atl_eqn_maxwell_2d_var_module</a></td>
                 <td>Subroutine</td>
                 <td><p>init the variables for maxwell equation (2D, TE-mode formulation).</p><a href="../proc/atl_init_maxwell_2d_vars.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_init_maxwell_material.html'>atl_init_maxwell_material</a></td>
                 <td><a href='../module/atl_eqn_maxwell_var_module.html'>atl_eqn_maxwell_var_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Adds the properties of the expected source terms to the list of possible
variables to extract these expected variables later on from the
configuration file.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_init_maxwell_sourceterms.html'>atl_init_maxwell_sourceTerms</a></td>
                 <td><a href='../module/atl_eqn_maxwell_var_module.html'>atl_eqn_maxwell_var_module</a></td>
                 <td>Subroutine</td>
                 <td><p>init source terms for electrodynamic simulations.</p><a href="../proc/atl_init_maxwell_sourceterms.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_init_maxwell_vars.html'>atl_init_maxwell_vars</a></td>
                 <td><a href='../module/atl_eqn_maxwell_var_module.html'>atl_eqn_maxwell_var_module</a></td>
                 <td>Subroutine</td>
                 <td><p>init the variables for maxwell equation</p><a href="../proc/atl_init_maxwell_vars.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_init_maxwelldivcorr_material.html'>atl_init_maxwellDivCorr_material</a></td>
                 <td><a href='../module/atl_eqn_maxwelldivcorr_var_module.html'>atl_eqn_maxwelldivcorr_var_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Adds the properties of the expected source terms to the list of possible
variables to extract these expected variables later on from the
configuration file.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_init_maxwelldivcorr_sourceterms.html'>atl_init_maxwellDivCorr_sourceTerms</a></td>
                 <td><a href='../module/atl_eqn_maxwelldivcorr_var_module.html'>atl_eqn_maxwelldivcorr_var_module</a></td>
                 <td>Subroutine</td>
                 <td><p>init source terms for electrodynamic simulations with divergence</p><a href="../proc/atl_init_maxwelldivcorr_sourceterms.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_init_maxwelldivcorr_vars.html'>atl_init_maxwellDivCorr_vars</a></td>
                 <td><a href='../module/atl_eqn_maxwelldivcorr_var_module.html'>atl_eqn_maxwelldivcorr_var_module</a></td>
                 <td>Subroutine</td>
                 <td><p>init the variables for maxwell equation</p><a href="../proc/atl_init_maxwelldivcorr_vars.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_init_modg_1d_kernel.html'>atl_init_modg_1d_kernel</a></td>
                 <td><a href='../module/atl_modg_1d_kernel_module.html'>atl_modg_1d_kernel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Initiate the MODG kernel for cubic elements on all levels.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_init_modg_2d_kernel.html'>atl_init_modg_2d_kernel</a></td>
                 <td><a href='../module/atl_modg_2d_kernel_module.html'>atl_modg_2d_kernel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Initiate the MODG kernel for cubic elements on all levels.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_init_modg_kernel.html'>atl_init_modg_kernel</a></td>
                 <td><a href='../module/atl_modg_kernel_module.html'>atl_modg_kernel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Initiate the MODG kernel for cubic elements on all levels.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_init_nerplanck_vars.html'>atl_init_nerplanck_vars</a></td>
                 <td><a href='../module/atl_eqn_nerplanck_var_module.html'>atl_eqn_nerplanck_var_module</a></td>
                 <td>Subroutine</td>
                 <td><p>init the variables for nernst-planck equation</p><a href="../proc/atl_init_nerplanck_vars.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_init_parallel_module.html'>atl_init_parallel_module</a></td>
                 <td><a href='../module/atl_parallel_module.html'>atl_parallel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>initialize the parallel module to make it usable in ATELES</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_init_penalization.html'>atl_init_penalization</a></td>
                 <td><a href='../module/atl_penalization_module.html'>atl_penalization_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Routine to init container for penalization data.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_init_physcheck.html'>atl_init_physCheck</a></td>
                 <td><a href='../module/atl_physcheck_module.html'>atl_physCheck_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Read the info for the physical checks from the configuration file</p><a href="../proc/atl_init_physcheck.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_init_precice.html'>atl_init_precice</a></td>
                 <td><a href='../module/atl_precice_module.html'>atl_precice_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Read from preCICE the requested points</p><a href="../proc/atl_init_precice.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_init_rans_2d_vars.html'>atl_init_rans_2d_vars</a></td>
                 <td><a href='../module/atl_eqn_filnvrstk_var_module.html'>atl_eqn_filNvrStk_var_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_init_rans_closure_coeffs.html'>atl_init_RANS_closure_coeffs</a></td>
                 <td><a href='../module/atl_eqn_filnvrstk_var_module.html'>atl_eqn_filNvrStk_var_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_init_rans_vars.html'>atl_init_Rans_vars</a></td>
                 <td><a href='../module/atl_eqn_filnvrstk_var_module.html'>atl_eqn_filNvrStk_var_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Init the variable system for filtered NavierStokes equation.</p><a href="../proc/atl_init_rans_vars.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_init_scheme.html'>atl_init_scheme</a></td>
                 <td><a href='../module/atl_scheme_module.html'>atl_scheme_module</a></td>
                 <td>Subroutine</td>
                 <td><p>subroutine to intialize a scheme as specified by a given lua script file.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_init_spacebasis.html'>atl_init_spacebasis</a></td>
                 <td><a href='../module/atl_space_basis.html'>atl_space_basis</a></td>
                 <td>Subroutine</td>
                 <td><p>Initialize the space basis, this subroutine has to be called before
using the module variable space_basis#basis.</p><a href="../proc/atl_init_spacebasis.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_init_statedata.html'>atl_init_statedata</a></td>
                 <td><a href='../module/atl_kerneldata_module.html'>atl_kerneldata_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Initialize the statedata.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_init_varsys_solverdata.html'>atl_init_varSys_solverData</a></td>
                 <td><a href='../module/atl_varsys_module.html'>atl_varSys_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_initcoordinaterotations.html'>atl_initCoordinateRotations</a></td>
                 <td><a href='../module/atl_equation_init_module.html'>atl_equation_init_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_initialize.html'>atl_initialize</a></td>
                 <td><a href='../module/atl_initialize_module.html'>atl_initialize_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Routine to initialize the complete Ateles solver.</p><a href="../proc/atl_initialize.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_initialize_program.html'>atl_initialize_program</a></td>
                 <td><a href='../module/atl_program_module.html'>atl_program_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_initialize_sources.html'>atl_initialize_sources</a></td>
                 <td><a href='../module/atl_source_module.html'>atl_source_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_initialize_state_der.html'>atl_initialize_state_der</a></td>
                 <td><a href='../module/atl_compute_module.html'>atl_compute_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine is used to initialize an array in an OpenMP PARALLEL region.
Usually this is done using a WORKSHARE directive, but due to a bug in
Intel 15 we cannot make use of WORKSHARE.</p><a href="../proc/atl_initialize_state_der.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_initrestart.html'>atl_initRestart</a></td>
                 <td><a href='../module/atl_restart_module.html'>atl_restart_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Initializes writing restart files, if activated.</p><a href="../proc/atl_initrestart.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_inittimestepinfo.html'>atl_initTimeStepInfo</a></td>
                 <td><a href='../module/atl_global_time_integration_module.html'>atl_global_time_integration_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Subroutine to initialize the timestep information for the first iteration</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_initweights.html'>atl_initWeights</a></td>
                 <td><a href='../module/atl_weights_module.html'>atl_weights_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_interpolate_elemstate.html'>atl_interpolate_elemstate</a></td>
                 <td><a href='../module/atl_stabilize_module.html'>atl_stabilize_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Recursive interpolation of element states among the levels of the
mesh.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_kerneldata_update_estimates.html'>atl_kerneldata_update_estimates</a></td>
                 <td><a href='../module/atl_kerneldata_module.html'>atl_kerneldata_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_kerneldata_update_maxdev.html'>atl_kerneldata_update_maxdev</a></td>
                 <td><a href='../module/atl_kerneldata_module.html'>atl_kerneldata_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Find the maximal deviation for the polynomials representing the state
in each element.</p><a href="../proc/atl_kerneldata_update_maxdev.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_kerneldata_update_maxgrad.html'>atl_kerneldata_update_maxgrad</a></td>
                 <td><a href='../module/atl_kerneldata_module.html'>atl_kerneldata_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Find the maximal gradient estimation for the polynomials representing
the state in each element.</p><a href="../proc/atl_kerneldata_update_maxgrad.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_kineticenergy_getelement.html'>atl_kineticEnergy_getElement</a></td>
                 <td><a href='../module/atl_eqn_euler_derive_module.html'>atl_eqn_euler_derive_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_kineticenergy_getpoint.html'>atl_KineticEnergy_getPoint</a></td>
                 <td><a href='../module/atl_eqn_euler_derive_module.html'>atl_eqn_euler_derive_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_lambda2_getelement.html'>atl_lambda2_getElement</a></td>
                 <td><a href='../module/atl_eqn_euler_derive_module.html'>atl_eqn_euler_derive_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_lambda2_getpoint.html'>atl_lambda2_getPoint</a></td>
                 <td><a href='../module/atl_eqn_euler_derive_module.html'>atl_eqn_euler_derive_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_laxfriedacoustic.html'>atl_laxFriedAcoustic</a></td>
                 <td><a href='../module/atl_laxfriedrichflux_module.html'>atl_laxFriedrichFlux_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Lax-Friedrich flux (in fully conservative variables) for the Acoustic equation</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_laxfriedeuler.html'>atl_laxFriedEuler</a></td>
                 <td><a href='../module/atl_laxfriedrichflux_module.html'>atl_laxFriedrichFlux_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Lax-Friedrich flux (in fully conservative variables) for the Euler equation</p><a href="../proc/atl_laxfriedeuler.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_laxfriedeuler_1d.html'>atl_laxFriedEuler_1d</a></td>
                 <td><a href='../module/atl_laxfriedrichflux_1d_module.html'>atl_laxFriedrichFlux_1d_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Lax-Friedrich flux (in fully conservative variables) for the 1D Euler
equation</p><a href="../proc/atl_laxfriedeuler_1d.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_laxfriedeuler_2d.html'>atl_laxFriedEuler_2d</a></td>
                 <td><a href='../module/atl_laxfriedrichflux_2d_module.html'>atl_laxFriedrichFlux_2d_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Lax-Friedrich flux (in fully conservative variables) for the 2D Euler
equation</p><a href="../proc/atl_laxfriedeuler_2d.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_laxfriedlineareuler.html'>atl_laxFriedLinearEuler</a></td>
                 <td><a href='../module/atl_laxfriedrichflux_module.html'>atl_laxFriedrichFlux_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Lax-Friedrich flux (in fully conservative variables) for the</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_laxfriedlineareuler_2d.html'>atl_laxFriedLinearEuler_2d</a></td>
                 <td><a href='../module/atl_laxfriedrichflux_2d_module.html'>atl_laxFriedrichFlux_2d_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Lax-Friedrich flux (in fully conservative variables) for the</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_laxfriedrans.html'>atl_laxFriedRans</a></td>
                 <td><a href='../module/atl_laxfriedrichflux_module.html'>atl_laxFriedrichFlux_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Lax-Friedrich flux (in fully conservative variables) for the Euler equation</p><a href="../proc/atl_laxfriedrans.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_laxfriedrans_2d.html'>atl_laxFriedRans_2D</a></td>
                 <td><a href='../module/atl_laxfriedrichflux_module.html'>atl_laxFriedrichFlux_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_legpolyvar_append.html'>atl_legpolyvar_append</a></td>
                 <td><a href='../module/atl_legpolyvar_module.html'>atl_legpolyvar_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_legpolyvar_load.html'>atl_legpolyvar_load</a></td>
                 <td><a href='../module/atl_legpolyvar_module.html'>atl_legpolyvar_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Load the definition of a Legendre polynomial variable from a Lua script.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_lineareuler_2d_numflux_subleft.html'>atl_LinearEuler_2d_numflux_subleft</a></td>
                 <td><a href='../module/atl_lineareuler_2d_numflux_module.html'>atl_LinearEuler_2d_numflux_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_lineareuler_2d_numflux_subright.html'>atl_LinearEuler_2d_numflux_subright</a></td>
                 <td><a href='../module/atl_lineareuler_2d_numflux_module.html'>atl_LinearEuler_2d_numflux_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_lineareuler_2d_numflux_superleft.html'>atl_LinearEuler_2d_numflux_superleft</a></td>
                 <td><a href='../module/atl_lineareuler_2d_numflux_module.html'>atl_LinearEuler_2d_numflux_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_lineareuler_2d_numflux_superright.html'>atl_LinearEuler_2d_numflux_superright</a></td>
                 <td><a href='../module/atl_lineareuler_2d_numflux_module.html'>atl_LinearEuler_2d_numflux_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_lineareuler_2d_physflux.html'>atl_LinearEuler_2d_physFlux</a></td>
                 <td><a href='../module/atl_lineareuler_2d_physflux_module.html'>atl_LinearEuler_2d_physflux_module</a></td>
                 <td>Function</td>
                 <td><p>Function for physical flux of the LinearEuler equation F, 1D?
Since it is 1d, there need to be passed the correct background velocity (u0
for F - flux in x direction, v0 for G - flux in y direction, w0 for H -
flux in z direction)</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_lineareuler_numflux_subleft.html'>atl_LinearEuler_numflux_subleft</a></td>
                 <td><a href='../module/atl_lineareuler_numflux_module.html'>atl_LinearEuler_numflux_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_lineareuler_numflux_subright.html'>atl_LinearEuler_numflux_subright</a></td>
                 <td><a href='../module/atl_lineareuler_numflux_module.html'>atl_LinearEuler_numflux_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_lineareuler_numflux_superleft.html'>atl_LinearEuler_numflux_superleft</a></td>
                 <td><a href='../module/atl_lineareuler_numflux_module.html'>atl_LinearEuler_numflux_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_lineareuler_numflux_superright.html'>atl_LinearEuler_numflux_superright</a></td>
                 <td><a href='../module/atl_lineareuler_numflux_module.html'>atl_LinearEuler_numflux_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_lineareuler_physflux.html'>atl_LinearEuler_physFlux</a></td>
                 <td><a href='../module/atl_lineareuler_physflux_module.html'>atl_LinearEuler_physflux_module</a></td>
                 <td>Function</td>
                 <td><p>Function for physical flux of the LinearEuler equation F, 1D?
Since it is 1d, there need to be passed the correct background velocity (u0
for F - flux in x direction, v0 for G - flux in y direction, w0 for H -
flux in z direction)</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_lineuler_2d_completstate_getelement.html'>atl_linEuler_2d_completState_getElement</a></td>
                 <td><a href='../module/atl_eqn_lineareuler_2d_derive_module.html'>atl_eqn_lineareuler_2d_derive_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_lineuler_2d_completstate_getpoint.html'>atl_linEuler_2d_completState_getPoint</a></td>
                 <td><a href='../module/atl_eqn_lineareuler_2d_derive_module.html'>atl_eqn_lineareuler_2d_derive_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_lineuler_completstate_getelement.html'>atl_linEuler_completState_getElement</a></td>
                 <td><a href='../module/atl_eqn_lineareuler_derive_module.html'>atl_eqn_lineareuler_derive_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_lineuler_completstate_getpoint.html'>atl_linEuler_completState_getPoint</a></td>
                 <td><a href='../module/atl_eqn_lineareuler_derive_module.html'>atl_eqn_lineareuler_derive_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_linindicator_getelement.html'>atl_linindicator_getElement</a></td>
                 <td><a href='../module/atl_eqn_euler_derive_module.html'>atl_eqn_euler_derive_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_linindicator_getpoint.html'>atl_linindicator_getPoint</a></td>
                 <td><a href='../module/atl_eqn_euler_derive_module.html'>atl_eqn_euler_derive_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_load_acoustic.html'>atl_load_acoustic</a></td>
                 <td><a href='../module/atl_eqn_acoustic_module.html'>atl_eqn_acoustic_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Load the configuration for acoustic equations from the Lua script.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_load_advection_1d.html'>atl_load_advection_1d</a></td>
                 <td><a href='../module/atl_eqn_advection_1d_module.html'>atl_eqn_advection_1d_module</a></td>
                 <td>Subroutine</td>
                 <td><p>subroutine to initialize an equation of type advection equation
as defined in the configuration file</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_load_bbmem.html'>atl_load_BBMEM</a></td>
                 <td><a href='../module/atl_eqn_bbm_module.html'>atl_eqn_bbm_module</a></td>
                 <td>Subroutine</td>
                 <td><p>subroutine to intialize BBM</p><a href="../proc/atl_load_bbmem.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_load_bc.html'>atl_load_bc</a></td>
                 <td><a href='../module/atl_bc_header_module.html'>atl_bc_header_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Get the boundary configuration.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_load_bc_state.html'>atl_load_bc_state</a></td>
                 <td><a href='../module/atl_bc_state_module.html'>atl_bc_state_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Load the boundary condition for state variables.</p><a href="../proc/atl_load_bc_state.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_load_config.html'>atl_load_config</a></td>
                 <td><a href='../module/atl_program_module.html'>atl_program_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_load_euler.html'>atl_load_euler</a></td>
                 <td><a href='../module/atl_eqn_euler_module.html'>atl_eqn_euler_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Subroutine to initialize an equation of type euler equation
as defined in the configuration file</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_load_filtns.html'>atl_load_filtNS</a></td>
                 <td><a href='../module/atl_eqn_nvrstk_module.html'>atl_eqn_nvrstk_module</a></td>
                 <td>Subroutine</td>
                 <td><p>subroutine to initialize an equation of type filtered-navier-stokes
equation (turbulence modelling) as defined in the configuration file</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_load_general_projection.html'>atl_load_general_projection</a></td>
                 <td><a href='../module/atl_load_project_module.html'>atl_load_project_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_load_heat.html'>atl_load_heat</a></td>
                 <td><a href='../module/atl_eqn_heat_module.html'>atl_eqn_heat_module</a></td>
                 <td>Subroutine</td>
                 <td><p>subroutine to initialize an equation of type heat equation
as defined in the configuration file</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_load_initial_condition.html'>atl_load_initial_condition</a></td>
                 <td><a href='../module/atl_initial_condition_module.html'>atl_initial_condition_module</a></td>
                 <td>Subroutine</td>
                 <td><p>subroutine to load the initial conditions from a lua configuration file.</p><a href="../proc/atl_load_initial_condition.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_load_lineareuler.html'>atl_load_LinearEuler</a></td>
                 <td><a href='../module/atl_eqn_lineareuler_module.html'>atl_eqn_LinearEuler_module</a></td>
                 <td>Subroutine</td>
                 <td><p>subroutine to initialize an equation of type linear euler equation
as defined in the configuration file</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_load_navierstokes.html'>atl_load_navierStokes</a></td>
                 <td><a href='../module/atl_eqn_nvrstk_module.html'>atl_eqn_nvrstk_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Subroutine to initialize an equation of type navier stokes equation
as defined in the configuration file</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_load_nernstplanck.html'>atl_load_nernstPlanck</a></td>
                 <td><a href='../module/atl_eqn_nerplanck_module.html'>atl_eqn_nerplanck_module</a></td>
                 <td>Subroutine</td>
                 <td><p>subroutine to intialize Nernst-Planck equation with constant</p><a href="../proc/atl_load_nernstplanck.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_load_projection.html'>atl_load_projection</a></td>
                 <td><a href='../module/atl_load_project_module.html'>atl_load_project_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_load_solver_parameters.html'>atl_load_solver_parameters</a></td>
                 <td><a href='../module/atl_solver_param_module.html'>atl_solver_param_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Routine to initialize the global parameters, sets the solver
 module variable.</p><a href="../proc/atl_load_solver_parameters.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_load_subprojection.html'>atl_load_subprojection</a></td>
                 <td><a href='../module/atl_load_project_module.html'>atl_load_project_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_machnumber_getelement.html'>atl_machNumber_getElement</a></td>
                 <td><a href='../module/atl_eqn_euler_derive_module.html'>atl_eqn_euler_derive_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_machnumber_getpoint.html'>atl_machNumber_getPoint</a></td>
                 <td><a href='../module/atl_eqn_euler_derive_module.html'>atl_eqn_euler_derive_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../interface/atl_maxwell_flux.html'>atl_maxwell_flux</a></td>
                 <td><a href='../module/atl_maxwell_flux_module.html'>atl_maxwell_flux_module</a></td>
                 <td>Interface</td>
                 <td><p>Interface for fluxes of pure Maxwell equations.</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/atl_maxwell_flux_2d.html'>atl_maxwell_flux_2d</a></td>
                 <td><a href='../module/atl_maxwell_flux_2d_module.html'>atl_maxwell_flux_2d_module</a></td>
                 <td>Interface</td>
                 <td><p>Interface for fluxes of pure Maxwell equations.</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/atl_maxwell_hc_flux.html'>atl_maxwell_hc_flux</a></td>
                 <td><a href='../module/atl_maxwell_flux_module.html'>atl_maxwell_flux_module</a></td>
                 <td>Interface</td>
                 <td><p>Interface for fluxes of Maxwell equations with
hyperbolic divergence cleaning.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_modg_1d_advection_numflux.html'>atl_modg_1d_advection_numFlux</a></td>
                 <td><a href='../module/atl_modg_1d_advection_kernel_module.html'>atl_modg_1d_advection_kernel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate the numerical flux for the advection equation and MODG scheme</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_modg_1d_advection_physflux.html'>atl_modg_1d_advection_physFlux</a></td>
                 <td><a href='../module/atl_modg_1d_advection_kernel_module.html'>atl_modg_1d_advection_kernel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate the physical flux for the MODG scheme and
advection equation.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_modg_1d_bnd.html'>atl_modg_1d_bnd</a></td>
                 <td><a href='../module/atl_modg_1d_bnd_module.html'>atl_modg_1d_bnd_module</a></td>
                 <td>Function</td>
                 <td><p>Subroutine to create the modal representation for a ceratin boundary face.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_modg_1d_coarsetofineface.html'>atl_modg_1d_coarseToFineFace</a></td>
                 <td><a href='../module/atl_modg_1d_multilevel_module.html'>atl_modg_1d_multilevel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>\brief Interpolate modal face representation from coarse to next finer faces (level
difference between coarser and finer faces has to be 1).</p><a href="../proc/atl_modg_1d_coarsetofineface.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_modg_1d_ensure_pos_face.html'>atl_modg_1d_ensure_pos_face</a></td>
                 <td><a href='../module/atl_modg_1d_kernel_module.html'>atl_modg_1d_kernel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Lift the value on the face to a positive value if necessary.</p><a href="../proc/atl_modg_1d_ensure_pos_face.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_modg_1d_euler_numflux.html'>atl_modg_1d_euler_numFlux</a></td>
                 <td><a href='../module/atl_modg_1d_euler_kernel_module.html'>atl_modg_1d_euler_kernel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate the numerical flux for Euler equation and MODG scheme</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_modg_1d_euler_penalization_const.html'>atl_modg_1d_euler_penalization_Const</a></td>
                 <td><a href='../module/atl_modg_1d_euler_kernel_module.html'>atl_modg_1d_euler_kernel_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_modg_1d_euler_penalization_nonconst.html'>atl_modg_1d_euler_penalization_NonConst</a></td>
                 <td><a href='../module/atl_modg_1d_euler_kernel_module.html'>atl_modg_1d_euler_kernel_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_modg_1d_euler_physflux_const.html'>atl_modg_1d_euler_physFlux_const</a></td>
                 <td><a href='../module/atl_modg_1d_euler_kernel_module.html'>atl_modg_1d_euler_kernel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate the physical flux for the MODG scheme and
Euler equation with constant characteristic (mask function) in the
element.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_modg_1d_euler_physflux_nonconst.html'>atl_modg_1d_euler_physFlux_nonConst</a></td>
                 <td><a href='../module/atl_modg_1d_euler_kernel_module.html'>atl_modg_1d_euler_kernel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate the physical flux for the MODG scheme and
Euler equation with variable characteristic (mask function) in the
element.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_modg_1d_finetocoarseface.html'>atl_modg_1d_fineToCoarseFace</a></td>
                 <td><a href='../module/atl_modg_1d_multilevel_module.html'>atl_modg_1d_multilevel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Interpolate modal face representation from next finer faces to coarse level (level</p><a href="../proc/atl_modg_1d_finetocoarseface.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_modg_1d_heat_numflux.html'>atl_modg_1d_heat_numFlux</a></td>
                 <td><a href='../module/atl_modg_1d_heat_kernel_module.html'>atl_modg_1d_heat_kernel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate the numerical flux for the Heat equation and MODG scheme</p><a href="../proc/atl_modg_1d_heat_numflux.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_modg_1d_heat_physflux.html'>atl_modg_1d_heat_physFlux</a></td>
                 <td><a href='../module/atl_modg_1d_heat_kernel_module.html'>atl_modg_1d_heat_kernel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate the physical flux for the MODG scheme and
Heat equation.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_modg_1d_invmassmatrix.html'>atl_modg_1d_invMassMatrix</a></td>
                 <td><a href='../module/atl_modg_1d_kernel_module.html'>atl_modg_1d_kernel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Applies the inverse of the mass matrix for a 3D scheme.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_modg_1d_loclineuler_physflux.html'>atl_modg_1d_LoclinEuler_physFlux</a></td>
                 <td><a href='../module/atl_modg_1d_loclineuler_kernel_module.html'>atl_modg_1d_LoclinEuler_kernel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate the physical flux for the MODG scheme and
Linearized euler equation.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_modg_1d_modalvoltomodalface.html'>atl_modg_1d_modalVolToModalFace</a></td>
                 <td><a href='../module/atl_modg_1d_kernel_module.html'>atl_modg_1d_kernel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Projects modal representation of each cell to its faces, i.e.
this subroutine creates a modal representation on the faces.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_modg_1d_modalvoltomodalface~2.html'>atl_modg_1d_modalVolToModalFace</a></td>
                 <td><a href='../module/atl_voltoface_module.html'>atl_volToFace_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Projects modal representation of each cell to its faces, i.e.
this subroutine creates a modal representation on the faces.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_modg_1d_project_physflux_testfunc.html'>atl_modg_1d_project_PhysFlux_testFunc</a></td>
                 <td><a href='../module/atl_modg_1d_kernel_module.html'>atl_modg_1d_kernel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Subroutine to project modal representations of physical flux, numerical flux
and source terms onto test functions.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_modg_1d_project_testfunc.html'>atl_modg_1d_project_testFunc</a></td>
                 <td><a href='../module/atl_modg_1d_kernel_module.html'>atl_modg_1d_kernel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Subroutine to project modal representations of physical flux, numerical
flux and source terms onto test functions.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_modg_1d_scheme_init.html'>atl_modg_1d_scheme_init</a></td>
                 <td><a href='../module/atl_modg_1d_scheme_module.html'>atl_modg_1d_scheme_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_modg_1d_scheme_load_polydegree.html'>atl_modg_1d_scheme_load_polyDegree</a></td>
                 <td><a href='../module/atl_modg_1d_scheme_module.html'>atl_modg_1d_scheme_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_modg_1d_set_bnd.html'>atl_modg_1d_set_bnd</a></td>
                 <td><a href='../module/atl_modg_1d_bnd_module.html'>atl_modg_1d_bnd_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Subroutine to set face values to impose boundary conditions.</p><a href="../proc/atl_modg_1d_set_bnd.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_modg_1d_voltoface_grad_q.html'>atl_modg_1d_VolToFace_grad_Q</a></td>
                 <td><a href='../module/atl_voltoface_module.html'>atl_volToFace_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_modg_1d_voltoface_q.html'>atl_modg_1d_volToFace_Q</a></td>
                 <td><a href='../module/atl_voltoface_module.html'>atl_volToFace_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Project modal representation of an element to one of its faces for Q space.</p><a href="../proc/atl_modg_1d_voltoface_q.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_modg_2d_acoustic_numflux.html'>atl_modg_2d_acoustic_numFlux</a></td>
                 <td><a href='../module/atl_modg_2d_acoustic_kernel_module.html'>atl_modg_2d_acoustic_kernel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate the numerical flux for acoustic equation and MODG scheme</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_modg_2d_acoustic_physflux.html'>atl_modg_2d_acoustic_physFlux</a></td>
                 <td><a href='../module/atl_modg_2d_acoustic_kernel_module.html'>atl_modg_2d_acoustic_kernel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate the physical flux for the MODG scheme and
Acoustic equation.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_modg_2d_bnd.html'>atl_modg_2d_bnd</a></td>
                 <td><a href='../module/atl_modg_2d_bnd_module.html'>atl_modg_2d_bnd_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Subroutine to create the modal representation for a ceratin boundary face.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_modg_2d_coarsetofineface.html'>atl_modg_2d_coarseToFineFace</a></td>
                 <td><a href='../module/atl_modg_2d_multilevel_module.html'>atl_modg_2d_multilevel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Interpolate modal face representation from coarse to next finer faces (level</p><a href="../proc/atl_modg_2d_coarsetofineface.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_modg_2d_ensure_pos_facemean.html'>atl_modg_2d_ensure_pos_facemean</a></td>
                 <td><a href='../module/atl_modg_2d_kernel_module.html'>atl_modg_2d_kernel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Lift the mean on the face to a positive value if necessary.</p><a href="../proc/atl_modg_2d_ensure_pos_facemean.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_modg_2d_euler_numflux.html'>atl_modg_2d_euler_numFlux</a></td>
                 <td><a href='../module/atl_modg_2d_euler_kernel_module.html'>atl_modg_2d_euler_kernel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate the numerical flux for Euler equation and MODG scheme</p><a href="../proc/atl_modg_2d_euler_numflux.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_modg_2d_euler_onedim_numflux_const.html'>atl_modg_2d_euler_oneDim_numFlux_const</a></td>
                 <td><a href='../module/atl_modg_2d_euler_kernel_module.html'>atl_modg_2d_euler_kernel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Numerical flux calculation for Euler equation across the faces in a single
spatial direction (with constant penalization parameters).</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_modg_2d_euler_onedim_numflux_nonconst.html'>atl_modg_2d_euler_oneDim_numFlux_nonconst</a></td>
                 <td><a href='../module/atl_modg_2d_euler_kernel_module.html'>atl_modg_2d_euler_kernel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Numerical flux calculation for Euler equation across the faces in a single
spatial direction (with non-constant penalization parameters).</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_modg_2d_euler_penalization_const.html'>atl_modg_2d_euler_penalization_const</a></td>
                 <td><a href='../module/atl_modg_2d_euler_kernel_module.html'>atl_modg_2d_euler_kernel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>PV 20150820 Get the correct penalization data here</p><a href="../proc/atl_modg_2d_euler_penalization_const.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_modg_2d_euler_penalization_nonconst.html'>atl_modg_2d_euler_penalization_NonConst</a></td>
                 <td><a href='../module/atl_modg_2d_euler_kernel_module.html'>atl_modg_2d_euler_kernel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>PV 20150820 Get the correct penalization data here</p><a href="../proc/atl_modg_2d_euler_penalization_nonconst.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_modg_2d_euler_physflux_const.html'>atl_modg_2d_euler_physFlux_const</a></td>
                 <td><a href='../module/atl_modg_2d_euler_kernel_module.html'>atl_modg_2d_euler_kernel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate the physical flux for the MODG scheme and
Euler equation.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_modg_2d_euler_physflux_nonconst.html'>atl_modg_2d_euler_physFlux_NonConst</a></td>
                 <td><a href='../module/atl_modg_2d_euler_kernel_module.html'>atl_modg_2d_euler_kernel_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_modg_2d_filnvrstk_numflux.html'>atl_modg_2d_filNvrStk_numFlux</a></td>
                 <td><a href='../module/atl_modg_2d_filnvrstk_kernel_module.html'>atl_modg_2d_filNvrStk_kernel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate the numerical flux for Navier-Stokes equation and MODG scheme</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_modg_2d_filnvrstk_physflux_const.html'>atl_modg_2d_filNvrStk_physFlux_const</a></td>
                 <td><a href='../module/atl_modg_2d_filnvrstk_kernel_module.html'>atl_modg_2d_filNvrStk_kernel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate the physical flux for the MODG scheme and
Navier-Stokes equation (with constant penalizations).</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_modg_2d_filnvrstk_physflux_nonconst.html'>atl_modg_2d_filNvrStk_physFlux_NonConst</a></td>
                 <td><a href='../module/atl_modg_2d_filnvrstk_kernel_module.html'>atl_modg_2d_filNvrStk_kernel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate the physical flux for the MODG scheme and
Navier-Stokes equation (with non-constant penalizations).</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_modg_2d_finetocoarseface.html'>atl_modg_2d_fineToCoarseFace</a></td>
                 <td><a href='../module/atl_modg_2d_multilevel_module.html'>atl_modg_2d_multilevel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Interpolate modal face representation from next finer faces to coarse level (level</p><a href="../proc/atl_modg_2d_finetocoarseface.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_modg_2d_heat_numflux.html'>atl_modg_2d_heat_numFlux</a></td>
                 <td><a href='../module/atl_modg_2d_heat_kernel_module.html'>atl_modg_2d_heat_kernel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate the numerical flux for Heat equation and MODG scheme</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_modg_2d_heat_physflux.html'>atl_modg_2d_heat_physFlux</a></td>
                 <td><a href='../module/atl_modg_2d_heat_kernel_module.html'>atl_modg_2d_heat_kernel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate the physical flux for the MODG scheme and
 Heat equation.</p><a href="../proc/atl_modg_2d_heat_physflux.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_modg_2d_invmassmatrix.html'>atl_modg_2d_invMassMatrix</a></td>
                 <td><a href='../module/atl_modg_2d_kernel_module.html'>atl_modg_2d_kernel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Applies the inverse of the mass matrix for a 2D scheme.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_modg_2d_lineareuler_numflux.html'>atl_modg_2d_LinearEuler_numFlux</a></td>
                 <td><a href='../module/atl_modg_2d_lineareuler_kernel_module.html'>atl_modg_2d_LinearEuler_kernel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate the numerical flux for LinearEuler equation and MODG scheme</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_modg_2d_lineareuler_physflux.html'>atl_modg_2d_LinearEuler_physFlux</a></td>
                 <td><a href='../module/atl_modg_2d_lineareuler_kernel_module.html'>atl_modg_2d_LinearEuler_kernel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate the physical flux for the MODG scheme and
Linearized euler equation.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_modg_2d_loclineuler_physflux.html'>atl_modg_2d_LoclinEuler_physFlux</a></td>
                 <td><a href='../module/atl_modg_2d_loclineuler_kernel_module.html'>atl_modg_2d_LoclinEuler_kernel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate the physical flux for the MODG scheme and
Linearized euler equation.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_modg_2d_modalvoltomodalface.html'>atl_modg_2d_modalVolToModalFace</a></td>
                 <td><a href='../module/atl_modg_2d_kernel_module.html'>atl_modg_2d_kernel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Projects modal representation of each cell to its faces, i.e.
this subroutine creates a modal representation on the faces.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_modg_2d_navierstokes_numflux.html'>atl_modg_2d_navierstokes_numFlux</a></td>
                 <td><a href='../module/atl_modg_2d_navierstokes_kernel_module.html'>atl_modg_2d_navierstokes_kernel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate the numerical flux for Navier-Stokes equation and MODG scheme</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_modg_2d_navierstokes_penalization_const.html'>atl_modg_2d_navierstokes_penalization_const</a></td>
                 <td><a href='../module/atl_modg_2d_navierstokes_kernel_module.html'>atl_modg_2d_navierstokes_kernel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>PV 20150820 Get the correct penalization data here</p><a href="../proc/atl_modg_2d_navierstokes_penalization_const.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_modg_2d_navierstokes_penalization_nonconst.html'>atl_modg_2d_navierstokes_penalization_Nonconst</a></td>
                 <td><a href='../module/atl_modg_2d_navierstokes_kernel_module.html'>atl_modg_2d_navierstokes_kernel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>PV 20150820 Get the correct penalization data here</p><a href="../proc/atl_modg_2d_navierstokes_penalization_nonconst.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_modg_2d_navierstokes_physflux_const.html'>atl_modg_2d_navierstokes_physFlux_const</a></td>
                 <td><a href='../module/atl_modg_2d_navierstokes_kernel_module.html'>atl_modg_2d_navierstokes_kernel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate the physical flux for the MODG scheme and
Navier-Stokes equation (with constant penalizations).</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_modg_2d_navierstokes_physflux_nonconst.html'>atl_modg_2d_navierstokes_physFlux_NonConst</a></td>
                 <td><a href='../module/atl_modg_2d_navierstokes_kernel_module.html'>atl_modg_2d_navierstokes_kernel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate the physical flux for the MODG scheme and
Navier-Stokes equation (with non-constant penalizations).</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_modg_2d_project_numflux.html'>atl_modg_2d_project_NumFlux</a></td>
                 <td><a href='../module/atl_modg_2d_kernel_module.html'>atl_modg_2d_kernel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Subroutine to project modal representations of numerical flux
and source terms onto test functions.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_modg_2d_project_physflux_testfunc.html'>atl_modg_2d_project_physFlux_testFunc</a></td>
                 <td><a href='../module/atl_project_physflux_module.html'>atl_project_physflux_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Subroutine to project modal representations of physical flux, numerical
flux and source terms onto test functions.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_modg_2d_project_source.html'>atl_modg_2d_project_source</a></td>
                 <td><a href='../module/atl_modg_2d_kernel_module.html'>atl_modg_2d_kernel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Projection of the source terms (in modal representation) to
the test functions.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_modg_2d_scheme_init.html'>atl_modg_2d_scheme_init</a></td>
                 <td><a href='../module/atl_modg_2d_scheme_module.html'>atl_modg_2d_scheme_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_modg_2d_scheme_load_polydegree.html'>atl_modg_2d_scheme_load_polyDegree</a></td>
                 <td><a href='../module/atl_modg_2d_scheme_module.html'>atl_modg_2d_scheme_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_modg_2d_set_bnd.html'>atl_modg_2d_set_bnd</a></td>
                 <td><a href='../module/atl_modg_2d_bnd_module.html'>atl_modg_2d_bnd_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Subroutine to set face values to impose boundary conditions
 at a certain point of the domain. The subroutine is operating levelwise.</p><a href="../proc/atl_modg_2d_set_bnd.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_modg_2d_voltoface_grad_q.html'>atl_modg_2d_volToFace_grad_Q</a></td>
                 <td><a href='../module/atl_voltoface_module.html'>atl_volToFace_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Project modal representation of gradients of an element to one of its
faces for Q space.</p><a href="../proc/atl_modg_2d_voltoface_grad_q.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_modg_2d_voltoface_p.html'>atl_modg_2d_volToFace_P</a></td>
                 <td><a href='../module/atl_voltoface_module.html'>atl_volToFace_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Project modal representation of an element to one of its faces for P space.</p><a href="../proc/atl_modg_2d_voltoface_p.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_modg_2d_voltoface_q.html'>atl_modg_2d_volToFace_Q</a></td>
                 <td><a href='../module/atl_voltoface_module.html'>atl_volToFace_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Project modal representation of an element to one of its faces for Q space.</p><a href="../proc/atl_modg_2d_voltoface_q.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_modg_acoustic_numflux.html'>atl_modg_acoustic_numFlux</a></td>
                 <td><a href='../module/atl_modg_acoustic_kernel_module.html'>atl_modg_acoustic_kernel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate the numerical flux for acoustic equation and MODG scheme</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_modg_acoustic_physflux.html'>atl_modg_acoustic_physFlux</a></td>
                 <td><a href='../module/atl_modg_acoustic_kernel_module.html'>atl_modg_acoustic_kernel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate the physical flux for the MODG scheme and
Acoustic equation.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_modg_bnd.html'>atl_modg_bnd</a></td>
                 <td><a href='../module/atl_modg_bnd_module.html'>atl_modg_bnd_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Subroutine to create the modal representation for a ceratin boundary face.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_modg_coarsetofineelem.html'>atl_modg_coarseToFineElem</a></td>
                 <td><a href='../module/atl_modg_multilevel_module.html'>atl_modg_multilevel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Project coarse parent element to its 8 finer child elements
by a simple L2 projection.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_modg_coarsetofineelem_1d.html'>atl_modg_coarseToFineElem_1d</a></td>
                 <td><a href='../module/atl_modg_1d_multilevel_module.html'>atl_modg_1d_multilevel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Project coarse parent element to its 8 finer child elements
by a simple L2 projection.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_modg_coarsetofineelem_2d.html'>atl_modg_coarseToFineElem_2d</a></td>
                 <td><a href='../module/atl_modg_2d_multilevel_module.html'>atl_modg_2d_multilevel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Project coarse parent element to its 8 finer child elements
by a simple L2 projection.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_modg_coarsetofineface.html'>atl_modg_coarseToFineFace</a></td>
                 <td><a href='../module/atl_modg_multilevel_module.html'>atl_modg_multilevel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Interpolate modal face representation from coarse to next finer faces (level</p><a href="../proc/atl_modg_coarsetofineface.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_modg_ensure_pos_facemean.html'>atl_modg_ensure_pos_facemean</a></td>
                 <td><a href='../module/atl_modg_kernel_module.html'>atl_modg_kernel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Lift the mean on the face to a positive value if necessary.</p><a href="../proc/atl_modg_ensure_pos_facemean.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_modg_euler_numflux.html'>atl_modg_euler_numFlux</a></td>
                 <td><a href='../module/atl_modg_euler_kernel_module.html'>atl_modg_euler_kernel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate the numerical flux for Euler equation and MODG scheme</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_modg_euler_onedim_numflux_const.html'>atl_modg_euler_oneDim_numFlux_const</a></td>
                 <td><a href='../module/atl_modg_euler_kernel_module.html'>atl_modg_euler_kernel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Numerical flux calculation for Euler equation across the faces in a single
spatial direction.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_modg_euler_onedim_numflux_nonconst.html'>atl_modg_euler_oneDim_numFlux_nonconst</a></td>
                 <td><a href='../module/atl_modg_euler_kernel_module.html'>atl_modg_euler_kernel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Numerical flux calculation for Euler equation across the faces in a single
spatial direction.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_modg_euler_penalization_const.html'>atl_modg_euler_penalization_const</a></td>
                 <td><a href='../module/atl_modg_euler_kernel_module.html'>atl_modg_euler_kernel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>PV 20150820 Get the correct penalization data here</p><a href="../proc/atl_modg_euler_penalization_const.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_modg_euler_penalization_nonconst.html'>atl_modg_euler_penalization_NonConst</a></td>
                 <td><a href='../module/atl_modg_euler_kernel_module.html'>atl_modg_euler_kernel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>PV 20150820 Get the correct penalization data here</p><a href="../proc/atl_modg_euler_penalization_nonconst.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_modg_euler_physflux_const.html'>atl_modg_euler_physFlux_const</a></td>
                 <td><a href='../module/atl_modg_euler_kernel_module.html'>atl_modg_euler_kernel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate the physical flux for the MODG scheme and
Euler equation.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_modg_euler_physflux_nonconst.html'>atl_modg_euler_physFlux_NonConst</a></td>
                 <td><a href='../module/atl_modg_euler_kernel_module.html'>atl_modg_euler_kernel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate the physical flux for the MODG scheme and
Euler equation.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_modg_filnvrstk_numflux.html'>atl_modg_filNvrStk_numFlux</a></td>
                 <td><a href='../module/atl_modg_filnvrstk_kernel_module.html'>atl_modg_filNvrStk_kernel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate the numerical flux for Navier-Stokes equation and MODG scheme</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_modg_filnvrstk_physflux_const.html'>atl_modg_filNvrStk_physFlux_const</a></td>
                 <td><a href='../module/atl_modg_filnvrstk_kernel_module.html'>atl_modg_filNvrStk_kernel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate the physical flux for the MODG scheme and
Navier-Stokes equation (with constant penalizations).</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_modg_filnvrstk_physflux_nonconst.html'>atl_modg_filNvrStk_physFlux_NonConst</a></td>
                 <td><a href='../module/atl_modg_filnvrstk_kernel_module.html'>atl_modg_filNvrStk_kernel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate the physical flux for the MODG scheme and
Navier-Stokes equation (with non-constant penalizations).</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_modg_finetocoarseelem.html'>atl_modg_fineToCoarseElem</a></td>
                 <td><a href='../module/atl_modg_multilevel_module.html'>atl_modg_multilevel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Project data from 8 smaller elements to its parent element in terms
of L2 projections.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_modg_finetocoarseelem_1d.html'>atl_modg_fineToCoarseElem_1d</a></td>
                 <td><a href='../module/atl_modg_1d_multilevel_module.html'>atl_modg_1d_multilevel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Project data from 8 smaller elements to its parent element in terms
of L2 projections.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_modg_finetocoarseelem_2d.html'>atl_modg_fineToCoarseElem_2d</a></td>
                 <td><a href='../module/atl_modg_2d_multilevel_module.html'>atl_modg_2d_multilevel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Project data from 8 smaller elements to its parent element in terms
of L2 projections.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_modg_finetocoarseface.html'>atl_modg_fineToCoarseFace</a></td>
                 <td><a href='../module/atl_modg_multilevel_module.html'>atl_modg_multilevel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Interpolate modal face representation from next finer faces to coarse level (level</p><a href="../proc/atl_modg_finetocoarseface.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_modg_heat_numflux.html'>atl_modg_heat_numFlux</a></td>
                 <td><a href='../module/atl_modg_heat_kernel_module.html'>atl_modg_heat_kernel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate the numerical flux for Heat equation and MODG scheme</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_modg_heat_numflux_sipg.html'>atl_modg_heat_numFlux_sipg</a></td>
                 <td><a href='../module/atl_numfluxheat_module.html'>atl_numFluxHeat_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Numerical flux calculation for Heat equation across the faces in a single
spatial direction.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_modg_heat_physflux.html'>atl_modg_heat_physFlux</a></td>
                 <td><a href='../module/atl_modg_heat_kernel_module.html'>atl_modg_heat_kernel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate the physical flux for the MODG scheme and
Heat equation.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_modg_invmassmatrix.html'>atl_modg_invMassMatrix</a></td>
                 <td><a href='../module/atl_modg_kernel_module.html'>atl_modg_kernel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Applies the inverse of the mass matrix for a 3D scheme.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_modg_kernel_utests.html'>atl_modg_kernel_utests</a></td>
                 <td><a href='../module/atl_modg_kernel_module.html'>atl_modg_kernel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Subroutine to test the various routines of this module.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_modg_lineareuler_numflux.html'>atl_modg_LinearEuler_numFlux</a></td>
                 <td><a href='../module/atl_modg_lineareuler_kernel_module.html'>atl_modg_LinearEuler_kernel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate the numerical flux for LinearEuler equation and MODG scheme</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_modg_lineareuler_physflux.html'>atl_modg_LinearEuler_physFlux</a></td>
                 <td><a href='../module/atl_modg_lineareuler_kernel_module.html'>atl_modg_LinearEuler_kernel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate the physical flux for the MODG scheme and
Linearized euler equation.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_modg_loclineuler_physflux.html'>atl_modg_LoclinEuler_physFlux</a></td>
                 <td><a href='../module/atl_modg_loclineuler_kernel_module.html'>atl_modg_LoclinEuler_kernel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate the physical flux for the MODG scheme and
Linearized euler equation.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_modg_maxwell_2d_numflux.html'>atl_modg_maxwell_2d_numFlux</a></td>
                 <td><a href='../module/atl_modg_2d_maxwell_kernel_module.html'>atl_modg_2d_maxwell_kernel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate the numerical flux for Maxwell equation and MODG scheme</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_modg_maxwell_2d_penalization_const.html'>atl_modg_maxwell_2d_penalization_Const</a></td>
                 <td><a href='../module/atl_modg_2d_maxwell_kernel_module.html'>atl_modg_2d_maxwell_kernel_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_modg_maxwell_2d_penalization_nonconst.html'>atl_modg_maxwell_2d_penalization_NonConst</a></td>
                 <td><a href='../module/atl_modg_2d_maxwell_kernel_module.html'>atl_modg_2d_maxwell_kernel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>PV 20150820 Get the correct penalization data here</p><a href="../proc/atl_modg_maxwell_2d_penalization_nonconst.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_modg_maxwell_2d_physflux_const.html'>atl_modg_maxwell_2d_physFlux_const</a></td>
                 <td><a href='../module/atl_modg_2d_maxwell_kernel_module.html'>atl_modg_2d_maxwell_kernel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate the physical flux for the MODG scheme and Maxwell equation.
used for both space P and Q</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_modg_maxwell_2d_physflux_nonconst.html'>atl_modg_maxwell_2d_physFlux_NonConst</a></td>
                 <td><a href='../module/atl_modg_2d_maxwell_kernel_module.html'>atl_modg_2d_maxwell_kernel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate the physical flux for the MODG scheme and Maxwell equation.
used for both space P and Q</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_modg_maxwell_numflux.html'>atl_modg_maxwell_numFlux</a></td>
                 <td><a href='../module/atl_modg_maxwell_kernel_module.html'>atl_modg_maxwell_kernel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate the numerical flux for Maxwell equation and MODG scheme</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_modg_maxwell_physflux_const.html'>atl_modg_maxwell_physFlux_const</a></td>
                 <td><a href='../module/atl_modg_maxwell_kernel_module.html'>atl_modg_maxwell_kernel_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_modg_maxwell_physflux_nonconst.html'>atl_modg_maxwell_physFlux_NonConst</a></td>
                 <td><a href='../module/atl_modg_maxwell_kernel_module.html'>atl_modg_maxwell_kernel_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_modg_maxwelldivcor_numflux.html'>atl_modg_maxwellDivCor_numFlux</a></td>
                 <td><a href='../module/atl_modg_maxwelldivcor_kernel_module.html'>atl_modg_maxwellDivCor_kernel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate the numerical flux for Maxwell equation with hyperbolic
divergence cleaning and MODG scheme</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_modg_maxwelldivcor_physflux_const.html'>atl_modg_maxwellDivCor_physFlux_const</a></td>
                 <td><a href='../module/atl_modg_maxwelldivcor_kernel_module.html'>atl_modg_maxwellDivCor_kernel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate the physical flux for the MODG scheme and
Maxwell equation with hyperbolic divergenc cleaning.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_modg_maxwelldivcor_physflux_nonconst.html'>atl_modg_maxwellDivCor_physFlux_NonConst</a></td>
                 <td><a href='../module/atl_modg_maxwelldivcor_kernel_module.html'>atl_modg_maxwellDivCor_kernel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate the physical flux for the MODG scheme and
Maxwell equation with hyperbolic divergenc cleaning.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_modg_modalvoltomodalface.html'>atl_modg_modalVolToModalFace</a></td>
                 <td><a href='../module/atl_modg_kernel_module.html'>atl_modg_kernel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Projects modal representation of each cell to its faces, i.e.
this subroutine creates a modal representation on the faces.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_modg_navierstokes_numflux.html'>atl_modg_navierstokes_numFlux</a></td>
                 <td><a href='../module/atl_modg_navierstokes_kernel_module.html'>atl_modg_navierstokes_kernel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate the numerical flux for Navier-Stokes equation and MODG scheme</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_modg_navierstokes_penalization_const.html'>atl_modg_navierstokes_penalization_const</a></td>
                 <td><a href='../module/atl_modg_navierstokes_kernel_module.html'>atl_modg_navierstokes_kernel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>PV 20150820 Get the correct penalization data here</p><a href="../proc/atl_modg_navierstokes_penalization_const.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_modg_navierstokes_penalization_nonconst.html'>atl_modg_navierstokes_penalization_nonconst</a></td>
                 <td><a href='../module/atl_modg_navierstokes_kernel_module.html'>atl_modg_navierstokes_kernel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>PV 20150820 Get the correct penalization data here</p><a href="../proc/atl_modg_navierstokes_penalization_nonconst.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_modg_navierstokes_physflux_const.html'>atl_modg_navierstokes_physFlux_const</a></td>
                 <td><a href='../module/atl_modg_navierstokes_kernel_module.html'>atl_modg_navierstokes_kernel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate the physical flux for the MODG scheme and
Navier-Stokes equation (with constant penalizations).</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_modg_navierstokes_physflux_nonconst.html'>atl_modg_navierstokes_physFlux_NonConst</a></td>
                 <td><a href='../module/atl_modg_navierstokes_kernel_module.html'>atl_modg_navierstokes_kernel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate the physical flux for the MODG scheme and
Navier-Stokes equation (with non-constant penalizations).</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_modg_project_numflux.html'>atl_modg_project_NumFlux</a></td>
                 <td><a href='../module/atl_modg_kernel_module.html'>atl_modg_kernel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Subroutine to project modal representations of physical flux, numerical
flux and source terms onto test functions.</p><a href="../proc/atl_modg_project_numflux.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_modg_project_physflux_testfunc.html'>atl_modg_project_PhysFlux_testFunc</a></td>
                 <td><a href='../module/atl_project_physflux_module.html'>atl_project_physflux_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Subroutine to project modal representations of physical flux, numerical flux
and source terms onto test functions.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_modg_project_source.html'>atl_modg_project_source</a></td>
                 <td><a href='../module/atl_modg_kernel_module.html'>atl_modg_kernel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Projection of the source terms (in modal representation) to the
test functions.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_modg_project_source_p.html'>atl_modg_project_source_P</a></td>
                 <td><a href='../module/atl_modg_kernel_module.html'>atl_modg_kernel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Projection of the source terms (in modal representation) to the
test functions.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_modg_project_source_q.html'>atl_modg_project_source_Q</a></td>
                 <td><a href='../module/atl_modg_kernel_module.html'>atl_modg_kernel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Projection of the source terms (in modal representation) to the
test functions.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_modg_scaledtransposedinvmassmatrix_p.html'>atl_modg_scaledTransposedInvMassMatrix_P</a></td>
                 <td><a href='../module/atl_modg_kernel_module.html'>atl_modg_kernel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Applies a scaled transposed inverse of the mass matrix for a 3D scheme.
The result is a transformation of the polynomial basis from the
ansatz- to the test-polynomials.
This is useful for a local predictor</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_modg_scaledtransposedinvmassmatrix_q.html'>atl_modg_scaledTransposedInvMassMatrix_Q</a></td>
                 <td><a href='../module/atl_modg_kernel_module.html'>atl_modg_kernel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Applies a scaled transposed inverse of the mass matrix for a 3D scheme.
The result is a transformation of the polynomial basis from
the ansatz- to the test-polynomials.
This is useful for a local predictor</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_modg_scaledtransposedproject_physflux_p.html'>atl_modg_scaledTransposedProject_physFlux_P</a></td>
                 <td><a href='../module/atl_modg_kernel_module.html'>atl_modg_kernel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Projection of the physical flux for the local predictor:
This function expects the physical flux transformed in the basis of
test-polynomials and projects it onto the ansatz-functions.
Thus, the result is directly given in the basis of ansatz-polynomials
(no invMassMatrix-call needed afterwards)</p><a href="../proc/atl_modg_scaledtransposedproject_physflux_p.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_modg_scaledtransposedproject_physflux_q.html'>atl_modg_scaledTransposedProject_physFlux_Q</a></td>
                 <td><a href='../module/atl_modg_kernel_module.html'>atl_modg_kernel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Projection of the physical flux for the local predictor:
This function expects the physical flux transformed in the basis of
test-polynomials and projects it onto the ansatz-functions.
Thus, the result is directly given in the basis of ansatz-polynomials
(no invMassMatrix-call needed afterwards)</p><a href="../proc/atl_modg_scaledtransposedproject_physflux_q.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_modg_scheme_init.html'>atl_modg_scheme_init</a></td>
                 <td><a href='../module/atl_modg_scheme_module.html'>atl_modg_scheme_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_modg_scheme_load_polydegree.html'>atl_modg_scheme_load_polyDegree</a></td>
                 <td><a href='../module/atl_modg_scheme_module.html'>atl_modg_scheme_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_modg_set_bnd.html'>atl_modg_set_bnd</a></td>
                 <td><a href='../module/atl_modg_bnd_module.html'>atl_modg_bnd_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Subroutine to set face values to impose boundary conditions
at a certain point of the domain. The subroutine is operating levelwise.</p><a href="../proc/atl_modg_set_bnd.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_modg_stabviscnavierstokes_onedim_numflux.html'>atl_modg_stabViscNavierStokes_oneDim_numFlux</a></td>
                 <td><a href='../module/atl_modg_navierstokes_kernel_module.html'>atl_modg_navierstokes_kernel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Numerical flux calculation for stab-viscous part of the Navier-Stokes
equation across the faces in a single spatial direction.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_modg_viscnavierstokes_onedim_numflux.html'>atl_modg_viscNavierStokes_oneDim_numFlux</a></td>
                 <td><a href='../module/atl_modg_navierstokes_kernel_module.html'>atl_modg_navierstokes_kernel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Numerical flux calculation for viscous part of the Navier-Stokes equation
across the faces in a single spatial direction.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_modg_voltoface_grad_q.html'>atl_modg_volToFace_grad_Q</a></td>
                 <td><a href='../module/atl_voltoface_module.html'>atl_volToFace_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Project modal representation of gradients of an element to one of its
faces for Q space.</p><a href="../proc/atl_modg_voltoface_grad_q.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_modg_voltoface_p.html'>atl_modg_volToFace_P</a></td>
                 <td><a href='../module/atl_voltoface_module.html'>atl_volToFace_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Project modal representation of an element to one of its faces for P space.</p><a href="../proc/atl_modg_voltoface_p.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_modg_voltoface_q.html'>atl_modg_volToFace_Q</a></td>
                 <td><a href='../module/atl_voltoface_module.html'>atl_volToFace_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Project modal representation of an element to one of its faces for Q space.</p><a href="../proc/atl_modg_voltoface_q.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_mult_nu11_navierstokes.html'>atl_mult_nu11_NavierStokes</a></td>
                 <td><a href='../module/atl_physfluxnvrstk_module.html'>atl_physFluxNvrStk_module</a></td>
                 <td>Function</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_mult_nu11_navierstokes_2d.html'>atl_mult_nu11_NavierStokes_2d</a></td>
                 <td><a href='../module/atl_physfluxnvrstk_2d_module.html'>atl_physFluxNvrStk_2d_module</a></td>
                 <td>Function</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_mult_nu11_rans_2d.html'>atl_mult_nu11_Rans_2d</a></td>
                 <td><a href='../module/atl_physfluxfilnvrstk_module.html'>atl_physFluxFilNvrStk_module</a></td>
                 <td>Function</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_mult_nu12_navierstokes.html'>atl_mult_nu12_NavierStokes</a></td>
                 <td><a href='../module/atl_physfluxnvrstk_module.html'>atl_physFluxNvrStk_module</a></td>
                 <td>Function</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_mult_nu12_navierstokes_2d.html'>atl_mult_nu12_NavierStokes_2d</a></td>
                 <td><a href='../module/atl_physfluxnvrstk_2d_module.html'>atl_physFluxNvrStk_2d_module</a></td>
                 <td>Function</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_mult_nu12_rans_2d.html'>atl_mult_nu12_Rans_2d</a></td>
                 <td><a href='../module/atl_physfluxfilnvrstk_module.html'>atl_physFluxFilNvrStk_module</a></td>
                 <td>Function</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_mult_nu13_navierstokes.html'>atl_mult_nu13_NavierStokes</a></td>
                 <td><a href='../module/atl_physfluxnvrstk_module.html'>atl_physFluxNvrStk_module</a></td>
                 <td>Function</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_mult_nu21_navierstokes.html'>atl_mult_nu21_NavierStokes</a></td>
                 <td><a href='../module/atl_physfluxnvrstk_module.html'>atl_physFluxNvrStk_module</a></td>
                 <td>Function</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_mult_nu21_navierstokes_2d.html'>atl_mult_nu21_NavierStokes_2d</a></td>
                 <td><a href='../module/atl_physfluxnvrstk_2d_module.html'>atl_physFluxNvrStk_2d_module</a></td>
                 <td>Function</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_mult_nu21_rans_2d.html'>atl_mult_nu21_Rans_2d</a></td>
                 <td><a href='../module/atl_physfluxfilnvrstk_module.html'>atl_physFluxFilNvrStk_module</a></td>
                 <td>Function</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_mult_nu22_navierstokes.html'>atl_mult_nu22_NavierStokes</a></td>
                 <td><a href='../module/atl_physfluxnvrstk_module.html'>atl_physFluxNvrStk_module</a></td>
                 <td>Function</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_mult_nu22_navierstokes_2d.html'>atl_mult_nu22_NavierStokes_2d</a></td>
                 <td><a href='../module/atl_physfluxnvrstk_2d_module.html'>atl_physFluxNvrStk_2d_module</a></td>
                 <td>Function</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_mult_nu22_rans_2d.html'>atl_mult_nu22_Rans_2d</a></td>
                 <td><a href='../module/atl_physfluxfilnvrstk_module.html'>atl_physFluxFilNvrStk_module</a></td>
                 <td>Function</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_mult_nu23_navierstokes.html'>atl_mult_nu23_NavierStokes</a></td>
                 <td><a href='../module/atl_physfluxnvrstk_module.html'>atl_physFluxNvrStk_module</a></td>
                 <td>Function</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_mult_nu31_navierstokes.html'>atl_mult_nu31_NavierStokes</a></td>
                 <td><a href='../module/atl_physfluxnvrstk_module.html'>atl_physFluxNvrStk_module</a></td>
                 <td>Function</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_mult_nu32_navierstokes.html'>atl_mult_nu32_NavierStokes</a></td>
                 <td><a href='../module/atl_physfluxnvrstk_module.html'>atl_physFluxNvrStk_module</a></td>
                 <td>Function</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_mult_nu33_navierstokes.html'>atl_mult_nu33_NavierStokes</a></td>
                 <td><a href='../module/atl_physfluxnvrstk_module.html'>atl_physFluxNvrStk_module</a></td>
                 <td>Function</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_nearest_projection.html'>atl_nearest_projection</a></td>
                 <td><a href='../module/atl_writeprecice_module.html'>atl_writePrecice_module</a></td>
                 <td>Subroutine</td>
                 <td><p>For a 2D testcase just the edges are of importance, in 3D also
triangles have to be provided
loop over all faces and edges. Set an offset, to get from one face
to the other
For a 3D testcase in addition to the edges triangles have to be
created</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/atl_nerplanck_numflux_preprocess.html'>atl_nerplanck_numflux_preprocess</a></td>
                 <td><a href='../module/atl_nerplanck_flux_module.html'>atl_nerplanck_flux_module</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../interface/atl_nerplanck_numflux_solve.html'>atl_nerplanck_numflux_solve</a></td>
                 <td><a href='../module/atl_nerplanck_flux_module.html'>atl_nerplanck_flux_module</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../interface/atl_nerplanck_physflux_preprocess.html'>atl_nerplanck_physflux_preprocess</a></td>
                 <td><a href='../module/atl_nerplanck_flux_module.html'>atl_nerplanck_flux_module</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../interface/atl_nerplanck_physflux_solve.html'>atl_nerplanck_physflux_solve</a></td>
                 <td><a href='../module/atl_nerplanck_flux_module.html'>atl_nerplanck_flux_module</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_op_deviation_forelement.html'>atl_op_deviation_forElement</a></td>
                 <td><a href='../module/atl_operator_module.html'>atl_operator_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_op_dividevecbyscal_forelement.html'>atl_op_divideVecByScal_forElement</a></td>
                 <td><a href='../module/atl_operator_module.html'>atl_operator_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_op_division_forelement.html'>atl_op_division_forElement</a></td>
                 <td><a href='../module/atl_operator_module.html'>atl_operator_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_op_gradient_forelement.html'>atl_op_Gradient_forElement</a></td>
                 <td><a href='../module/atl_operator_module.html'>atl_operator_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine takes in a variable and differentiates it in a modal way</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_op_gradient_forpoint.html'>atl_op_Gradient_forPoint</a></td>
                 <td><a href='../module/atl_operator_module.html'>atl_operator_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_op_gradient_fromindex.html'>atl_op_gradient_fromIndex</a></td>
                 <td><a href='../module/atl_operator_module.html'>atl_operator_module</a></td>
                 <td>Subroutine</td>
                 <td><p>to do</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_op_gradientx_forelement.html'>atl_op_GradientX_forElement</a></td>
                 <td><a href='../module/atl_operator_module.html'>atl_operator_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine takes in a variable and differentiates it in a modal way</p><a href="../proc/atl_op_gradientx_forelement.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_op_gradienty_forelement.html'>atl_op_GradientY_forElement</a></td>
                 <td><a href='../module/atl_operator_module.html'>atl_operator_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine takes in a variable and differentiates it in a modal way</p><a href="../proc/atl_op_gradienty_forelement.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_op_gradientz_forelement.html'>atl_op_GradientZ_forElement</a></td>
                 <td><a href='../module/atl_operator_module.html'>atl_operator_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine takes in a variable and differentiates it in a modal way</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_op_local_l2_mean_forelement.html'>atl_op_local_L2_mean_forElement</a></td>
                 <td><a href='../module/atl_operator_module.html'>atl_operator_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_op_meansquare_forelement.html'>atl_op_meansquare_forElement</a></td>
                 <td><a href='../module/atl_operator_module.html'>atl_operator_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_opvar_setupindices.html'>atl_opVar_setupIndices</a></td>
                 <td><a href='../module/atl_operator_module.html'>atl_operator_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine takes points coordinates, pass them tp the input variables
the opertaion depends and return indices</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_physcheck_acoustic.html'>atl_physCheck_acoustic</a></td>
                 <td><a href='../module/atl_physcheck_module.html'>atl_physCheck_module</a></td>
                 <td>Function</td>
                 <td><p>Routine to check if the physical values of a state are physically
meaningful or not for the acoustic equation.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_physcheck_acoustic_2d.html'>atl_physCheck_acoustic_2d</a></td>
                 <td><a href='../module/atl_physcheck_module.html'>atl_physCheck_module</a></td>
                 <td>Function</td>
                 <td><p>Routine to check if the physical values of a state are physically
meaningful or not for the acoustic 2d equation.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_physcheck_euler.html'>atl_physCheck_euler</a></td>
                 <td><a href='../module/atl_physcheck_module.html'>atl_physCheck_module</a></td>
                 <td>Function</td>
                 <td><p>Routine to check if the physical values of a state are physically
meaningful or not for the Euler equation.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_physcheck_euler1d.html'>atl_physCheck_euler1d</a></td>
                 <td><a href='../module/atl_physcheck_module.html'>atl_physCheck_module</a></td>
                 <td>Function</td>
                 <td><p>Routine to check if the physical values of a state are physically
meaningful or not for the Euler equation.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_physcheck_euler2d.html'>atl_physCheck_euler2d</a></td>
                 <td><a href='../module/atl_physcheck_module.html'>atl_physCheck_module</a></td>
                 <td>Function</td>
                 <td><p>Routine to check if the physical values of a state are physically
meaningful or not for the Euler equation.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_physcheck_lineareuler.html'>atl_physCheck_lineareuler</a></td>
                 <td><a href='../module/atl_physcheck_module.html'>atl_physCheck_module</a></td>
                 <td>Function</td>
                 <td><p>Routine to check if the physical values of a state are physically
meaningful or not for the linear euler equation.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_physcheck_lineareuler_2d.html'>atl_physCheck_lineareuler_2d</a></td>
                 <td><a href='../module/atl_physcheck_module.html'>atl_physCheck_module</a></td>
                 <td>Function</td>
                 <td><p>Routine to check if the physical values of a state are physically meaningful</p><a href="../proc/atl_physcheck_lineareuler_2d.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_physcheck_maxwell.html'>atl_physCheck_maxwell</a></td>
                 <td><a href='../module/atl_physcheck_module.html'>atl_physCheck_module</a></td>
                 <td>Function</td>
                 <td><p>Routine to check if the physical values of a state are physically
meaningful or not for the Maxwell equation.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_physcheck_rans.html'>atl_physCheck_Rans</a></td>
                 <td><a href='../module/atl_physcheck_module.html'>atl_physCheck_module</a></td>
                 <td>Function</td>
                 <td><p>Routine to check if the physical values of a state are</p><a href="../proc/atl_physcheck_rans.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_physcheck_rans_2d.html'>atl_physCheck_Rans_2d</a></td>
                 <td><a href='../module/atl_physcheck_module.html'>atl_physCheck_module</a></td>
                 <td>Function</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_physfluxeuler.html'>atl_physFluxEuler</a></td>
                 <td><a href='../module/atl_physfluxeuler_module.html'>atl_physFluxEuler_module</a></td>
                 <td>Function</td>
                 <td><p>Physical flux calculation along x direction for Euler equation.</p><a href="../proc/atl_physfluxeuler.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_physfluxeuler_1d.html'>atl_physFluxEuler_1d</a></td>
                 <td><a href='../module/atl_physfluxeuler_1d_module.html'>atl_physFluxEuler_1d_module</a></td>
                 <td>Function</td>
                 <td><p>Physical flux calculation along x direction for Euler equation.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_physfluxeuler_2d.html'>atl_physFluxEuler_2d</a></td>
                 <td><a href='../module/atl_physfluxeuler_2d_module.html'>atl_physFluxEuler_2d_module</a></td>
                 <td>Function</td>
                 <td><p>Physical flux calculation along x direction for Euler equation.</p><a href="../proc/atl_physfluxeuler_2d.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_physfluxeuler_vec.html'>atl_physFluxEuler_vec</a></td>
                 <td><a href='../module/atl_physfluxeuler_module.html'>atl_physFluxEuler_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Physical flux calculation along x direction for Euler equation.</p><a href="../proc/atl_physfluxeuler_vec.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_physfluxmaxwell.html'>atl_physFluxMaxwell</a></td>
                 <td><a href='../module/atl_modg_maxwell_kernel_module.html'>atl_modg_maxwell_kernel_module</a></td>
                 <td>Function</td>
                 <td><p>Function for physical flux of the Maxwell equations in terms of D and B.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_physfluxmaxwell_2d.html'>atl_physFluxMaxwell_2d</a></td>
                 <td><a href='../module/atl_modg_2d_maxwell_kernel_module.html'>atl_modg_2d_maxwell_kernel_module</a></td>
                 <td>Function</td>
                 <td><p>Function for physical flux of the Maxwell equations in terms of D and B.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_physfluxmaxwelldivcor.html'>atl_physFluxMaxwellDivCor</a></td>
                 <td><a href='../module/atl_maxwell_flux_module.html'>atl_maxwell_flux_module</a></td>
                 <td>Function</td>
                 <td><p>Function for physical flux of the Maxwell equations in terms of D and B.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_physfluxrans.html'>atl_physFluxRans</a></td>
                 <td><a href='../module/atl_physfluxfilnvrstk_module.html'>atl_physFluxFilNvrStk_module</a></td>
                 <td>Function</td>
                 <td><p>Physical flux calculation along x direction for the</p><a href="../proc/atl_physfluxrans.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_physfluxrans_2d.html'>atl_physFluxRans_2d</a></td>
                 <td><a href='../module/atl_physfluxfilnvrstk_module.html'>atl_physFluxFilNvrStk_module</a></td>
                 <td>Function</td>
                 <td><p>JZ: here, we divide by a polynomial, we should be careful! We are leaving
the polynomial space here!</p><a href="../proc/atl_physfluxrans_2d.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_positivity_preserv.html'>atl_positivity_preserv</a></td>
                 <td><a href='../module/atl_stabilize_module.html'>atl_stabilize_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Apply pointwise limitation of denisty and energy to ensure positivity
for density and pressure.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_positivity_preserv_2d.html'>atl_positivity_preserv_2d</a></td>
                 <td><a href='../module/atl_stabilize_module.html'>atl_stabilize_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Apply pointwise limitation of denisty and energy to ensure positivity
for density and pressure.</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/atl_postprocess_rhs.html'>atl_postprocess_rhs</a></td>
                 <td><a href='../module/atl_compute_module.html'>atl_compute_module</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../interface/atl_preprocess_local_rhs.html'>atl_preprocess_local_rhs</a></td>
                 <td><a href='../module/atl_compute_local_module.html'>atl_compute_local_module</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_preprocess_modg_1d_kernel.html'>atl_preprocess_modg_1d_kernel</a></td>
                 <td><a href='../module/atl_modg_1d_kernel_module.html'>atl_modg_1d_kernel_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_preprocess_modg_2d_kernel.html'>atl_preprocess_modg_2d_kernel</a></td>
                 <td><a href='../module/atl_modg_2d_kernel_module.html'>atl_modg_2d_kernel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Subroutine to execute the preprocessing for the MODG kernels.
Currently this includes: Convert external source terms to modal
representation.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_preprocess_modg_kernel.html'>atl_preprocess_modg_kernel</a></td>
                 <td><a href='../module/atl_modg_kernel_module.html'>atl_modg_kernel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Subroutine to execute the preprocessing for the MODG kernels.
Currently this includes: Convert external source terms to modal
representation.</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/atl_preprocess_modg_nerplanck_kernel.html'>atl_preprocess_modg_nerplanck_kernel</a></td>
                 <td><a href='../module/atl_modg_nerplanck_kernel_module.html'>atl_modg_nerplanck_kernel_module</a></td>
                 <td>Interface</td>
                 <td><p>interface for preprocessing the data for the kernel</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/atl_preprocess_rhs.html'>atl_preprocess_rhs</a></td>
                 <td><a href='../module/atl_compute_module.html'>atl_compute_module</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_pressure_1d_getelement.html'>atl_pressure_1d_getElement</a></td>
                 <td><a href='../module/atl_eqn_euler_1d_derive_module.html'>atl_eqn_euler_1d_derive_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_pressure_1d_getindex.html'>atl_pressure_1d_getIndex</a></td>
                 <td><a href='../module/atl_eqn_euler_1d_derive_module.html'>atl_eqn_euler_1d_derive_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_pressure_1d_getpoint.html'>atl_pressure_1d_getPoint</a></td>
                 <td><a href='../module/atl_eqn_euler_1d_derive_module.html'>atl_eqn_euler_1d_derive_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_pressure_2d_getelement.html'>atl_pressure_2d_getElement</a></td>
                 <td><a href='../module/atl_eqn_euler_2d_derive_module.html'>atl_eqn_euler_2d_derive_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_pressure_2d_getindex.html'>atl_pressure_2d_getIndex</a></td>
                 <td><a href='../module/atl_eqn_euler_2d_derive_module.html'>atl_eqn_euler_2d_derive_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_pressure_2d_getpoint.html'>atl_pressure_2d_getPoint</a></td>
                 <td><a href='../module/atl_eqn_euler_2d_derive_module.html'>atl_eqn_euler_2d_derive_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_pressure_getelement.html'>atl_pressure_getElement</a></td>
                 <td><a href='../module/atl_eqn_euler_derive_module.html'>atl_eqn_euler_derive_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_pressure_getindex.html'>atl_pressure_getIndex</a></td>
                 <td><a href='../module/atl_eqn_euler_derive_module.html'>atl_eqn_euler_derive_module</a></td>
                 <td>Subroutine</td>
                 <td><p>call varSys%method%val(fun%inpuit_varPos(1))%get_point( &amp;
  &amp; varSys  = varSys,                                  &amp;
  &amp; point   = point,                                   &amp;
  &amp; time    = time,                                    &amp;
  &amp; tree    = tree,                                    &amp;
  &amp; nPnts   = nPnts,                                   &amp;
  &amp; res     = density                                  )
call varSys%method%val(fun%input_varPos(2))%get_point( &amp;
  &amp; varSys  = varSys,                                  &amp;
  &amp; point   = point,                                   &amp;
  &amp; time    = time,                                    &amp;
  &amp; tree    = tree,                                    &amp;
  &amp; nPnts   = nPnts,                                   &amp;
  &amp; res     = momentum                                 )
call varSys%method%val(fun%input_varPos(3))%get_point( &amp;
  &amp; varSys  = varSys,                                  &amp;
  &amp; point   = point,                                   &amp;
  &amp; time    = time,                                    &amp;
  &amp; tree    = tree,                                    &amp;
  &amp; nPnts   = nPnts,                                   &amp;
  &amp; res     = energy                                   )</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_pressure_getpoint.html'>atl_pressure_getPoint</a></td>
                 <td><a href='../module/atl_eqn_euler_derive_module.html'>atl_eqn_euler_derive_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_primal_to_covolume_projection.html'>atl_primal_to_covolume_projection</a></td>
                 <td><a href='../module/atl_covolume_projection_module.html'>atl_covolume_projection_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Project two elements onto single co-volume element.</p><a href="../proc/atl_primal_to_covolume_projection.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_primal_to_covolume_projection_1d.html'>atl_primal_to_covolume_projection_1d</a></td>
                 <td><a href='../module/atl_covolume_projection_module.html'>atl_covolume_projection_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Project two elements onto single co-volume element.</p><a href="../proc/atl_primal_to_covolume_projection_1d.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_primal_to_covolume_projection_2d.html'>atl_primal_to_covolume_projection_2d</a></td>
                 <td><a href='../module/atl_covolume_projection_module.html'>atl_covolume_projection_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Project two elements onto single co-volume element.</p><a href="../proc/atl_primal_to_covolume_projection_2d.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_qcriterion_getelement.html'>atl_qCriterion_getElement</a></td>
                 <td><a href='../module/atl_eqn_euler_derive_module.html'>atl_eqn_euler_derive_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_qcriterion_getpoint.html'>atl_qCriterion_getPoint</a></td>
                 <td><a href='../module/atl_eqn_euler_derive_module.html'>atl_eqn_euler_derive_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_rans_pressure_getelement.html'>atl_Rans_pressure_getElement</a></td>
                 <td><a href='../module/atl_eqn_filnvrstk_derive_module.html'>atl_eqn_filNvrStk_derive_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_rans_pressure_getpoint.html'>atl_Rans_pressure_getPoint</a></td>
                 <td><a href='../module/atl_eqn_filnvrstk_derive_module.html'>atl_eqn_filNvrStk_derive_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_read_precice.html'>atl_read_precice</a></td>
                 <td><a href='../module/atl_writeprecice_module.html'>atl_writePrecice_module</a></td>
                 <td>Subroutine</td>
                 <td><p>loop over linked list of spacetimefunction
set the current to head
loop over all shapes of that spacetimefunction
check if there is a precice kind
get the number of unquie points ( xyz should be same number)</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_readrestart.html'>atl_readRestart</a></td>
                 <td><a href='../module/atl_restart_module.html'>atl_restart_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Read the serialized restart file into the state vectors</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_reassignstfunptr.html'>atl_reassignStFunPtr</a></td>
                 <td><a href='../module/atl_materialini_module.html'>atl_materialIni_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Reassigns the spacetime function pointers based on the material variable
position and the spacetime function position.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_ref_in_elempos.html'>atl_ref_in_elempos</a></td>
                 <td><a href='../module/atl_reference_element_module.html'>atl_reference_element_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Transform reference points to physical points in the element
of the tree identified by the provided elempos.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_reftophyscoord.html'>atl_refToPhysCoord</a></td>
                 <td><a href='../module/atl_reference_element_module.html'>atl_reference_element_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Subroutine to move points defined on the reference element [-1,+1] to
the physical element coordinates.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_resettimers.html'>atl_resetTimers</a></td>
                 <td><a href='../module/atl_timer_module.html'>atl_timer_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_save_acoustic.html'>atl_save_acoustic</a></td>
                 <td><a href='../module/atl_eqn_acoustic_module.html'>atl_eqn_acoustic_module</a></td>
                 <td>Subroutine</td>
                 <td><p>dump the equation variables into the lua file</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_save_advection_1d.html'>atl_save_advection_1d</a></td>
                 <td><a href='../module/atl_eqn_advection_1d_module.html'>atl_eqn_advection_1d_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_save_euler.html'>atl_save_euler</a></td>
                 <td><a href='../module/atl_eqn_euler_module.html'>atl_eqn_euler_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_save_heat.html'>atl_save_heat</a></td>
                 <td><a href='../module/atl_eqn_heat_module.html'>atl_eqn_heat_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_save_lineareuler.html'>atl_save_LinearEuler</a></td>
                 <td><a href='../module/atl_eqn_lineareuler_module.html'>atl_eqn_LinearEuler_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_save_maxwell.html'>atl_save_maxwell</a></td>
                 <td><a href='../module/atl_eqn_maxwell_module.html'>atl_eqn_maxwell_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_save_navierstokes.html'>atl_save_navierStokes</a></td>
                 <td><a href='../module/atl_eqn_nvrstk_module.html'>atl_eqn_nvrstk_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_schemeid2ndim.html'>atl_schemeID2ndim</a></td>
                 <td><a href='../module/atl_scheme_module.html'>atl_scheme_module</a></td>
                 <td>Function</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_set_covolume_bnd.html'>atl_set_covolume_bnd</a></td>
                 <td><a href='../module/atl_covolume_boundary_module.html'>atl_covolume_boundary_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Routine to set boundary values for the covolume filter.</p><a href="../proc/atl_set_covolume_bnd.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_set_cpl_elemtimers.html'>atl_set_cpl_elemTimers</a></td>
                 <td><a href='../module/atl_timer_module.html'>atl_timer_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine sets elementTimers passed by apesmate</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_set_elemtimers.html'>atl_set_elemTimers</a></td>
                 <td><a href='../module/atl_timer_module.html'>atl_timer_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine sets elementTimers passed by apesmate</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_set_opvar_getelement.html'>atl_set_opVar_getElement</a></td>
                 <td><a href='../module/atl_operator_module.html'>atl_operator_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_set_stfun_getelement.html'>atl_set_stFun_getElement</a></td>
                 <td><a href='../module/atl_varsys_module.html'>atl_varSys_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_set_timerhandles.html'>atl_set_timerHandles</a></td>
                 <td><a href='../module/atl_timer_module.html'>atl_timer_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine sets atl_timerHandles passed by apesmate</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_shearestimate_getelement.html'>atl_shearestimate_getElement</a></td>
                 <td><a href='../module/atl_eqn_nvrstk_var_module.html'>atl_eqn_nvrstk_var_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_shearestimate_getpoint.html'>atl_shearestimate_getPoint</a></td>
                 <td><a href='../module/atl_eqn_nvrstk_var_module.html'>atl_eqn_nvrstk_var_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_solve_program.html'>atl_solve_program</a></td>
                 <td><a href='../module/atl_program_module.html'>atl_program_module</a></td>
                 <td>Subroutine</td>
                 <td><p>NE ! Dump and reset the timer after each Iteration
NE call atl_dumpTimers( general = params%general,                      &amp;
NE   &amp;                  nElems  = tree%global%nElems,                  &amp;
NE   &amp;                  nDofs   = element_container%cubes              &amp;
NE   &amp;                              %scheme_list(tree%global%minLevel) &amp;
NE   &amp;                              %nDofs,                            &amp;
NE   &amp;                  nVars   = equation%varSys%nScalars             )
NE call atl_resetTimers()</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_source_prim2cons.html'>atl_source_prim2cons</a></td>
                 <td><a href='../module/atl_source_module.html'>atl_source_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine converts primitive variables in source terms to convervative</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_spectral_visc_1d.html'>atl_spectral_visc_1d</a></td>
                 <td><a href='../module/atl_stabilize_module.html'>atl_stabilize_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Damp )the modal coefficients of the state vector by a given spectral viscosity
method.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_spectral_visc_2d.html'>atl_spectral_visc_2d</a></td>
                 <td><a href='../module/atl_stabilize_module.html'>atl_stabilize_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Damp )the modal coefficients of the state vector by a given spectral
viscosity method.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_spectral_visc_3d.html'>atl_spectral_visc_3d</a></td>
                 <td><a href='../module/atl_stabilize_module.html'>atl_stabilize_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Damp )the modal coefficients of the state vector by a given spectral
viscosity method.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_speedofsound_getelement.html'>atl_speedOfSound_getElement</a></td>
                 <td><a href='../module/atl_eqn_euler_derive_module.html'>atl_eqn_euler_derive_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_speedofsound_getpoint.html'>atl_speedOfSound_getPoint</a></td>
                 <td><a href='../module/atl_eqn_euler_derive_module.html'>atl_eqn_euler_derive_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_stabilize.html'>atl_stabilize</a></td>
                 <td><a href='../module/atl_stabilize_module.html'>atl_stabilize_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Subroutine to apply the stabilization procedure to the state vector.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_store_bcvarpos.html'>atl_store_bcVarPos</a></td>
                 <td><a href='../module/atl_bc_header_module.html'>atl_bc_header_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Routine to store position of user variable defined state and
 state_gradient boundary variable in bc(iBC)%state(iVar)%varPos
 and bc(iBC)%state_gradient</p><a href="../proc/atl_store_bcvarpos.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_subres_import_color.html'>atl_subres_import_color</a></td>
                 <td><a href='../module/atl_subresolution_module.html'>atl_subresolution_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Get the subresolution data for all elements for a given color and in the
requested format.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_subresolution_load.html'>atl_subresolution_load</a></td>
                 <td><a href='../module/atl_subresolution_module.html'>atl_subresolution_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Subroutine to load subresolution information for a given tree.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_temperature_getelement.html'>atl_temperature_getElement</a></td>
                 <td><a href='../module/atl_eqn_euler_derive_module.html'>atl_eqn_euler_derive_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_temperature_getpoint.html'>atl_temperature_getPoint</a></td>
                 <td><a href='../module/atl_eqn_euler_derive_module.html'>atl_eqn_euler_derive_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_update_materialparams.html'>atl_update_materialParams</a></td>
                 <td><a href='../module/atl_materialini_module.html'>atl_materialIni_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Read the configuration for the material paramters for Maxwell equations
from configuration files and init the material parameter datatype.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_update_sourcedata.html'>atl_update_sourcedata</a></td>
                 <td><a href='../module/atl_source_module.html'>atl_source_module</a></td>
                 <td>Subroutine</td>
                 <td><p>subroutine to calculate the RHS of the PDE from the sum of all</p><a href="../proc/atl_update_sourcedata.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_varsys_getstateforelement.html'>atl_varSys_getStateForElement</a></td>
                 <td><a href='../module/atl_varsys_module.html'>atl_varSys_module</a></td>
                 <td>Subroutine</td>
                 <td><p>To obtain values of a given variable, it is necessary to state the
treeID and time at which the variable should be evaluated.
The interface is nDofs values to cover the all degrees of freedoms
in the element.
Of course the variable system itself also needs to be passed in, to
allow the computation of other derived quantities as needed.
The method description itself is passed in automatically, and has not
to be provided explicitly.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_varsys_getstateforpoint.html'>atl_varSys_getStateForPoint</a></td>
                 <td><a href='../module/atl_varsys_module.html'>atl_varSys_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Interface description for a variable access method (single point).</p><a href="../proc/atl_varsys_getstateforpoint.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_varsys_getstatevalofindex.html'>atl_varSys_getStateValOfIndex</a></td>
                 <td><a href='../module/atl_varsys_module.html'>atl_varSys_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Routine for gettint the actual value for a given array of indices.
The indices belong to the grwarray of points storing levelwise in
Pointdata%pntLvl(iLevel).
Hence this routines takes the indeices as input, can refer to the pointData
and evaluate the variable and returns the values</p><a href="../proc/atl_varsys_getstatevalofindex.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_varsys_load_user.html'>atl_varSys_load_user</a></td>
                 <td><a href='../module/atl_varsys_module.html'>atl_varSys_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Method to load user defined variables from the configuration.</p><a href="../proc/atl_varsys_load_user.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_varsys_setupstateindices.html'>atl_varSys_setupStateIndices</a></td>
                 <td><a href='../module/atl_varsys_module.html'>atl_varSys_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine takes points coordinates, stores them in the method_data and
return indices where points are located in the growing array of points or
values ( sometimes we do not need to store the points )
It is need to setup points for every variable. Points will be provided by
boundaries or sources depends on what uses the variable. This points do not
change with time . This indices will be stored in corresponding boundary
or source to evaluate a value on that point later using
tem_varSys_proc_getValOfIndex.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_viscindicator_getelement.html'>atl_viscindicator_getElement</a></td>
                 <td><a href='../module/atl_eqn_nvrstk_var_module.html'>atl_eqn_nvrstk_var_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_viscindicator_getpoint.html'>atl_viscindicator_getPoint</a></td>
                 <td><a href='../module/atl_eqn_nvrstk_var_module.html'>atl_eqn_nvrstk_var_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_viscnavierstokes.html'>atl_viscNavierStokes</a></td>
                 <td><a href='../module/atl_viscnumflux_nvrstk_module.html'>atl_viscNumFlux_Nvrstk_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_viscnavierstokes_2d.html'>atl_viscNavierStokes_2d</a></td>
                 <td><a href='../module/atl_viscnumflux_nvrstk_2d_module.html'>atl_viscNumFlux_Nvrstk_2d_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_viscphysfluxnavierstokes.html'>atl_viscPhysFluxNavierStokes</a></td>
                 <td><a href='../module/atl_physfluxnvrstk_module.html'>atl_physFluxNvrStk_module</a></td>
                 <td>Function</td>
                 <td><p>Physical flux calculation along x direction for Euler equation.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_viscphysfluxnavierstokes_2d.html'>atl_viscPhysFluxNavierStokes_2d</a></td>
                 <td><a href='../module/atl_physfluxnvrstk_2d_module.html'>atl_physFluxNvrStk_2d_module</a></td>
                 <td>Function</td>
                 <td><p>Physical flux calculation along x direction for Euler equation.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_viscphysfluxrans.html'>atl_viscPhysFluxRans</a></td>
                 <td><a href='../module/atl_physfluxfilnvrstk_module.html'>atl_physFluxFilNvrStk_module</a></td>
                 <td>Function</td>
                 <td><p>Physical flux calculation along x direction for Euler equation.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_viscphysfluxrans_2d.html'>atl_viscPhysFluxRans_2d</a></td>
                 <td><a href='../module/atl_physfluxfilnvrstk_module.html'>atl_physFluxFilNvrStk_module</a></td>
                 <td>Function</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_viscrans_2d.html'>atl_viscRans_2d</a></td>
                 <td><a href='../module/atl_numflux_filnvrstk_module.html'>atl_numFlux_filNvrStk_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_voltoface.html'>atl_volToFace</a></td>
                 <td><a href='../module/atl_covolume_boundary_module.html'>atl_covolume_boundary_module</a></td>
                 <td>Function</td>
                 <td><p>Project elemental state to a particular face.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_voltoface_1d.html'>atl_volToFace_1d</a></td>
                 <td><a href='../module/atl_covolume_boundary_module.html'>atl_covolume_boundary_module</a></td>
                 <td>Function</td>
                 <td><p>Project elemental state to a particular face.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_voltoface_2d.html'>atl_volToFace_2d</a></td>
                 <td><a href='../module/atl_covolume_boundary_module.html'>atl_covolume_boundary_module</a></td>
                 <td>Function</td>
                 <td><p>Project elemental state to a particular face.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_vorticity_getelement.html'>atl_vorticity_getElement</a></td>
                 <td><a href='../module/atl_eqn_euler_derive_module.html'>atl_eqn_euler_derive_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_vorticity_getpoint.html'>atl_vorticity_getPoint</a></td>
                 <td><a href='../module/atl_eqn_euler_derive_module.html'>atl_eqn_euler_derive_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_write_equipoints.html'>atl_write_equiPoints</a></td>
                 <td><a href='../module/atl_writeprecice_module.html'>atl_writePrecice_module</a></td>
                 <td>Subroutine</td>
                 <td><p>ceate equidistant points for write to precice and use the number of these
 points for the setup_indices routine. If its set by the user, the
 Nearest-Pojection can be used for these points</p><a href="../proc/atl_write_equipoints.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_write_nonequipoints.html'>atl_write_nonequiPoints</a></td>
                 <td><a href='../module/atl_writeprecice_module.html'>atl_writePrecice_module</a></td>
                 <td>Subroutine</td>
                 <td><p>setup_indices for boundary variables are read_var in precice
 space-time function we are not able to use 'idx' created here as input for
 get_valOfIndex for write_vars.Therefore we have to do setup_indices for
 write_vars once during initialization and then store the idx in
 precice_coupling type. This is done for the non-equidistant points. We also
 set the vertices and the edges as well as the triangles for the
 Interpolation between the domains.</p><a href="../proc/atl_write_nonequipoints.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_write_precice.html'>atl_write_precice</a></td>
                 <td><a href='../module/atl_writeprecice_module.html'>atl_writePrecice_module</a></td>
                 <td>Subroutine</td>
                 <td><p>loop over linked list of spacetimefunction
set the current to head
loop over all shapes of that spacetimefunction
check if there is a precice kind</p><a href="../proc/atl_write_precice.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_write_precice_getpoint.html'>atl_write_precice_getPoint</a></td>
                 <td><a href='../module/atl_writeprecice_module.html'>atl_writePrecice_module</a></td>
                 <td>Subroutine</td>
                 <td><p>loop over linked list of spacetimefunction
 set the current to head
check if there is a precice kind
loop over all shapes of that spacetimefunction</p><a href="../proc/atl_write_precice_getpoint.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_writerestart.html'>atl_writeRestart</a></td>
                 <td><a href='../module/atl_restart_module.html'>atl_restart_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Writes a restart file for the current point in time.</p><a href="../proc/atl_writerestart.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_writerestartifnecessary.html'>atl_writeRestartIfNecessary</a></td>
                 <td><a href='../module/atl_restart_module.html'>atl_restart_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Writes a restart file, if necessary.</p><a href="../proc/atl_writerestartifnecessary.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_writesolverspecinfo.html'>atl_writeSolverSpecInfo</a></td>
                 <td><a href='../module/atl_restart_module.html'>atl_restart_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Write solver specific info to scratch file</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_xfrom1d_getelement.html'>atl_xFrom1D_getElement</a></td>
                 <td><a href='../module/atl_eqn_maxwell_2d_derive_module.html'>atl_eqn_maxwell_2d_derive_module</a></td>
                 <td>Subroutine</td>
                 <td><p>We only want to have one component, thus we don't need to loop over them</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_xfrom1d_getpoint.html'>atl_xFrom1D_getPoint</a></td>
                 <td><a href='../module/atl_eqn_maxwell_2d_derive_module.html'>atl_eqn_maxwell_2d_derive_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_xfrom2d_getelement.html'>atl_xFrom2D_getElement</a></td>
                 <td><a href='../module/atl_eqn_maxwell_2d_derive_module.html'>atl_eqn_maxwell_2d_derive_module</a></td>
                 <td>Subroutine</td>
                 <td><p>We only want to have one component, thus we don't need to loop over them</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_xfrom2d_getpoint.html'>atl_xFrom2D_getPoint</a></td>
                 <td><a href='../module/atl_eqn_maxwell_2d_derive_module.html'>atl_eqn_maxwell_2d_derive_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_xfrom3d_getelement.html'>atl_xFrom3D_getElement</a></td>
                 <td><a href='../module/atl_eqn_maxwell_derive_module.html'>atl_eqn_maxwell_derive_module</a></td>
                 <td>Subroutine</td>
                 <td><p>We only want to have one component, thus we don't need to loop over them</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_xfrom3d_getpoint.html'>atl_xFrom3D_getPoint</a></td>
                 <td><a href='../module/atl_eqn_maxwell_derive_module.html'>atl_eqn_maxwell_derive_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_yfrom2d_getelement.html'>atl_yFrom2D_getElement</a></td>
                 <td><a href='../module/atl_eqn_maxwell_2d_derive_module.html'>atl_eqn_maxwell_2d_derive_module</a></td>
                 <td>Subroutine</td>
                 <td><p>We only want to have one component, thus we don't need to loop over them</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_yfrom2d_getpoint.html'>atl_yFrom2D_getPoint</a></td>
                 <td><a href='../module/atl_eqn_maxwell_2d_derive_module.html'>atl_eqn_maxwell_2d_derive_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_yfrom3d_getelement.html'>atl_yFrom3D_getElement</a></td>
                 <td><a href='../module/atl_eqn_maxwell_derive_module.html'>atl_eqn_maxwell_derive_module</a></td>
                 <td>Subroutine</td>
                 <td><p>We only want to have one component, thus we don't need to loop over them</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_yfrom3d_getpoint.html'>atl_yFrom3D_getPoint</a></td>
                 <td><a href='../module/atl_eqn_maxwell_derive_module.html'>atl_eqn_maxwell_derive_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_zfrom3d_getelement.html'>atl_zFrom3D_getElement</a></td>
                 <td><a href='../module/atl_eqn_maxwell_derive_module.html'>atl_eqn_maxwell_derive_module</a></td>
                 <td>Subroutine</td>
                 <td><p>We only want to have one component, thus we don't need to loop over them</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/atl_zfrom3d_getpoint.html'>atl_zFrom3D_getPoint</a></td>
                 <td><a href='../module/atl_eqn_maxwell_derive_module.html'>atl_eqn_maxwell_derive_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/beta.html'>beta</a></td>
                 <td><a href='../module/ply_split_legendre_module.html'>ply_split_legendre_module</a></td>
                 <td>Function</td>
                 <td><p>Coefficient beta from the recursive formulation of Legendre polynomials,
 for the Legendre mode 'mode'.</p><a href="../proc/beta.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/bico.html'>bico</a></td>
                 <td><a href='../program/integrateleg_test.html'>integrateLeg_test</a></td>
                 <td>Function</td>
                 <td><p>Compute the binomial n over k</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/calc_barycoord.html'>calc_barycoord</a></td>
                 <td><a href='../module/atl_cube_elem_module.html'>atl_cube_elem_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate barycentric coordinates of the tree ids given in treeids.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/calc_common_global_timestep.html'>calc_common_global_timestep</a></td>
                 <td><a href='../module/atl_calc_time_module.html'>atl_calc_time_module</a></td>
                 <td>Function</td>
                 <td><p>Function to find a single global time step for all levels and processes.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/calc_eigenvalues_3by3_matrix.html'>calc_eigenValues_3by3_matrix</a></td>
                 <td><a href='../module/atl_eqn_euler_derive_module.html'>atl_eqn_euler_derive_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/calc_matrix_qcriterion.html'>calc_matrix_QCriterion</a></td>
                 <td><a href='../module/atl_eqn_euler_derive_module.html'>atl_eqn_euler_derive_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/calc_timestep_acoustic_2d_cube.html'>calc_timestep_acoustic_2d_cube</a></td>
                 <td><a href='../module/atl_calc_time_module.html'>atl_calc_time_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate time step based on a given CFL condition for a cube in a acoustic
simulation.</p><a href="../proc/calc_timestep_acoustic_2d_cube.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/calc_timestep_acoustic_cube.html'>calc_timestep_acoustic_cube</a></td>
                 <td><a href='../module/atl_calc_time_module.html'>atl_calc_time_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate time step based on a given CFL condition for a cube in a acoustic
simulation.</p><a href="../proc/calc_timestep_acoustic_cube.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/calc_timestep_adv_cube.html'>calc_timestep_adv_cube</a></td>
                 <td><a href='../module/atl_calc_time_module.html'>atl_calc_time_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate time step based on a given CFL number of cubes in a
advection simulation.</p><a href="../proc/calc_timestep_adv_cube.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/calc_timestep_ed_cube.html'>calc_timestep_ed_cube</a></td>
                 <td><a href='../module/atl_calc_time_module.html'>atl_calc_time_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate time step based on a given CFL number of cubes in a
electrodynamic simulation.</p><a href="../proc/calc_timestep_ed_cube.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/calc_timestep_flow_cube.html'>calc_timestep_flow_cube</a></td>
                 <td><a href='../module/atl_calc_time_module.html'>atl_calc_time_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate time step based on a given CFL condition for a cube in a flow
simulation.</p><a href="../proc/calc_timestep_flow_cube.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/calc_timestep_flow_cube_1d.html'>calc_timestep_flow_cube_1d</a></td>
                 <td><a href='../module/atl_calc_time_module.html'>atl_calc_time_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate time step based on a given CFL condition for a cube in a flow
simulation.</p><a href="../proc/calc_timestep_flow_cube_1d.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/calc_timestep_flow_cube_2d.html'>calc_timestep_flow_cube_2d</a></td>
                 <td><a href='../module/atl_calc_time_module.html'>atl_calc_time_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate time step based on a given CFL condition for a cube in a flow
simulation.</p><a href="../proc/calc_timestep_flow_cube_2d.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/calc_timestep_flow_cube_mod.html'>calc_timestep_flow_cube_mod</a></td>
                 <td><a href='../module/atl_calc_time_module.html'>atl_calc_time_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/calc_timestep_heat_cube_1d.html'>calc_timestep_heat_cube_1d</a></td>
                 <td><a href='../module/atl_calc_time_module.html'>atl_calc_time_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate time step based on a given CFL condition for a cube in a flow
simulation.</p><a href="../proc/calc_timestep_heat_cube_1d.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/calc_timestep_lineareuler_2d_cube.html'>calc_timestep_linearEuler_2d_cube</a></td>
                 <td><a href='../module/atl_calc_time_module.html'>atl_calc_time_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate time step based on a given CFL condition for a cube in a linear
Euler 2d simulation.</p><a href="../proc/calc_timestep_lineareuler_2d_cube.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/calc_timestep_lineareuler_cube.html'>calc_timestep_linearEuler_cube</a></td>
                 <td><a href='../module/atl_calc_time_module.html'>atl_calc_time_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate time step based on a given CFL condition for a cube in a linear
Euler simulation.</p><a href="../proc/calc_timestep_lineareuler_cube.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/calc_timestep_nerplanck_cube.html'>calc_timestep_nerplanck_cube</a></td>
                 <td><a href='../module/atl_calc_time_module.html'>atl_calc_time_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate time step based on a given CFL number of cubes in a
Nernst-Planck simulation.</p><a href="../proc/calc_timestep_nerplanck_cube.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/calc_timestep_viscflow_cube.html'>calc_timestep_viscflow_cube</a></td>
                 <td><a href='../module/atl_calc_time_module.html'>atl_calc_time_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate time step based on a given CFL condition for a cube in a viscous
flow simulation.</p><a href="../proc/calc_timestep_viscflow_cube.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/calc_timestep_viscflow_cube_2d.html'>calc_timestep_viscflow_cube_2d</a></td>
                 <td><a href='../module/atl_calc_time_module.html'>atl_calc_time_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate time step based on a given CFL condition for a cube in a viscous
flow simulation.</p><a href="../proc/calc_timestep_viscflow_cube_2d.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/calculate_cfl_timestep.html'>calculate_cfl_timestep</a></td>
                 <td><a href='../module/atl_calc_time_module.html'>atl_calc_time_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate the timestep for a whole part of a cubic mesh by a CFL condition.</p><a href="../proc/calculate_cfl_timestep.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/check_fpt.html'>check_fpt</a></td>
                 <td><a href='../program/ply_project_fpt_lobattopoints_test.html'>ply_project_fpt_lobattoPoints_test</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/check_fpt~2.html'>check_fpt</a></td>
                 <td><a href='../program/ply_project_fpt_test.html'>ply_project_fpt_test</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/check_fpt_2d.html'>check_fpt_2d</a></td>
                 <td><a href='../program/ply_project_2d_fpt_test.html'>ply_project_2d_fpt_test</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/check_fpt_2d~2.html'>check_fpt_2d</a></td>
                 <td><a href='../program/ply_project_2d_fpt_lobattopoints_test.html'>ply_project_2d_fpt_lobattoPoints_test</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/check_fwd_bwd.html'>check_fwd_bwd</a></td>
                 <td><a href='../program/ply_fpt_ifpt_test.html'>ply_fpt_ifpt_test</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/check_fxt_1d.html'>check_fxt_1d</a></td>
                 <td><a href='../program/test_fxtd_n2m2n.html'>test_fxtd_n2m2n</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/check_fxt_2d.html'>check_fxt_2d</a></td>
                 <td><a href='../program/test_fxtd_n2m2n.html'>test_fxtd_n2m2n</a></td>
                 <td>Subroutine</td>
                 <td><p>todo NA: Check if nodes kind and factor are correctly used for</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/check_fxt_3d.html'>check_fxt_3D</a></td>
                 <td><a href='../program/test_fxtd_n2m2n.html'>test_fxtd_n2m2n</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/compute_intermediate.html'>compute_intermediate</a></td>
                 <td><a href='../module/atl_ssprk2_module.html'>atl_ssprk2_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/compute_physflux.html'>compute_physFlux</a></td>
                 <td><a href='../module/atl_modg_maxwell_kernel_module.html'>atl_modg_maxwell_kernel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Compute the physical flux in x direction.</p><a href="../proc/compute_physflux.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/compute_physflux_2d.html'>compute_physFlux_2d</a></td>
                 <td><a href='../module/atl_modg_2d_maxwell_kernel_module.html'>atl_modg_2d_maxwell_kernel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Compute the physical flux in x direction.</p><a href="../proc/compute_physflux_2d.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/compute_physflux_nonconst.html'>compute_physFlux_nonConst</a></td>
                 <td><a href='../module/atl_modg_maxwell_kernel_module.html'>atl_modg_maxwell_kernel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Compute the physical flux in x direction.</p><a href="../proc/compute_physflux_nonconst.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/compute_physflux_nonconst_2d.html'>compute_physFlux_nonConst_2d</a></td>
                 <td><a href='../module/atl_modg_2d_maxwell_kernel_module.html'>atl_modg_2d_maxwell_kernel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Compute the physical flux in x direction.</p><a href="../proc/compute_physflux_nonconst_2d.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/compute_physfluxdivcor.html'>compute_physFluxDivCor</a></td>
                 <td><a href='../module/atl_modg_maxwelldivcor_kernel_module.html'>atl_modg_maxwellDivCor_kernel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Compute the physical flux in x direction. For other directions a properly
defined variable permutation can be used. This routine covers only constant
material parameters.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/compute_physfluxdivcor_nonconst.html'>compute_physFluxDivCor_nonConst</a></td>
                 <td><a href='../module/atl_modg_maxwelldivcor_kernel_module.html'>atl_modg_maxwellDivCor_kernel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Compute the physical flux in x direction. For other directions a properly
defined variable permutation can be used. This routine covers non-constant
material parameters.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/compute_rhs_cubes.html'>compute_rhs_cubes</a></td>
                 <td><a href='../module/atl_compute_module.html'>atl_compute_module</a></td>
                 <td>Subroutine</td>
                 <td><p>compute the right hand side of your discrete equation.</p><a href="../proc/compute_rhs_cubes.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/compute_rhs_cubes_modg.html'>compute_rhs_cubes_modg</a></td>
                 <td><a href='../module/atl_compute_module.html'>atl_compute_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Computes the right hand side for cubical elements and MODG scheme.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/compute_rhs_cubes_modg_1d.html'>compute_rhs_cubes_modg_1d</a></td>
                 <td><a href='../module/atl_compute_module.html'>atl_compute_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Computes the right hand side for cubical elements and 1D MODG scheme.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/compute_rhs_cubes_modg_2d.html'>compute_rhs_cubes_modg_2d</a></td>
                 <td><a href='../module/atl_compute_module.html'>atl_compute_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Computes the right hand side for cubical elements and 2D MODG scheme.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/compute_scalprod_dualleg.html'>compute_scalProd_DualLeg</a></td>
                 <td><a href='../module/atl_scheme_module.html'>atl_scheme_module</a></td>
                 <td>Subroutine</td>
                 <td><p>precompute the scalar products of the anstaz and test function</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/compute_up.html'>compute_up</a></td>
                 <td><a href='../module/atl_ssprk2_module.html'>atl_ssprk2_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/compute_vec.html'>compute_vec</a></td>
                 <td><a href='../module/atl_ssprk2_module.html'>atl_ssprk2_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/copy_fpt.html'>Copy_fpt</a></td>
                 <td><a href='../module/ply_legfpt_module.html'>ply_legFpt_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/copy_fpt_header.html'>Copy_fpt_header</a></td>
                 <td><a href='../module/ply_fpt_header_module.html'>ply_fpt_header_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Copy the FPT header information.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/copy_fxt_header.html'>Copy_fxt_header</a></td>
                 <td><a href='../module/ply_fxt_header_module.html'>ply_fxt_header_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/copy_l2p_header.html'>Copy_l2p_header</a></td>
                 <td><a href='../module/ply_l2p_header_module.html'>ply_l2p_header_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/copy_nodes_header.html'>Copy_nodes_header</a></td>
                 <td><a href='../module/ply_nodes_header_module.html'>ply_nodes_header_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/copy_ply_l2p.html'>Copy_ply_l2p</a></td>
                 <td><a href='../module/ply_l2p_module.html'>ply_l2p_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/copy_ply_prj_init.html'>Copy_ply_prj_init</a></td>
                 <td><a href='../module/ply_dynarray_project_module.html'>ply_dynarray_project_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/copy_poly_proj_header.html'>Copy_poly_proj_header</a></td>
                 <td><a href='../module/ply_prj_header_module.html'>ply_prj_header_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/copy_poly_project.html'>Copy_poly_project</a></td>
                 <td><a href='../module/ply_poly_project_module.html'>ply_poly_project_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/copy_poly_project_body.html'>Copy_poly_project_body</a></td>
                 <td><a href='../module/ply_poly_project_module.html'>ply_poly_project_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/copy_trafo_params.html'>Copy_trafo_params</a></td>
                 <td><a href='../module/ply_polybaseexc_module.html'>ply_polyBaseExc_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/create_global_timestep.html'>create_global_timestep</a></td>
                 <td><a href='../module/atl_calc_time_module.html'>atl_calc_time_module</a></td>
                 <td>Subroutine</td>
                 <td><p>\brief subroutine to create a single global timestep.</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/destroy.html'>destroy</a></td>
                 <td><a href='../module/ply_dynarray_project_module.html'>ply_dynarray_project_module</a></td>
                 <td>Interface</td>
                 <td><p>destroy the dynamic array</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/destroy_da_projection.html'>destroy_da_projection</a></td>
                 <td><a href='../module/ply_dynarray_project_module.html'>ply_dynarray_project_module</a></td>
                 <td>Subroutine</td>
                 <td><p>destruction of a dynamic array</p><a href="../proc/destroy_da_projection.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/elemental_timestep_euler.html'>elemental_timestep_euler</a></td>
                 <td><a href='../module/atl_fwdeuler_module.html'>atl_fwdEuler_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Interface definition for elementwise timestepping routine.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/elemental_timestep_imexrk.html'>elemental_timestep_imexrk</a></td>
                 <td><a href='../module/atl_imexrk_module.html'>atl_imexrk_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Elemental operation for timestepping IMEX-RK.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/elemental_timestep_predcor_cerk4.html'>elemental_timestep_predcor_cerk4</a></td>
                 <td><a href='../module/atl_predcor_cerk4_module.html'>atl_predcor_cerk4_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Elemental operation for timestepping of order 4.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/elemental_timestep_rk4.html'>elemental_timestep_rk4</a></td>
                 <td><a href='../module/atl_rk4_module.html'>atl_rk4_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Elemental operation for timestepping of order 4.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/elemental_timestep_rktaylor.html'>elemental_timestep_rktaylor</a></td>
                 <td><a href='../module/atl_rktaylor_module.html'>atl_rktaylor_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Elemental operation for timestepping of type Runge Kutta Taylor</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/elemental_timestep_ssprk2.html'>elemental_timestep_ssprk2</a></td>
                 <td><a href='../module/atl_ssprk2_module.html'>atl_ssprk2_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Elemental operation for timestepping of order 2.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/elemental_timestep_vec_euler.html'>elemental_timestep_vec_euler</a></td>
                 <td><a href='../module/atl_fwdeuler_module.html'>atl_fwdEuler_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Interface definition for elementwise timestepping routine.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/elemental_timestep_vec_imexrk.html'>elemental_timestep_vec_imexrk</a></td>
                 <td><a href='../module/atl_imexrk_module.html'>atl_imexrk_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Elemental operation for timestepping of order 4.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/elemental_timestep_vec_predcor_cerk4.html'>elemental_timestep_vec_predcor_cerk4</a></td>
                 <td><a href='../module/atl_predcor_cerk4_module.html'>atl_predcor_cerk4_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Elemental operation for timestepping of order 4.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/elemental_timestep_vec_rk4.html'>elemental_timestep_vec_rk4</a></td>
                 <td><a href='../module/atl_rk4_module.html'>atl_rk4_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Elemental operation for timestepping of order 4.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/elemental_timestep_vec_rktaylor.html'>elemental_timestep_vec_rktaylor</a></td>
                 <td><a href='../module/atl_rktaylor_module.html'>atl_rktaylor_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Elemental operation for timestepping of type Runge Kutta Taylor</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/elemental_timestep_vec_ssprk2.html'>elemental_timestep_vec_ssprk2</a></td>
                 <td><a href='../module/atl_ssprk2_module.html'>atl_ssprk2_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Elemental operation for timestepping of order 2.</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/empty.html'>empty</a></td>
                 <td><a href='../module/ply_dynarray_project_module.html'>ply_dynarray_project_module</a></td>
                 <td>Interface</td>
                 <td><p>empty the array, reset nvals to be 0</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/empty_da_projection.html'>empty_da_projection</a></td>
                 <td><a href='../module/ply_dynarray_project_module.html'>ply_dynarray_project_module</a></td>
                 <td>Subroutine</td>
                 <td><p>empty all contents of the array without changing the size or status of any
array</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/eqn_maxwell_2d_load_bc.html'>eqn_maxwell_2d_load_bc</a></td>
                 <td><a href='../module/atl_eqn_maxwell_hlp_module.html'>atl_eqn_maxwell_hlp_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Subroutine to load boundary conditions for 2D Maxwell equations from
 a Lua configuration file.</p><a href="../proc/eqn_maxwell_2d_load_bc.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/eval_arbitrary.html'>eval_arbitrary</a></td>
                 <td><a href='../module/atl_eqn_euler_var_module.html'>atl_eqn_euler_var_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/eval_arbitrary_2d.html'>eval_arbitrary_2d</a></td>
                 <td><a href='../module/atl_eqn_euler_2d_var_module.html'>atl_eqn_euler_2d_var_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/eval_charge.html'>eval_charge</a></td>
                 <td><a href='../module/atl_eqn_maxwelldivcorr_var_module.html'>atl_eqn_maxwelldivcorr_var_module</a></td>
                 <td>Subroutine</td>
                 <td><p>evaluate "currentDensity" source</p><a href="../proc/eval_charge.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/eval_currentdensity.html'>eval_currentDensity</a></td>
                 <td><a href='../module/atl_eqn_maxwell_var_module.html'>atl_eqn_maxwell_var_module</a></td>
                 <td>Subroutine</td>
                 <td><p>evaluate "currentDensity" source</p><a href="../proc/eval_currentdensity.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/eval_currentdensity_2d.html'>eval_currentDensity_2d</a></td>
                 <td><a href='../module/atl_eqn_maxwell_2d_var_module.html'>atl_eqn_maxwell_2d_var_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/eval_gravitation.html'>eval_gravitation</a></td>
                 <td><a href='../module/atl_eqn_euler_var_module.html'>atl_eqn_euler_var_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/eval_gravitation_2d.html'>eval_gravitation_2d</a></td>
                 <td><a href='../module/atl_eqn_euler_2d_var_module.html'>atl_eqn_euler_2d_var_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/eval_pml_2d.html'>eval_pml_2d</a></td>
                 <td><a href='../module/atl_eqn_maxwell_2d_var_module.html'>atl_eqn_maxwell_2d_var_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/eval_source_arbitrary.html'>eval_source_arbitrary</a></td>
                 <td><a href='../module/atl_eqn_euler_var_module.html'>atl_eqn_euler_var_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/eval_source_arbitrary_2d.html'>eval_source_arbitrary_2d</a></td>
                 <td><a href='../module/atl_eqn_euler_2d_var_module.html'>atl_eqn_euler_2d_var_module</a></td>
                 <td>Subroutine</td>
                 <td><p>PV: Create a unit test for this routine and compare it to the
version before the new varSys</p><a href="../proc/eval_source_arbitrary_2d.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/eval_source_charge.html'>eval_source_charge</a></td>
                 <td><a href='../module/atl_eqn_maxwelldivcorr_var_module.html'>atl_eqn_maxwelldivcorr_var_module</a></td>
                 <td>Subroutine</td>
                 <td><p>evaluate "charge" source</p><a href="../proc/eval_source_charge.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/eval_source_gravitation.html'>eval_source_gravitation</a></td>
                 <td><a href='../module/atl_eqn_euler_var_module.html'>atl_eqn_euler_var_module</a></td>
                 <td>Subroutine</td>
                 <td><p>evaluate "currentDensity" source</p><a href="../proc/eval_source_gravitation.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/eval_source_gravitation_2d.html'>eval_source_gravitation_2d</a></td>
                 <td><a href='../module/atl_eqn_euler_2d_var_module.html'>atl_eqn_euler_2d_var_module</a></td>
                 <td>Subroutine</td>
                 <td><p>PV: Create a unit test for this routine and compare it to the
version before the new varSys</p><a href="../proc/eval_source_gravitation_2d.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/eval_source_pml_2d.html'>eval_source_pml_2d</a></td>
                 <td><a href='../module/atl_eqn_maxwell_2d_var_module.html'>atl_eqn_maxwell_2d_var_module</a></td>
                 <td>Subroutine</td>
                 <td><p>evaluate "pml" source (uniaxial PML)</p><a href="../proc/eval_source_pml_2d.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/eval_source_rans2d.html'>eval_source_rans2D</a></td>
                 <td><a href='../module/atl_eqn_filnvrstk_var_module.html'>atl_eqn_filNvrStk_var_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../interface/expand.html'>expand</a></td>
                 <td><a href='../module/ply_dynarray_project_module.html'>ply_dynarray_project_module</a></td>
                 <td>Interface</td>
                 <td><p>increase the size of the container
for the array.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/expand_da_projection.html'>expand_da_projection</a></td>
                 <td><a href='../module/ply_dynarray_project_module.html'>ply_dynarray_project_module</a></td>
                 <td>Subroutine</td>
                 <td><p>expanding the dynamic array</p><a href="../proc/expand_da_projection.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/fftw_execute_r2r.html'>fftw_execute_r2r</a></td>
                 <td><a href='../module/fftw_wrap.html'>fftw_wrap</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/fftw_plan_many_r2r.html'>fftw_plan_many_r2r</a></td>
                 <td><a href='../module/fftw_wrap.html'>fftw_wrap</a></td>
                 <td>Function</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/fftw_plan_r2r_1d.html'>fftw_plan_r2r_1d</a></td>
                 <td><a href='../module/fftw_wrap.html'>fftw_wrap</a></td>
                 <td>Function</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../interface/fxt_faltld_del.html'>fxt_faltld_del</a></td>
                 <td><a href='../module/fxt_fif.html'>fxt_fif</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../interface/fxt_faltld_evl.html'>fxt_faltld_evl</a></td>
                 <td><a href='../module/fxt_fif.html'>fxt_fif</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../interface/fxt_faltld_exp.html'>fxt_faltld_exp</a></td>
                 <td><a href='../module/fxt_fif.html'>fxt_fif</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../interface/fxt_faltld_preproc.html'>fxt_faltld_preproc</a></td>
                 <td><a href='../module/fxt_fif.html'>fxt_fif</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../interface/fxt_faltld_wsize.html'>fxt_faltld_wsize</a></td>
                 <td><a href='../module/fxt_fif.html'>fxt_fif</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../interface/fxt_faltld_wsizemax.html'>fxt_faltld_wsizemax</a></td>
                 <td><a href='../module/fxt_fif.html'>fxt_fif</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../interface/fxt_flptld_del.html'>fxt_flptld_del</a></td>
                 <td><a href='../module/fxt_fif.html'>fxt_fif</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../interface/fxt_flptld_evl.html'>fxt_flptld_evl</a></td>
                 <td><a href='../module/fxt_fif.html'>fxt_fif</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../interface/fxt_flptld_exp.html'>fxt_flptld_exp</a></td>
                 <td><a href='../module/fxt_fif.html'>fxt_fif</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../interface/fxt_flptld_init.html'>fxt_flptld_init</a></td>
                 <td><a href='../module/fxt_fif.html'>fxt_fif</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../interface/fxt_flptld_preproc.html'>fxt_flptld_preproc</a></td>
                 <td><a href='../module/fxt_fif.html'>fxt_fif</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../interface/fxt_flptld_wsize.html'>fxt_flptld_wsize</a></td>
                 <td><a href='../module/fxt_fif.html'>fxt_fif</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../interface/fxt_vecl_new.html'>fxt_vecl_new</a></td>
                 <td><a href='../module/fxt_fif.html'>fxt_fif</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../interface/fxt_vecld_new.html'>fxt_vecld_new</a></td>
                 <td><a href='../module/fxt_fif.html'>fxt_fif</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../interface/fxtf_faltld_evl.html'>fxtf_faltld_evl</a></td>
                 <td><a href='../module/fxt_fwrap.html'>fxt_fwrap</a></td>
                 <td>Interface</td>
                 <td><p>Interface declarations to the fxtf_wrapper.c routines.</p><a href="../interface/fxtf_faltld_evl.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../interface/fxtf_faltld_exp.html'>fxtf_faltld_exp</a></td>
                 <td><a href='../module/fxt_fwrap.html'>fxt_fwrap</a></td>
                 <td>Interface</td>
                 <td><p>Interface declarations to the fxtf_wrapper.c routines.</p><a href="../interface/fxtf_faltld_exp.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../interface/fxtf_flptld_evl.html'>fxtf_flptld_evl</a></td>
                 <td><a href='../module/fxt_fwrap.html'>fxt_fwrap</a></td>
                 <td>Interface</td>
                 <td><p>Interface declarations to the fxtf_wrapper.c routines.</p><a href="../interface/fxtf_flptld_evl.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../interface/fxtf_flptld_exp.html'>fxtf_flptld_exp</a></td>
                 <td><a href='../module/fxt_fwrap.html'>fxt_fwrap</a></td>
                 <td>Interface</td>
                 <td><p>Interface declarations to the fxtf_wrapper.c routines.</p><a href="../interface/fxtf_flptld_exp.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/fxtf_flptld_init.html'>fxtf_flptld_init</a></td>
                 <td><a href='../module/fxt_fwrap.html'>fxt_fwrap</a></td>
                 <td>Subroutine</td>
                 <td><p>Initialize the flpt data structure for fast legendre polynomial
transformation via the fxtpack.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/fxtf_flptld_m2n.html'>fxtf_flptld_m2n</a></td>
                 <td><a href='../module/fxt_fwrap.html'>fxt_fwrap</a></td>
                 <td>Subroutine</td>
                 <td><p>Convert modal data to nodal data using flpt.</p><a href="../proc/fxtf_flptld_m2n.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/fxtf_flptld_n2m.html'>fxtf_flptld_n2m</a></td>
                 <td><a href='../module/fxt_fwrap.html'>fxt_fwrap</a></td>
                 <td>Subroutine</td>
                 <td><p>Convert nodal data to modal data using flpt.</p><a href="../proc/fxtf_flptld_n2m.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/get_rans_reynolds_tensor_2d.html'>get_rans_reynolds_tensor_2D</a></td>
                 <td><a href='../module/atl_eqn_filnvrstk_var_module.html'>atl_eqn_filNvrStk_var_module</a></td>
                 <td>Subroutine</td>
                 <td><p>current state</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/get_sampled_element.html'>get_sampled_element</a></td>
                 <td><a href='../module/ply_sampling_adaptive_module.html'>ply_sampling_adaptive_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Get sampled data.</p><a href="../proc/get_sampled_element.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/get_sampled_element~2.html'>get_sampled_element</a></td>
                 <td><a href='../module/ply_sampling_module.html'>ply_sampling_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Get sampled data.</p><a href="../proc/get_sampled_element~2.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/get_stateptr.html'>get_statePtr</a></td>
                 <td><a href='../module/atl_operator_module.html'>atl_operator_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/global_corrector_substep.html'>global_corrector_substep</a></td>
                 <td><a href='../module/atl_predcor_cerk4_module.html'>atl_predcor_cerk4_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Subroutine calculates a substep of corrector,
this is the same as a usual substep of the RKDG</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/imexrk_substep.html'>imexrk_substep</a></td>
                 <td><a href='../module/atl_imexrk_module.html'>atl_imexrk_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Subroutine calculates a substep of the IMEX Runge-Kutta timestepping
 scheme.</p><a href="../proc/imexrk_substep.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/imexrk_update.html'>imexrk_update</a></td>
                 <td><a href='../module/atl_imexrk_module.html'>atl_imexrk_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Subroutine calculates the final update step of the Runge-Kutta method.
It is performing levelwise.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/implicit_update.html'>implicit_update</a></td>
                 <td><a href='../module/atl_imexrk_module.html'>atl_imexrk_module</a></td>
                 <td>Subroutine</td>
                 <td><p>and the code from here should move into its hlp module.</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/init.html'>init</a></td>
                 <td><a href='../module/ply_dynarray_project_module.html'>ply_dynarray_project_module</a></td>
                 <td>Interface</td>
                 <td><p>initialize the dynamic array</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/init_da_projection.html'>init_da_projection</a></td>
                 <td><a href='../module/ply_dynarray_project_module.html'>ply_dynarray_project_module</a></td>
                 <td>Subroutine</td>
                 <td><p>initialization of a dynamic array</p><a href="../proc/init_da_projection.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/init_fptheader.html'>init_fptHeader</a></td>
                 <td><a href='../program/ply_fpt_header_test.html'>ply_fpt_header_test</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/init_kernel.html'>init_kernel</a></td>
                 <td><a href='../module/atl_container_module.html'>atl_container_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Initialize the kernel states for all parts of the mesh.</p><a href="../proc/init_kernel.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/init_local_time_integration.html'>init_local_time_integration</a></td>
                 <td><a href='../module/atl_scheme_module.html'>atl_scheme_module</a></td>
                 <td>Subroutine</td>
                 <td><p>routine to init the timestepping scheme.</p><a href="../proc/init_local_time_integration.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/inviscous_deactivated.html'>inviscous_deactivated</a></td>
                 <td><a href='../module/atl_eqn_nvrstk_hlp_module.html'>atl_eqn_nvrstk_hlp_module</a></td>
                 <td>Function</td>
                 <td><p>Deactivate adaptive inviscous computations.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/inviscous_indicator_2d.html'>inviscous_indicator_2d</a></td>
                 <td><a href='../module/atl_eqn_nvrstk_hlp_module.html'>atl_eqn_nvrstk_hlp_module</a></td>
                 <td>Function</td>
                 <td><p>Estimate the impact of viscous terms in 2D.</p><a href="../proc/inviscous_indicator_2d.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/inviscous_indicator_3d.html'>inviscous_indicator_3d</a></td>
                 <td><a href='../module/atl_eqn_nvrstk_hlp_module.html'>atl_eqn_nvrstk_hlp_module</a></td>
                 <td>Function</td>
                 <td><p>Estimate the impact of viscous terms in 3D.</p><a href="../proc/inviscous_indicator_3d.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/isequal.html'>isEqual</a></td>
                 <td><a href='../module/ply_prj_header_module.html'>ply_prj_header_module</a></td>
                 <td>Function</td>
                 <td><p>This function provides the test for equality of the header for two
projections.</p><a href="../proc/isequal.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/isequal~2.html'>isEqual</a></td>
                 <td><a href='../module/ply_fxt_header_module.html'>ply_fxt_header_module</a></td>
                 <td>Function</td>
                 <td><p>This function provides the test for equality of two projections.</p><a href="../proc/isequal~2.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/isequal~3.html'>isEqual</a></td>
                 <td><a href='../program/ply_fpt_header_test.html'>ply_fpt_header_test</a></td>
                 <td>Function</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/isequal~4.html'>isEqual</a></td>
                 <td><a href='../module/ply_l2p_header_module.html'>ply_l2p_header_module</a></td>
                 <td>Function</td>
                 <td><p>This function provides the test for equality of two projections.</p><a href="../proc/isequal~4.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/isequal~5.html'>isEqual</a></td>
                 <td><a href='../module/ply_dynarray_project_module.html'>ply_dynarray_project_module</a></td>
                 <td>Function</td>
                 <td><p>This function provides the test for equality of two projections.</p><a href="../proc/isequal~5.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/isequal~6.html'>isEqual</a></td>
                 <td><a href='../module/ply_fpt_header_module.html'>ply_fpt_header_module</a></td>
                 <td>Function</td>
                 <td><p>This function provides the test for equality of two projections.</p><a href="../proc/isequal~6.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/isequal~7.html'>isEqual</a></td>
                 <td><a href='../module/ply_nodes_header_module.html'>ply_nodes_header_module</a></td>
                 <td>Function</td>
                 <td><p>This function provides the test for equality of two nodes descriptions.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/isgreater.html'>isGreater</a></td>
                 <td><a href='../module/ply_prj_header_module.html'>ply_prj_header_module</a></td>
                 <td>Function</td>
                 <td><p>This function provides a &gt; comparison of the header of two projections.</p><a href="../proc/isgreater.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/isgreater~2.html'>isGreater</a></td>
                 <td><a href='../module/ply_fxt_header_module.html'>ply_fxt_header_module</a></td>
                 <td>Function</td>
                 <td><p>This function provides a &gt; comparison of two projections.</p><a href="../proc/isgreater~2.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/isgreater~3.html'>isGreater</a></td>
                 <td><a href='../program/ply_fpt_header_test.html'>ply_fpt_header_test</a></td>
                 <td>Function</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/isgreater~4.html'>isGreater</a></td>
                 <td><a href='../module/ply_l2p_header_module.html'>ply_l2p_header_module</a></td>
                 <td>Function</td>
                 <td><p>This function provides a &gt; comparison of two projections.</p><a href="../proc/isgreater~4.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/isgreater~5.html'>isGreater</a></td>
                 <td><a href='../module/ply_dynarray_project_module.html'>ply_dynarray_project_module</a></td>
                 <td>Function</td>
                 <td><p>This function provides a &gt; comparison of two projections.</p><a href="../proc/isgreater~5.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/isgreater~6.html'>isGreater</a></td>
                 <td><a href='../module/ply_fpt_header_module.html'>ply_fpt_header_module</a></td>
                 <td>Function</td>
                 <td><p>This function provides a &gt; comparison of two projections.</p><a href="../proc/isgreater~6.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/isgreater~7.html'>isGreater</a></td>
                 <td><a href='../module/ply_nodes_header_module.html'>ply_nodes_header_module</a></td>
                 <td>Function</td>
                 <td><p>This function provides a &gt; comparison of nodes descriptions.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/isgreaterorequal.html'>isGreaterOrEqual</a></td>
                 <td><a href='../module/ply_prj_header_module.html'>ply_prj_header_module</a></td>
                 <td>Function</td>
                 <td><p>This function provides a &gt;= comparison of the header of two projections.</p><a href="../proc/isgreaterorequal.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/isgreaterorequal~2.html'>isGreaterOrEqual</a></td>
                 <td><a href='../module/ply_fxt_header_module.html'>ply_fxt_header_module</a></td>
                 <td>Function</td>
                 <td><p>This function provides a &gt;= comparison of two projections.</p><a href="../proc/isgreaterorequal~2.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/isgreaterorequal~3.html'>isGreaterOrEqual</a></td>
                 <td><a href='../program/ply_fpt_header_test.html'>ply_fpt_header_test</a></td>
                 <td>Function</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/isgreaterorequal~4.html'>isGreaterOrEqual</a></td>
                 <td><a href='../module/ply_l2p_header_module.html'>ply_l2p_header_module</a></td>
                 <td>Function</td>
                 <td><p>This function provides a &gt;= comparison of two projections.</p><a href="../proc/isgreaterorequal~4.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/isgreaterorequal~5.html'>isGreaterOrEqual</a></td>
                 <td><a href='../module/ply_dynarray_project_module.html'>ply_dynarray_project_module</a></td>
                 <td>Function</td>
                 <td><p>This function provides a &gt;= comparison of two projections.</p><a href="../proc/isgreaterorequal~5.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/isgreaterorequal~6.html'>isGreaterOrEqual</a></td>
                 <td><a href='../module/ply_fpt_header_module.html'>ply_fpt_header_module</a></td>
                 <td>Function</td>
                 <td><p>This function provides a &gt;= comparison of two projections.</p><a href="../proc/isgreaterorequal~6.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/isgreaterorequal~7.html'>isGreaterOrEqual</a></td>
                 <td><a href='../module/ply_nodes_header_module.html'>ply_nodes_header_module</a></td>
                 <td>Function</td>
                 <td><p>This function provides a &gt;= comparison of two nodes descriptions.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/issmaller.html'>isSmaller</a></td>
                 <td><a href='../module/ply_prj_header_module.html'>ply_prj_header_module</a></td>
                 <td>Function</td>
                 <td><p>This function provides a &lt; comparison of the header of two projections.</p><a href="../proc/issmaller.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/issmaller~2.html'>isSmaller</a></td>
                 <td><a href='../module/ply_fxt_header_module.html'>ply_fxt_header_module</a></td>
                 <td>Function</td>
                 <td><p>This function provides a &lt; comparison of two projections.</p><a href="../proc/issmaller~2.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/issmaller~3.html'>isSmaller</a></td>
                 <td><a href='../program/ply_fpt_header_test.html'>ply_fpt_header_test</a></td>
                 <td>Function</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/issmaller~4.html'>isSmaller</a></td>
                 <td><a href='../module/ply_l2p_header_module.html'>ply_l2p_header_module</a></td>
                 <td>Function</td>
                 <td><p>This function provides a &lt; comparison of two projections.</p><a href="../proc/issmaller~4.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/issmaller~5.html'>isSmaller</a></td>
                 <td><a href='../module/ply_dynarray_project_module.html'>ply_dynarray_project_module</a></td>
                 <td>Function</td>
                 <td><p>This function provides a &lt; comparison of two projections.</p><a href="../proc/issmaller~5.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/issmaller~6.html'>isSmaller</a></td>
                 <td><a href='../module/ply_fpt_header_module.html'>ply_fpt_header_module</a></td>
                 <td>Function</td>
                 <td><p>This function provides a &lt; comparison of two projections.</p><a href="../proc/issmaller~6.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/issmaller~7.html'>isSmaller</a></td>
                 <td><a href='../module/ply_nodes_header_module.html'>ply_nodes_header_module</a></td>
                 <td>Function</td>
                 <td><p>This function provides a &lt; comparison of two nodes descriptions.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/issmallerorequal.html'>isSmallerOrEqual</a></td>
                 <td><a href='../module/ply_prj_header_module.html'>ply_prj_header_module</a></td>
                 <td>Function</td>
                 <td><p>This function provides a &lt;= comparison of the header of two projections.</p><a href="../proc/issmallerorequal.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/issmallerorequal~2.html'>isSmallerOrEqual</a></td>
                 <td><a href='../module/ply_fxt_header_module.html'>ply_fxt_header_module</a></td>
                 <td>Function</td>
                 <td><p>This function provides a &lt;= comparison of two projections.</p><a href="../proc/issmallerorequal~2.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/issmallerorequal~3.html'>isSmallerOrEqual</a></td>
                 <td><a href='../program/ply_fpt_header_test.html'>ply_fpt_header_test</a></td>
                 <td>Function</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/issmallerorequal~4.html'>isSmallerOrEqual</a></td>
                 <td><a href='../module/ply_l2p_header_module.html'>ply_l2p_header_module</a></td>
                 <td>Function</td>
                 <td><p>This function provides a &lt;= comparison of two projections.</p><a href="../proc/issmallerorequal~4.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/issmallerorequal~5.html'>isSmallerOrEqual</a></td>
                 <td><a href='../module/ply_dynarray_project_module.html'>ply_dynarray_project_module</a></td>
                 <td>Function</td>
                 <td><p>This function provides a &lt;= comparison of two projections.</p><a href="../proc/issmallerorequal~5.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/issmallerorequal~6.html'>isSmallerOrEqual</a></td>
                 <td><a href='../module/ply_fpt_header_module.html'>ply_fpt_header_module</a></td>
                 <td>Function</td>
                 <td><p>This function provides a &lt;= comparison of two projections.</p><a href="../proc/issmallerorequal~6.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/issmallerorequal~7.html'>isSmallerOrEqual</a></td>
                 <td><a href='../module/ply_nodes_header_module.html'>ply_nodes_header_module</a></td>
                 <td>Function</td>
                 <td><p>This function provides a &lt;= comparison of two nodes descriptions.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/isunequal.html'>isUnequal</a></td>
                 <td><a href='../module/ply_prj_header_module.html'>ply_prj_header_module</a></td>
                 <td>Function</td>
                 <td><p>This function provides the test for unequality of the header of two
projections.</p><a href="../proc/isunequal.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/isunequal~2.html'>isUnequal</a></td>
                 <td><a href='../module/ply_fxt_header_module.html'>ply_fxt_header_module</a></td>
                 <td>Function</td>
                 <td><p>This function provides the test for unequality of two projections.</p><a href="../proc/isunequal~2.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/isunequal~3.html'>isUnequal</a></td>
                 <td><a href='../program/ply_fpt_header_test.html'>ply_fpt_header_test</a></td>
                 <td>Function</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/isunequal~4.html'>isUnequal</a></td>
                 <td><a href='../module/ply_l2p_header_module.html'>ply_l2p_header_module</a></td>
                 <td>Function</td>
                 <td><p>This function provides the test for unequality of two projections.</p><a href="../proc/isunequal~4.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/isunequal~5.html'>isUnequal</a></td>
                 <td><a href='../module/ply_dynarray_project_module.html'>ply_dynarray_project_module</a></td>
                 <td>Function</td>
                 <td><p>This function provides the test for unequality of two projections.</p><a href="../proc/isunequal~5.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/isunequal~6.html'>isUnequal</a></td>
                 <td><a href='../module/ply_fpt_header_module.html'>ply_fpt_header_module</a></td>
                 <td>Function</td>
                 <td><p>This function provides the test for unequality of two projections.</p><a href="../proc/isunequal~6.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/isunequal~7.html'>isUnequal</a></td>
                 <td><a href='../module/ply_nodes_header_module.html'>ply_nodes_header_module</a></td>
                 <td>Function</td>
                 <td><p>This function provides the test for unequality of two nodes descriptions.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/linearization_deactivated.html'>linearization_deactivated</a></td>
                 <td><a href='../module/atl_eqn_euler_hlp_module.html'>atl_eqn_euler_hlp_module</a></td>
                 <td>Function</td>
                 <td><p>An indicator that completely deactivates linearization.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/linearization_indicator_density.html'>linearization_indicator_density</a></td>
                 <td><a href='../module/atl_eqn_euler_hlp_module.html'>atl_eqn_euler_hlp_module</a></td>
                 <td>Function</td>
                 <td><p>An indicator to decide whether linearization of fluxes is tolerable
based on the density.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/linearization_indicator_energy1d.html'>linearization_indicator_energy1d</a></td>
                 <td><a href='../module/atl_eqn_euler_hlp_module.html'>atl_eqn_euler_hlp_module</a></td>
                 <td>Function</td>
                 <td><p>An indicator to decide whether linearization of fluxes is tolerable
based on the energy in 2D.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/linearization_indicator_energy2d.html'>linearization_indicator_energy2d</a></td>
                 <td><a href='../module/atl_eqn_euler_hlp_module.html'>atl_eqn_euler_hlp_module</a></td>
                 <td>Function</td>
                 <td><p>An indicator to decide whether linearization of fluxes is tolerable
based on the energy in 2D.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/linearization_indicator_energy3d.html'>linearization_indicator_energy3d</a></td>
                 <td><a href='../module/atl_eqn_euler_hlp_module.html'>atl_eqn_euler_hlp_module</a></td>
                 <td>Function</td>
                 <td><p>An indicator to decide whether linearization of fluxes is tolerable
based on the energy in 3D.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/linearization_indicator_err1d.html'>linearization_indicator_err1d</a></td>
                 <td><a href='../module/atl_eqn_euler_hlp_module.html'>atl_eqn_euler_hlp_module</a></td>
                 <td>Function</td>
                 <td><p>An indicator to decide whether linearization of fluxes is tolerable
based on the error estimate.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/linearization_indicator_err2d.html'>linearization_indicator_err2d</a></td>
                 <td><a href='../module/atl_eqn_euler_hlp_module.html'>atl_eqn_euler_hlp_module</a></td>
                 <td>Function</td>
                 <td><p>An indicator to decide whether linearization of fluxes is tolerable
based on the error estimate.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/linearization_indicator_err3d.html'>linearization_indicator_err3d</a></td>
                 <td><a href='../module/atl_eqn_euler_hlp_module.html'>atl_eqn_euler_hlp_module</a></td>
                 <td>Function</td>
                 <td><p>An indicator to decide whether linearization of fluxes is tolerable
based on the error estimate.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/local_predictor_substep.html'>local_predictor_substep</a></td>
                 <td><a href='../module/atl_predcor_cerk4_module.html'>atl_predcor_cerk4_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Subroutine calculates a substep of the local predictor</p><a href="../proc/local_predictor_substep.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/maxwell_flux_cube.html'>maxwell_flux_cube</a></td>
                 <td><a href='../module/atl_maxwell_flux_module.html'>atl_maxwell_flux_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Subroutine to calculate the flux for pure Maxwell equations without
any divergence cleaning on the reference cubic face.</p><a href="../proc/maxwell_flux_cube.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/maxwell_flux_cube_2d.html'>maxwell_flux_cube_2d</a></td>
                 <td><a href='../module/atl_maxwell_flux_2d_module.html'>atl_maxwell_flux_2d_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Subroutine to calculate the flux for pure Maxwell equations without</p><a href="../proc/maxwell_flux_cube_2d.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/maxwell_flux_cube_vec.html'>maxwell_flux_cube_vec</a></td>
                 <td><a href='../module/atl_maxwell_flux_module.html'>atl_maxwell_flux_module</a></td>
                 <td>Subroutine</td>
                 <td><p>calculate flux of pure maxwell equation directly on the</p><a href="../proc/maxwell_flux_cube_vec.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/maxwell_flux_cube_vec_2d.html'>maxwell_flux_cube_vec_2d</a></td>
                 <td><a href='../module/atl_maxwell_flux_2d_module.html'>atl_maxwell_flux_2d_module</a></td>
                 <td>Subroutine</td>
                 <td><p>calculate flux of pure maxwell equation directly on the face-vector</p><a href="../proc/maxwell_flux_cube_vec_2d.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/maxwell_flux_nonconst_cube_vec.html'>maxwell_flux_nonconst_cube_vec</a></td>
                 <td><a href='../module/atl_maxwell_flux_module.html'>atl_maxwell_flux_module</a></td>
                 <td>Subroutine</td>
                 <td><p>calculate flux of pure maxwell equation directly on the</p><a href="../proc/maxwell_flux_nonconst_cube_vec.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/maxwell_flux_nonconst_cube_vec_2d.html'>maxwell_flux_nonconst_cube_vec_2d</a></td>
                 <td><a href='../module/atl_maxwell_flux_2d_module.html'>atl_maxwell_flux_2d_module</a></td>
                 <td>Subroutine</td>
                 <td><p>calculate flux of pure maxwell equation directly on the face-vector</p><a href="../proc/maxwell_flux_nonconst_cube_vec_2d.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/maxwell_hc_flux_cube.html'>maxwell_hc_flux_cube</a></td>
                 <td><a href='../module/atl_maxwell_flux_module.html'>atl_maxwell_flux_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Subroutine to calculate the flux for pure Maxwell equations with</p><a href="../proc/maxwell_hc_flux_cube.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/maxwell_hc_flux_cube_vec.html'>maxwell_hc_flux_cube_vec</a></td>
                 <td><a href='../module/atl_maxwell_flux_module.html'>atl_maxwell_flux_module</a></td>
                 <td>Subroutine</td>
                 <td><p>calculate flux of maxwell equation with hyperbolic divergence</p><a href="../proc/maxwell_hc_flux_cube_vec.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/maxwell_hc_flux_nonconst_cube_vec.html'>maxwell_hc_flux_nonconst_cube_vec</a></td>
                 <td><a href='../module/atl_maxwell_flux_module.html'>atl_maxwell_flux_module</a></td>
                 <td>Subroutine</td>
                 <td><p>calculate flux of maxwell equation with hyperbolic divergence</p><a href="../proc/maxwell_hc_flux_nonconst_cube_vec.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mesh_timestep_euler.html'>mesh_timestep_euler</a></td>
                 <td><a href='../module/atl_fwdeuler_module.html'>atl_fwdEuler_module</a></td>
                 <td>Subroutine</td>
                 <td><p>subroutine for timestepping with explicit euler.</p><a href="../proc/mesh_timestep_euler.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mesh_timestep_imexrk.html'>mesh_timestep_imexrk</a></td>
                 <td><a href='../module/atl_imexrk_module.html'>atl_imexrk_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Subroutine for timestepping with IMEX Runge-Kutta.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mesh_timestep_predcor_cerk4.html'>mesh_timestep_predcor_cerk4</a></td>
                 <td><a href='../module/atl_predcor_cerk4_module.html'>atl_predcor_cerk4_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Subroutine for timestepping with explicit runge kutta of order 4.</p><a href="../proc/mesh_timestep_predcor_cerk4.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mesh_timestep_rk4.html'>mesh_timestep_rk4</a></td>
                 <td><a href='../module/atl_rk4_module.html'>atl_rk4_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Subroutine for timestepping with explicit runge kutta of order 4.
 It contains four Euler forwarding substeps:
 0.1   temp = u0
 1.1   u1   = rk4_substep(temp) = rhs(temp)
 1.2   temp = u0 + dt/2 * u1
 2.1   u2   = rk4_substep(temp) = rhs(temp)
 2.2   temp = u0 + dt/2 * u2
 3.1   u3   = rk4_substep(temp) = rhs(temp)
 3.2   temp = u0 + dt   * u3
 4.1   u4   = rk4_substep(temp) = rhs(temp)
 4.2   u0   = u0 + dt/6 * ( u1 + 2*(u2+u3) + u4 )
 After each substep, the results are stabilized</p><a href="../proc/mesh_timestep_rk4.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mesh_timestep_rktaylor.html'>mesh_timestep_rktaylor</a></td>
                 <td><a href='../module/atl_rktaylor_module.html'>atl_rktaylor_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Subroutine for timestepping with explicit runge kutta taylor</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mesh_timestep_ssprk2.html'>mesh_timestep_ssprk2</a></td>
                 <td><a href='../module/atl_ssprk2_module.html'>atl_ssprk2_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Subroutine for timestepping with explicit runge kutta of order 2.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/modg_1d_advection_onedim_numflux.html'>modg_1d_advection_oneDim_numFlux</a></td>
                 <td><a href='../module/atl_modg_1d_advection_kernel_module.html'>atl_modg_1d_advection_kernel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Numerical flux calculation for the advection equation across the faces in a single
spatial direction.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/modg_1d_bnd_extrapolate.html'>modg_1d_bnd_extrapolate</a></td>
                 <td><a href='../module/atl_modg_1d_bnd_module.html'>atl_modg_1d_bnd_module</a></td>
                 <td>Function</td>
                 <td><p>Function to extrapolate face values for a given boundary condition in
physical or modal space.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/modg_1d_bnd_mirrormodalconst.html'>modg_1d_bnd_mirrorModalConst</a></td>
                 <td><a href='../module/atl_modg_1d_bnd_module.html'>atl_modg_1d_bnd_module</a></td>
                 <td>Function</td>
                 <td><p>Function to mirror a modal representation around a given boundary condition
in modal space.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/modg_1d_bnd_mirrorpoint.html'>modg_1d_bnd_mirrorPoint</a></td>
                 <td><a href='../module/atl_modg_1d_bnd_module.html'>atl_modg_1d_bnd_module</a></td>
                 <td>Function</td>
                 <td><p>Function to mirror pointvalues for a given boundary conditions.</p><a href="../proc/modg_1d_bnd_mirrorpoint.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/modg_1d_compute_project_physflux.html'>modg_1d_compute_project_physFlux</a></td>
                 <td><a href='../module/atl_compute_module.html'>atl_compute_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/modg_1d_euler_onedim_numflux.html'>modg_1d_euler_oneDim_numFlux</a></td>
                 <td><a href='../module/atl_modg_1d_euler_kernel_module.html'>atl_modg_1d_euler_kernel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Numerical flux calculation for Euler equation across the faces in a single
spatial direction.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/modg_1d_heat_onedim_numflux.html'>modg_1d_heat_oneDim_numFlux</a></td>
                 <td><a href='../module/atl_modg_1d_heat_kernel_module.html'>atl_modg_1d_heat_kernel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Numerical flux calculation for the Heat equation across the faces in a
single spatial direction.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/modg_1d_invmassmatrix_q.html'>modg_1d_invMassMatrix_Q</a></td>
                 <td><a href='../module/atl_modg_1d_kernel_module.html'>atl_modg_1d_kernel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Applies the inverse of the mass matrix for a 3D scheme.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/modg_1d_modal_bnd.html'>modg_1d_modal_bnd</a></td>
                 <td><a href='../module/atl_modg_1d_bnd_module.html'>atl_modg_1d_bnd_module</a></td>
                 <td>Function</td>
                 <td><p>Set boundary values in a modal way</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/modg_1d_nodal_bnd.html'>modg_1d_nodal_bnd</a></td>
                 <td><a href='../module/atl_modg_1d_bnd_module.html'>atl_modg_1d_bnd_module</a></td>
                 <td>Function</td>
                 <td><p>Set boundary values in a nodal way</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/modg_1d_project_numflux_difftestx_q.html'>modg_1d_project_numFlux_diffTestX_Q</a></td>
                 <td><a href='../module/atl_modg_1d_kernel_module.html'>atl_modg_1d_kernel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Projection of the numerical flux in x direction onto the differentiated</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/modg_1d_project_numfluxx_q.html'>modg_1d_project_numFluxX_Q</a></td>
                 <td><a href='../module/atl_modg_1d_kernel_module.html'>atl_modg_1d_kernel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Projection of the numerical flux in x direction onto the testfunctions.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/modg_1d_project_penalization.html'>modg_1d_project_penalization</a></td>
                 <td><a href='../module/atl_modg_1d_kernel_module.html'>atl_modg_1d_kernel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Projection of the penalization terms (in modal representation) to the test functions.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/modg_1d_project_physfluxx_q.html'>modg_1d_project_physFluxX_Q</a></td>
                 <td><a href='../module/atl_modg_1d_kernel_module.html'>atl_modg_1d_kernel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Projection of the physical flux in x direction onto the testfunctions.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/modg_1d_project_source_q.html'>modg_1d_project_source_Q</a></td>
                 <td><a href='../module/atl_modg_1d_kernel_module.html'>atl_modg_1d_kernel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Projection of the source terms (in modal representation) to the test functions.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/modg_1d_project_testfunc_q.html'>modg_1d_project_testFunc_Q</a></td>
                 <td><a href='../module/atl_modg_1d_kernel_module.html'>atl_modg_1d_kernel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Subroutine to project modal representations of physical flux, numerical flux
and source terms onto test functions.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/modg_1d_voltoface_grad_q.html'>modg_1d_VolToFace_grad_Q</a></td>
                 <td><a href='../module/atl_modg_1d_kernel_module.html'>atl_modg_1d_kernel_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/modg_1d_voltoface_q.html'>modg_1d_volToFace_Q</a></td>
                 <td><a href='../module/atl_modg_1d_kernel_module.html'>atl_modg_1d_kernel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Projects derivative of modal representation of each cell to its faces, i.e.
this subroutine creates a modal representation on the faces.
Project modal representation of an element to one of its faces for Q space.</p><a href="../proc/modg_1d_voltoface_q.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/modg_2d_bnd_extrapolate.html'>modg_2d_bnd_extrapolate</a></td>
                 <td><a href='../module/atl_modg_2d_bnd_module.html'>atl_modg_2d_bnd_module</a></td>
                 <td>Function</td>
                 <td><p>Function to extrapolate face values for a given boundary condition in
physical or modal space.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/modg_2d_bnd_mirrorpoint.html'>modg_2d_bnd_mirrorPoint</a></td>
                 <td><a href='../module/atl_modg_2d_bnd_module.html'>atl_modg_2d_bnd_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Function to mirror pointvalues for a given boundary conditions.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/modg_2d_compute_project_physflux.html'>modg_2d_compute_project_physFlux</a></td>
                 <td><a href='../module/atl_compute_module.html'>atl_compute_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This subroutine computes the physical fluxes for various equation system</p><a href="../proc/modg_2d_compute_project_physflux.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/modg_2d_invmassmatrix_p.html'>modg_2d_invMassMatrix_P</a></td>
                 <td><a href='../module/atl_modg_2d_kernel_module.html'>atl_modg_2d_kernel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Applies the inverse of the mass matrix for a 2D scheme in P_space.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/modg_2d_invmassmatrix_q.html'>modg_2d_invMassMatrix_Q</a></td>
                 <td><a href='../module/atl_modg_2d_kernel_module.html'>atl_modg_2d_kernel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Applies the inverse of the mass matrix for a 2D scheme in Q_space.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/modg_2d_modal_bnd.html'>modg_2d_modal_bnd</a></td>
                 <td><a href='../module/atl_modg_2d_bnd_module.html'>atl_modg_2d_bnd_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Set boundary values in a modal way</p><a href="../proc/modg_2d_modal_bnd.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/modg_2d_nodal_bnd.html'>modg_2d_nodal_bnd</a></td>
                 <td><a href='../module/atl_modg_2d_bnd_module.html'>atl_modg_2d_bnd_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Set boundary values in a nodal way</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/modg_2d_project_numfluxx_difftestx_q.html'>modg_2d_project_numFluxX_diffTestX_Q</a></td>
                 <td><a href='../module/atl_modg_2d_kernel_module.html'>atl_modg_2d_kernel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Projection of the numerical flux in x direction onto the testfunctions.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/modg_2d_project_numfluxx_q.html'>modg_2d_project_numFluxX_Q</a></td>
                 <td><a href='../module/atl_modg_2d_kernel_module.html'>atl_modg_2d_kernel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Projection of the numerical flux in x direction onto the testfunctions
for Q_space.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/modg_2d_project_numfluxy_difftesty_q.html'>modg_2d_project_numFluxY_diffTestY_Q</a></td>
                 <td><a href='../module/atl_modg_2d_kernel_module.html'>atl_modg_2d_kernel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Projection of the numerical flux in y direction onto the testfunctions.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/modg_2d_project_numfluxy_q.html'>modg_2d_project_numFluxY_Q</a></td>
                 <td><a href='../module/atl_modg_2d_kernel_module.html'>atl_modg_2d_kernel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Projection of the numerical flux in y direction onto the testfunctions
for Q_space.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/modg_2d_project_penalization_q.html'>modg_2d_project_penalization_Q</a></td>
                 <td><a href='../module/atl_modg_2d_kernel_module.html'>atl_modg_2d_kernel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Projection of the penalization terms (in modal representation) to the test
functions.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/modg_2d_project_physfluxx_p.html'>modg_2d_project_physFluxX_P</a></td>
                 <td><a href='../module/atl_project_physflux_module.html'>atl_project_physflux_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Projection of the physical flux in x direction onto the testfunctions.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/modg_2d_project_physfluxx_q.html'>modg_2d_project_physFluxX_Q</a></td>
                 <td><a href='../module/atl_project_physflux_module.html'>atl_project_physflux_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Projection of the physical flux in x direction onto the testfunctions.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/modg_2d_project_physfluxy_p.html'>modg_2d_project_physFluxY_P</a></td>
                 <td><a href='../module/atl_project_physflux_module.html'>atl_project_physflux_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Projection of the physical flux in y direction onto the testfunctions.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/modg_2d_project_physfluxy_q.html'>modg_2d_project_physFluxY_Q</a></td>
                 <td><a href='../module/atl_project_physflux_module.html'>atl_project_physflux_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Projection of the physical flux in y direction onto the testfunctions.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/modg_2d_project_source_p.html'>modg_2d_project_source_P</a></td>
                 <td><a href='../module/atl_modg_2d_kernel_module.html'>atl_modg_2d_kernel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Projection of the source terms (in modal representation) to
the test functions.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/modg_2d_project_source_q.html'>modg_2d_project_source_Q</a></td>
                 <td><a href='../module/atl_modg_2d_kernel_module.html'>atl_modg_2d_kernel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Projection of the source terms (in modal representation) to
the test functions.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/modg_2d_project_stabviscnumfluxx_q.html'>modg_2d_project_stabViscNumFluxX_Q</a></td>
                 <td><a href='../module/atl_modg_2d_kernel_module.html'>atl_modg_2d_kernel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Projection of the numerical flux in x direction onto the testfunctions.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/modg_2d_project_stabviscnumfluxy_q.html'>modg_2d_project_stabViscNumFluxY_Q</a></td>
                 <td><a href='../module/atl_modg_2d_kernel_module.html'>atl_modg_2d_kernel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Projection of the numerical flux in y direction onto the testfunctions.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/modg_2d_rans_onedim_numflux_const.html'>modg_2d_rans_oneDim_numFlux_const</a></td>
                 <td><a href='../module/atl_modg_2d_filnvrstk_kernel_module.html'>atl_modg_2d_filNvrStk_kernel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Numerical flux calculation for Rans 2D equation across the faces in a
single spatial direction (with constant penalization parameters).</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/modg_2d_rans_onedim_numflux_nonconst.html'>modg_2d_rans_oneDim_numFlux_nonconst</a></td>
                 <td><a href='../module/atl_modg_2d_filnvrstk_kernel_module.html'>atl_modg_2d_filNvrStk_kernel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Numerical flux calculation for Rans equation across the faces in a single
spatial direction (with non-constant penalization parameters).</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/modg_2d_semicoarseface.html'>modg_2d_semiCoarseFace</a></td>
                 <td><a href='../module/atl_modg_2d_multilevel_module.html'>atl_modg_2d_multilevel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Project modal representation of a semi-refined face (i.e. on a face</p><a href="../proc/modg_2d_semicoarseface.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/modg_2d_semirefineface.html'>modg_2d_semiRefineFace</a></td>
                 <td><a href='../module/atl_modg_2d_multilevel_module.html'>atl_modg_2d_multilevel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Project modal representation on a face to a semi-refined face (i.e. on a face</p><a href="../proc/modg_2d_semirefineface.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/modg_2d_stabviscnavierstokes_onedim_numflux.html'>modg_2d_stabViscNavierStokes_oneDim_numFlux</a></td>
                 <td><a href='../module/atl_modg_2d_navierstokes_kernel_module.html'>atl_modg_2d_navierstokes_kernel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Numerical flux calculation for stab-viscous part of the Navier-Stokes
equation across the faces in a single
spatial direction.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/modg_2d_stabviscrans_onedim_numflux.html'>modg_2d_stabViscRans_oneDim_numFlux</a></td>
                 <td><a href='../module/atl_modg_2d_filnvrstk_kernel_module.html'>atl_modg_2d_filNvrStk_kernel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Numerical flux calculation for stab-viscous part of the RANS equation
across the faces in a single spatial direction.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/modg_2d_viscnavierstokes_onedim_numflux.html'>modg_2d_viscNavierStokes_oneDim_numFlux</a></td>
                 <td><a href='../module/atl_modg_2d_navierstokes_kernel_module.html'>atl_modg_2d_navierstokes_kernel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Numerical flux calculation for viscous part of the Navier-Stokes equation
across the faces in a single spatial direction.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/modg_2d_viscrans_onedim_numflux.html'>modg_2d_viscRans_oneDim_numFlux</a></td>
                 <td><a href='../module/atl_modg_2d_filnvrstk_kernel_module.html'>atl_modg_2d_filNvrStk_kernel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Numerical flux calculation for viscous part of the RANS equation across the faces in a single
spatial direction.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/modg_bnd_extrapolate.html'>modg_bnd_extrapolate</a></td>
                 <td><a href='../module/atl_modg_bnd_module.html'>atl_modg_bnd_module</a></td>
                 <td>Function</td>
                 <td><p>Function to extrapolate face values for a given boundary condition in
physical or modal space.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/modg_bnd_mirrorpoint.html'>modg_bnd_mirrorPoint</a></td>
                 <td><a href='../module/atl_modg_bnd_module.html'>atl_modg_bnd_module</a></td>
                 <td>Function</td>
                 <td><p>Function to mirror pointvalues for a given boundary conditions.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/modg_compute_project_physflux.html'>modg_compute_project_physFlux</a></td>
                 <td><a href='../module/atl_compute_module.html'>atl_compute_module</a></td>
                 <td>Subroutine</td>
                 <td><p>TODO NA - Move this routine to the atl_modg_kernel_module</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/modg_invmassmatrix_p.html'>modg_invMassMatrix_P</a></td>
                 <td><a href='../module/atl_modg_kernel_module.html'>atl_modg_kernel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Applies the inverse of the mass matrix for a 3D scheme.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/modg_invmassmatrix_pre.html'>modg_invMassMatrix_pre</a></td>
                 <td><a href='../module/atl_modg_nerplanck_kernel_module.html'>atl_modg_nerplanck_kernel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Applies the inverse of the mass matrix for a 3D scheme.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/modg_invmassmatrix_q.html'>modg_invMassMatrix_Q</a></td>
                 <td><a href='../module/atl_modg_kernel_module.html'>atl_modg_kernel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Applies the inverse of the mass matrix for a 3D scheme.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/modg_modal_bnd.html'>modg_modal_bnd</a></td>
                 <td><a href='../module/atl_modg_bnd_module.html'>atl_modg_bnd_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Set boundary values in a modal way</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/modg_nerplanck_physflux_pre.html'>modg_nerplanck_physFlux_pre</a></td>
                 <td><a href='../module/atl_modg_nerplanck_kernel_module.html'>atl_modg_nerplanck_kernel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate the projection of the physical flux for the MODG scheme and
Nernst-Planck equation.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/modg_nerplanck_x_numflux_pre.html'>modg_nerplanck_x_numFlux_pre</a></td>
                 <td><a href='../module/atl_modg_nerplanck_kernel_module.html'>atl_modg_nerplanck_kernel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Numerical flux calculation for Nernst-Planck equation across the faces in X direction.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/modg_nerplanck_y_numflux_pre.html'>modg_nerplanck_y_numFlux_pre</a></td>
                 <td><a href='../module/atl_modg_nerplanck_kernel_module.html'>atl_modg_nerplanck_kernel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Numerical flux calculation for Nernst-Planck equation across the faces in Y direction.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/modg_nerplanck_z_numflux_pre.html'>modg_nerplanck_z_numFlux_pre</a></td>
                 <td><a href='../module/atl_modg_nerplanck_kernel_module.html'>atl_modg_nerplanck_kernel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Numerical flux calculation for Nernst-Planck equation across the faces in Z direction.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/modg_nodal_bnd.html'>modg_nodal_bnd</a></td>
                 <td><a href='../module/atl_modg_bnd_module.html'>atl_modg_bnd_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Set boundary values in a nodal way</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/modg_prj_pflux1_q_5.html'>modg_prj_pflux1_q_5</a></td>
                 <td><a href='../module/atl_project_physflux_module.html'>atl_project_physflux_module</a></td>
                 <td>Subroutine</td>
                 <td><p>X direction for 5 scalars
 projection of the physical flux onto the testfunctions, with unrolled loops</p><a href="../proc/modg_prj_pflux1_q_5.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/modg_prj_pflux1_q_6.html'>modg_prj_pflux1_q_6</a></td>
                 <td><a href='../module/atl_project_physflux_module.html'>atl_project_physflux_module</a></td>
                 <td>Subroutine</td>
                 <td><p>X direction for 6 scalars
 projection of the physical flux onto the testfunctions, with unrolled loops</p><a href="../proc/modg_prj_pflux1_q_6.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/modg_prj_pflux2_q_5.html'>modg_prj_pflux2_q_5</a></td>
                 <td><a href='../module/atl_project_physflux_module.html'>atl_project_physflux_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Y direction for 5 scalars
 projection of the physical flux onto the testfunctions, with unrolled loops</p><a href="../proc/modg_prj_pflux2_q_5.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/modg_prj_pflux2_q_6.html'>modg_prj_pflux2_q_6</a></td>
                 <td><a href='../module/atl_project_physflux_module.html'>atl_project_physflux_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Y direction for 6 scalars
 projection of the physical flux onto the testfunctions, with unrolled loops</p><a href="../proc/modg_prj_pflux2_q_6.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/modg_prj_pflux3_q_5.html'>modg_prj_pflux3_q_5</a></td>
                 <td><a href='../module/atl_project_physflux_module.html'>atl_project_physflux_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Z direction for 5 scalars
 projection of the physical flux onto the testfunctions, with unrolled loops</p><a href="../proc/modg_prj_pflux3_q_5.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/modg_prj_pflux3_q_6.html'>modg_prj_pflux3_q_6</a></td>
                 <td><a href='../module/atl_project_physflux_module.html'>atl_project_physflux_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Z direction for 6 scalars
 projection of the physical flux onto the testfunctions, with unrolled loops</p><a href="../proc/modg_prj_pflux3_q_6.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/modg_project_numflux_difftest_q.html'>modg_project_numFlux_diffTest_Q</a></td>
                 <td><a href='../module/atl_modg_kernel_module.html'>atl_modg_kernel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Projection of the numerical flux onto the differentiated testfunctions.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/modg_project_numflux_p.html'>modg_project_numFlux_P</a></td>
                 <td><a href='../module/atl_modg_kernel_module.html'>atl_modg_kernel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Projection of the numerical flux onto the testfunctions for P_space.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/modg_project_numflux_q.html'>modg_project_numFlux_Q</a></td>
                 <td><a href='../module/atl_modg_kernel_module.html'>atl_modg_kernel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Projection of the numerical flux onto the testfunctions for Q_space.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/modg_project_penalization_q.html'>modg_project_penalization_Q</a></td>
                 <td><a href='../module/atl_modg_kernel_module.html'>atl_modg_kernel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Projection of the penalization terms (in modal representation) to the
test functions.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/modg_project_physflux_p.html'>modg_project_physFlux_P</a></td>
                 <td><a href='../module/atl_project_physflux_module.html'>atl_project_physflux_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Projection of the physical flux onto the testfunctions, with unrolled loops
=&gt; fewer loop-overhead/instructions, but more "random" memory accesses
MZ: perhaps this version is faster for low order (or always, depending on the machine?)</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/modg_project_physflux_q.html'>modg_project_physFlux_Q</a></td>
                 <td><a href='../module/atl_project_physflux_module.html'>atl_project_physflux_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Projection of the physical flux onto the testfunctions, with unrolled loops</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/modg_project_stabviscnumfluxx_q.html'>modg_project_stabViscNumFluxX_Q</a></td>
                 <td><a href='../module/atl_modg_kernel_module.html'>atl_modg_kernel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Projection of the numerical flux in x direction onto the testfunctions.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/modg_project_stabviscnumfluxy_q.html'>modg_project_stabViscNumFluxY_Q</a></td>
                 <td><a href='../module/atl_modg_kernel_module.html'>atl_modg_kernel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Projection of the numerical flux in y direction onto the testfunctions.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/modg_project_stabviscnumfluxz_q.html'>modg_project_stabViscNumFluxZ_Q</a></td>
                 <td><a href='../module/atl_modg_kernel_module.html'>atl_modg_kernel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Projection of the numerical flux in y direction onto the testfunctions.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/modg_semicoarseelem.html'>modg_semiCoarseElem</a></td>
                 <td><a href='../module/atl_modg_multilevel_module.html'>atl_modg_multilevel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Subroutine to semi-coarsen an element with modal polynomial representation
to its semi-parent.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/modg_semicoarseelem_1d.html'>modg_semiCoarseElem_1d</a></td>
                 <td><a href='../module/atl_modg_1d_multilevel_module.html'>atl_modg_1d_multilevel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Subroutine to semi-coarsen an element with modal polynomial representation
to its semi-parent.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/modg_semicoarseelem_2d.html'>modg_semiCoarseElem_2d</a></td>
                 <td><a href='../module/atl_modg_2d_multilevel_module.html'>atl_modg_2d_multilevel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Subroutine to semi-coarsen an element with modal polynomial representation
to its semi-parent.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/modg_semicoarseface.html'>modg_semiCoarseFace</a></td>
                 <td><a href='../module/atl_modg_multilevel_module.html'>atl_modg_multilevel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Project modal representation of a semi-refined face (i.e. on a face</p><a href="../proc/modg_semicoarseface.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/modg_semirefineelem.html'>modg_semiRefineElem</a></td>
                 <td><a href='../module/atl_modg_multilevel_module.html'>atl_modg_multilevel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Subroutine to semi-refine an element with modal polynomial representation
into its semi-children.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/modg_semirefineelem_1d.html'>modg_semiRefineElem_1d</a></td>
                 <td><a href='../module/atl_modg_1d_multilevel_module.html'>atl_modg_1d_multilevel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Subroutine to semi-refine an element with modal polynomial representation
into its semi-children.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/modg_semirefineelem_2d.html'>modg_semiRefineElem_2d</a></td>
                 <td><a href='../module/atl_modg_2d_multilevel_module.html'>atl_modg_2d_multilevel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Subroutine to semi-refine an element with modal polynomial representation
into its semi-children.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/modg_semirefineface.html'>modg_semiRefineFace</a></td>
                 <td><a href='../module/atl_modg_multilevel_module.html'>atl_modg_multilevel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Project modal representation on a face to a semi-refined face (i.e. on a face</p><a href="../proc/modg_semirefineface.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/modg_voltoface_q_x.html'>modg_volToFace_Q_x</a></td>
                 <td><a href='../module/atl_modg_kernel_module.html'>atl_modg_kernel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Project modal representation of an element to its two faces in X.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/modg_voltoface_q_y.html'>modg_volToFace_Q_y</a></td>
                 <td><a href='../module/atl_modg_kernel_module.html'>atl_modg_kernel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Project modal representation of an element to its two faces in Y.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/modg_voltoface_q_z.html'>modg_volToFace_Q_z</a></td>
                 <td><a href='../module/atl_modg_kernel_module.html'>atl_modg_kernel_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Project modal representation of an element to its two faces in Y.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/nerplanck_numflux_concentration.html'>nerplanck_numflux_concentration</a></td>
                 <td><a href='../module/atl_nerplanck_flux_module.html'>atl_nerplanck_flux_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Subroutine to calculate the numerical flux for the first equation (u)</p><a href="../proc/nerplanck_numflux_concentration.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/nerplanck_numflux_diffusiveflux.html'>nerplanck_numflux_diffusiveFlux</a></td>
                 <td><a href='../module/atl_nerplanck_flux_module.html'>atl_nerplanck_flux_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Subroutine to calculate the flux for Nernst-Planck equations.</p><a href="../proc/nerplanck_numflux_diffusiveflux.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/nerplanck_physflux_concentration.html'>nerplanck_physflux_concentration</a></td>
                 <td><a href='../module/atl_nerplanck_flux_module.html'>atl_nerplanck_flux_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Subroutine to calculate the numerical flux for the first equation (u)</p><a href="../proc/nerplanck_physflux_concentration.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/nerplanck_physflux_diffusiveflux.html'>nerplanck_physflux_diffusiveFlux</a></td>
                 <td><a href='../module/atl_nerplanck_flux_module.html'>atl_nerplanck_flux_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Subroutine to calculate the flux for Nernst-Planck equations.</p><a href="../proc/nerplanck_physflux_diffusiveflux.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/nr_1side.html'>nr_1side</a></td>
                 <td><a href='../module/atl_exact_riemann_euler_module.html'>atl_exact_riemann_euler_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Compute one-sided iteration</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/nr_start.html'>nr_start</a></td>
                 <td><a href='../module/atl_exact_riemann_euler_module.html'>atl_exact_riemann_euler_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Initial setup for the iterative computation of the solution to the
Riemann problem.</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/operator(SLASH=).html'>operator(/=)</a></td>
                 <td><a href='../module/ply_prj_header_module.html'>ply_prj_header_module</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../interface/operator(SLASH=)~2.html'>operator(/=)</a></td>
                 <td><a href='../module/ply_fxt_header_module.html'>ply_fxt_header_module</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../interface/operator(SLASH=)~3.html'>operator(/=)</a></td>
                 <td><a href='../module/ply_l2p_header_module.html'>ply_l2p_header_module</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../interface/operator(SLASH=)~4.html'>operator(/=)</a></td>
                 <td><a href='../module/ply_dynarray_project_module.html'>ply_dynarray_project_module</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../interface/operator(SLASH=)~5.html'>operator(/=)</a></td>
                 <td><a href='../module/ply_fpt_header_module.html'>ply_fpt_header_module</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../interface/operator(SLASH=)~6.html'>operator(/=)</a></td>
                 <td><a href='../module/ply_nodes_header_module.html'>ply_nodes_header_module</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../interface/operator(lt).html'>operator(<)</a></td>
                 <td><a href='../module/ply_prj_header_module.html'>ply_prj_header_module</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../interface/operator(lt)~2.html'>operator(<)</a></td>
                 <td><a href='../module/ply_fxt_header_module.html'>ply_fxt_header_module</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../interface/operator(lt)~3.html'>operator(<)</a></td>
                 <td><a href='../module/ply_l2p_header_module.html'>ply_l2p_header_module</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../interface/operator(lt)~4.html'>operator(<)</a></td>
                 <td><a href='../module/ply_dynarray_project_module.html'>ply_dynarray_project_module</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../interface/operator(lt)~5.html'>operator(<)</a></td>
                 <td><a href='../module/ply_fpt_header_module.html'>ply_fpt_header_module</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../interface/operator(lt)~6.html'>operator(<)</a></td>
                 <td><a href='../module/ply_nodes_header_module.html'>ply_nodes_header_module</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../interface/operator(lt=).html'>operator(<=)</a></td>
                 <td><a href='../module/ply_prj_header_module.html'>ply_prj_header_module</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../interface/operator(lt=)~2.html'>operator(<=)</a></td>
                 <td><a href='../module/ply_fxt_header_module.html'>ply_fxt_header_module</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../interface/operator(lt=)~3.html'>operator(<=)</a></td>
                 <td><a href='../module/ply_l2p_header_module.html'>ply_l2p_header_module</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../interface/operator(lt=)~4.html'>operator(<=)</a></td>
                 <td><a href='../module/ply_dynarray_project_module.html'>ply_dynarray_project_module</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../interface/operator(lt=)~5.html'>operator(<=)</a></td>
                 <td><a href='../module/ply_fpt_header_module.html'>ply_fpt_header_module</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../interface/operator(lt=)~6.html'>operator(<=)</a></td>
                 <td><a href='../module/ply_nodes_header_module.html'>ply_nodes_header_module</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../interface/operator(==).html'>operator(==)</a></td>
                 <td><a href='../module/ply_prj_header_module.html'>ply_prj_header_module</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../interface/operator(==)~2.html'>operator(==)</a></td>
                 <td><a href='../module/ply_fxt_header_module.html'>ply_fxt_header_module</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../interface/operator(==)~3.html'>operator(==)</a></td>
                 <td><a href='../module/ply_l2p_header_module.html'>ply_l2p_header_module</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../interface/operator(==)~4.html'>operator(==)</a></td>
                 <td><a href='../module/ply_dynarray_project_module.html'>ply_dynarray_project_module</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../interface/operator(==)~5.html'>operator(==)</a></td>
                 <td><a href='../module/ply_fpt_header_module.html'>ply_fpt_header_module</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../interface/operator(==)~6.html'>operator(==)</a></td>
                 <td><a href='../module/ply_nodes_header_module.html'>ply_nodes_header_module</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../interface/operator(gt).html'>operator(>)</a></td>
                 <td><a href='../module/ply_prj_header_module.html'>ply_prj_header_module</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../interface/operator(gt)~2.html'>operator(>)</a></td>
                 <td><a href='../module/ply_fxt_header_module.html'>ply_fxt_header_module</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../interface/operator(gt)~3.html'>operator(>)</a></td>
                 <td><a href='../module/ply_l2p_header_module.html'>ply_l2p_header_module</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../interface/operator(gt)~4.html'>operator(>)</a></td>
                 <td><a href='../module/ply_dynarray_project_module.html'>ply_dynarray_project_module</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../interface/operator(gt)~5.html'>operator(>)</a></td>
                 <td><a href='../module/ply_fpt_header_module.html'>ply_fpt_header_module</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../interface/operator(gt)~6.html'>operator(>)</a></td>
                 <td><a href='../module/ply_nodes_header_module.html'>ply_nodes_header_module</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../interface/operator(gt=).html'>operator(>=)</a></td>
                 <td><a href='../module/ply_prj_header_module.html'>ply_prj_header_module</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../interface/operator(gt=)~2.html'>operator(>=)</a></td>
                 <td><a href='../module/ply_fxt_header_module.html'>ply_fxt_header_module</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../interface/operator(gt=)~3.html'>operator(>=)</a></td>
                 <td><a href='../module/ply_l2p_header_module.html'>ply_l2p_header_module</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../interface/operator(gt=)~4.html'>operator(>=)</a></td>
                 <td><a href='../module/ply_dynarray_project_module.html'>ply_dynarray_project_module</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../interface/operator(gt=)~5.html'>operator(>=)</a></td>
                 <td><a href='../module/ply_fpt_header_module.html'>ply_fpt_header_module</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../interface/operator(gt=)~6.html'>operator(>=)</a></td>
                 <td><a href='../module/ply_nodes_header_module.html'>ply_nodes_header_module</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/outputappendresult.html'>outputAppendResult</a></td>
                 <td><a href='../module/atl_eqn_euler_2d_var_module.html'>atl_eqn_euler_2d_var_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Outputs the result of appending a variable. If appending was not
successful, the program is aborted.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_alpha.html'>ply_alpha</a></td>
                 <td><a href='../module/ply_poly_transformation_module.html'>ply_poly_transformation_module</a></td>
                 <td>Function</td>
                 <td><p>Coefficients from the recursive formulation of legendre polynomials.
L_n = alpha * x * L_n-1 + beta * L_n-2</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_alpha_beta.html'>ply_alpha_beta</a></td>
                 <td><a href='../module/ply_poly_transformation_module.html'>ply_poly_transformation_module</a></td>
                 <td>Function</td>
                 <td><p>Prodcut of alpha(numerator) * beta(denominator) / alpha(denominator)</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_alpha_frac.html'>ply_alpha_frac</a></td>
                 <td><a href='../module/ply_poly_transformation_module.html'>ply_poly_transformation_module</a></td>
                 <td>Function</td>
                 <td><p>Quotient of two alpha values.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_beta.html'>ply_beta</a></td>
                 <td><a href='../module/ply_poly_transformation_module.html'>ply_poly_transformation_module</a></td>
                 <td>Function</td>
                 <td><p>Coefficients from the recursive formulation of legendre polynomials.
L_n = alpha * x * L_n-1 + beta * L_n-2</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_calcdiff_leg.html'>ply_calcDiff_leg</a></td>
                 <td><a href='../module/ply_leg_diff_module.html'>ply_leg_diff_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_calcdiff_leg_1d.html'>ply_calcDiff_leg_1d</a></td>
                 <td><a href='../module/ply_leg_diff_module.html'>ply_leg_diff_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_calcdiff_leg_2d.html'>ply_calcDiff_leg_2d</a></td>
                 <td><a href='../module/ply_leg_diff_module.html'>ply_leg_diff_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_calcdiff_leg_2d_normal.html'>ply_calcDiff_leg_2d_normal</a></td>
                 <td><a href='../module/ply_leg_diff_module.html'>ply_leg_diff_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_calcdiff_leg_normal.html'>ply_calcDiff_leg_normal</a></td>
                 <td><a href='../module/ply_leg_diff_module.html'>ply_leg_diff_module</a></td>
                 <td>Subroutine</td>
                 <td><p>do IDeg1 = 1, mPd+1
 do IDeg2 = 1, mPd=1   !! iDeg2 = mod(iDeg-1,mpd+1)+1
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!</p><a href="../proc/ply_calcdiff_leg_normal.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_calcdiff_leg_x_vec.html'>ply_calcDiff_leg_x_vec</a></td>
                 <td><a href='../module/ply_leg_diff_module.html'>ply_leg_diff_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Compute the derivative in X direction for 3D Legendre polynomial.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_calcdiff_leg_y_vec.html'>ply_calcDiff_leg_y_vec</a></td>
                 <td><a href='../module/ply_leg_diff_module.html'>ply_leg_diff_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Compute the derivative in Y direction for 3D Legendre polynomial.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_calcdiff_leg_z_vec.html'>ply_calcDiff_leg_z_vec</a></td>
                 <td><a href='../module/ply_leg_diff_module.html'>ply_leg_diff_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Compute the derivative in Y direction for 3D Legendre polynomial.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_calculate_coeff_strip.html'>ply_calculate_coeff_strip</a></td>
                 <td><a href='../module/ply_polybaseexc_module.html'>ply_polyBaseExc_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_change_poly_space.html'>ply_change_poly_space</a></td>
                 <td><a href='../module/ply_dof_module.html'>ply_dof_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Subroutine to change the polynomial space (Q or P) of an
atl_statedata_type from Q-space to P-space and vice versa.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_check_legtopnt.html'>ply_check_legToPnt</a></td>
                 <td><a href='../program/ply_fpt_lobattonodes_test.html'>ply_fpt_lobattoNodes_test</a></td>
                 <td>Subroutine</td>
                 <td><p>do iPoint = 1, maxPolyDegree+1
  write(<em>,</em>) 'Point: ', chebPnt(iPoint), &amp;
           &amp; ' FPT: ', pntVal(iPoint), &amp;
           &amp; ' Ref.: ', refVal(iPoint), &amp;
           &amp; ' error: ', pntVal(iPoint)-refVal(iPoint)
end do</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_check_legtopnt~2.html'>ply_check_legToPnt</a></td>
                 <td><a href='../program/ply_fpt_test.html'>ply_fpt_test</a></td>
                 <td>Subroutine</td>
                 <td><p>do iPoint = 1, maxPolyDegree+1
  write(<em>,</em>) 'Point: ', chebPnt(iPoint), &amp;
           &amp; ' FPT: ', pntVal(iPoint), &amp;
           &amp; ' Ref.: ', refVal(iPoint), &amp;
           &amp; ' error: ', pntVal(iPoint)-refVal(iPoint)
end do</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_check_legtopnt_2d.html'>ply_check_legToPnt_2D</a></td>
                 <td><a href='../program/ply_fpt_ifpt_2d_singvar_lobattonodes_test.html'>ply_fpt_ifpt_2D_singVar_lobattoNodes_test</a></td>
                 <td>Subroutine</td>
                 <td><p>do iDof = 1, (maxPolyDegree+1)<em><em>2
  write(</em>,</em>) 'Leg coeff ', iDof, ' has error: ', legVal(iDof) - legCoeffs(iDof)
end do</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_check_legtopnt_2d~2.html'>ply_check_legToPnt_2D</a></td>
                 <td><a href='../program/ply_fpt_ifpt_2d_multivar_test.html'>ply_fpt_ifpt_2D_multiVar_test</a></td>
                 <td>Subroutine</td>
                 <td><p>do iDof = 1, (maxPolyDegree+1)<em><em>2
  write(</em>,</em>) 'Leg coeff ', iDof, ' has error: ', legVal(iDof) - legCoeffs(iDof)
end do</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_check_legtopnt_2d~3.html'>ply_check_legToPnt_2D</a></td>
                 <td><a href='../program/ply_fpt_ifpt_2d_singvar_test.html'>ply_fpt_ifpt_2D_singVar_test</a></td>
                 <td>Subroutine</td>
                 <td><p>do iDof = 1, (maxPolyDegree+1)<em><em>2
  write(</em>,</em>) 'Leg coeff ', iDof, ' has error: ', legVal(iDof) - legCoeffs(iDof)
end do</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_check_legtopnt_2d~4.html'>ply_check_legToPnt_2D</a></td>
                 <td><a href='../program/ply_fpt_ifpt_2d_multivar_lobattonodes_test.html'>ply_fpt_ifpt_2D_multiVar_lobattoNodes_test</a></td>
                 <td>Subroutine</td>
                 <td><p>do iDof = 1, (maxPolyDegree+1)<em><em>2
  write(</em>,</em>) 'Leg coeff ', iDof, ' has error: ', legVal(iDof) - legCoeffs(iDof)
end do</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_check_legtopnt_3d.html'>ply_check_legToPnt_3D</a></td>
                 <td><a href='../program/ply_fpt_ifpt_3d_multivar_test.html'>ply_fpt_ifpt_3D_multiVar_test</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_check_legtopnt_3d~2.html'>ply_check_legToPnt_3D</a></td>
                 <td><a href='../program/ply_fpt_ifpt_3d_singvar_lobattonodes_test.html'>ply_fpt_ifpt_3D_singVar_lobattoNodes_test</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_check_legtopnt_3d~3.html'>ply_check_legToPnt_3D</a></td>
                 <td><a href='../program/ply_fpt_ifpt_3d_singvar_test.html'>ply_fpt_ifpt_3D_singVar_test</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_check_legtopnt_3d~4.html'>ply_check_legToPnt_3D</a></td>
                 <td><a href='../program/ply_fpt_ifpt_3d_multivar_lobattonodes_test.html'>ply_fpt_ifpt_3D_multiVar_lobattoNodes_test</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_check_pnttoleg.html'>ply_check_pntToLeg</a></td>
                 <td><a href='../program/ply_ifpt_lobattonodes_test.html'>ply_ifpt_lobattoNodes_test</a></td>
                 <td>Subroutine</td>
                 <td><p>do iPoly = 1, maxPolyDegree+1
  write(<em>,</em>) 'Poly degree: ', iPoly, &amp;
           &amp; ' iFPT: ', legVal(iPoly), &amp;
           &amp; ' Ref.: ', legCoeffs(iPoly), &amp;
           &amp; ' error: ', legVal(iPoly)-legCoeffs(iPoly)
end do</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_check_pnttoleg~2.html'>ply_check_pntToLeg</a></td>
                 <td><a href='../program/ply_ifpt_test.html'>ply_ifpt_test</a></td>
                 <td>Subroutine</td>
                 <td><p>do iPoly = 1, maxPolyDegree+1
  write(<em>,</em>) 'Poly degree: ', iPoly, &amp;
           &amp; ' iFPT: ', legVal(iPoly), &amp;
           &amp; ' Ref.: ', legCoeffs(iPoly), &amp;
           &amp; ' error: ', legVal(iPoly)-legCoeffs(iPoly)
end do</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_convert2oversample.html'>ply_convert2oversample</a></td>
                 <td><a href='../module/ply_oversample_module.html'>ply_oversample_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Copy a single element state into a larger array and pad it with zeroes.</p><a href="../proc/ply_convert2oversample.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_convert2oversample_1d.html'>ply_convert2oversample_1d</a></td>
                 <td><a href='../module/ply_oversample_module.html'>ply_oversample_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Copy a single 1D element state into a larger array and pad it with zeroes.</p><a href="../proc/ply_convert2oversample_1d.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_convert2oversample_2d.html'>ply_convert2oversample_2d</a></td>
                 <td><a href='../module/ply_oversample_module.html'>ply_oversample_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Copy a single 2D element state into a larger array and pad it with zeroes.</p><a href="../proc/ply_convert2oversample_2d.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_convert2oversample_3d.html'>ply_convert2oversample_3d</a></td>
                 <td><a href='../module/ply_oversample_module.html'>ply_oversample_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Copy a single element state into a larger array and pad it with zeroes.</p><a href="../proc/ply_convert2oversample_3d.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_convertfromoversample.html'>ply_convertFromOversample</a></td>
                 <td><a href='../module/ply_oversample_module.html'>ply_oversample_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Truncating an oversampled polynomial representation back to the original
representation.</p><a href="../proc/ply_convertfromoversample.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_convertfromoversample_1d.html'>ply_convertFromOversample_1d</a></td>
                 <td><a href='../module/ply_oversample_module.html'>ply_oversample_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Truncating an oversampled 1D polynomial representation back to the original
representation.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_convertfromoversample_2d.html'>ply_convertFromOversample_2d</a></td>
                 <td><a href='../module/ply_oversample_module.html'>ply_oversample_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Truncating an oversampled 2D polynomial representation back to the original
representation.</p><a href="../proc/ply_convertfromoversample_2d.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_convertfromoversample_3d.html'>ply_convertFromOversample_3d</a></td>
                 <td><a href='../module/ply_oversample_module.html'>ply_oversample_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Truncating an oversampled polynomial representation back to the original
representation.</p><a href="../proc/ply_convertfromoversample_3d.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_degree_2dof.html'>ply_degree_2dof</a></td>
                 <td><a href='../module/ply_dof_module.html'>ply_dof_module</a></td>
                 <td>Function</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_dof_2degree.html'>ply_dof_2degree</a></td>
                 <td><a href='../module/ply_dof_module.html'>ply_dof_module</a></td>
                 <td>Function</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_doftoqpoly.html'>ply_dofToQPoly</a></td>
                 <td><a href='../module/ply_legpolyprojection_module.html'>ply_LegPolyProjection_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Subroutine to convert linearized dof index to ansatz function number for
Q-Polynomials.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_evallegendretenspoly.html'>ply_evalLegendreTensPoly</a></td>
                 <td><a href='../module/ply_modg_basis_module.html'>ply_modg_basis_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Evaluate three-dimensional tensor product Legendre polynomials
(not-normalized) at a given set of coordinates.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_facevalleftbndans.html'>ply_faceValLeftBndAns</a></td>
                 <td><a href='../module/ply_modg_basis_module.html'>ply_modg_basis_module</a></td>
                 <td>Function</td>
                 <td><p>Returns the value of the non-normalized Legendre polynomial at the left
boundary of the reference element, i.e. at -1.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_facevalleftbndans_vec.html'>ply_faceValLeftBndAns_vec</a></td>
                 <td><a href='../module/ply_modg_basis_module.html'>ply_modg_basis_module</a></td>
                 <td>Function</td>
                 <td><p>Returns the value of the non-normalized Legendre polynomial at the left
boundary of the reference element, i.e. at -1.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_facevalleftbnddiffans.html'>ply_faceValLeftBndDiffAns</a></td>
                 <td><a href='../module/ply_modg_basis_module.html'>ply_modg_basis_module</a></td>
                 <td>Function</td>
                 <td><p>Returns the value of the non-normalized differentiated Legendre polynomial
at the leftboundary of the reference element, i.e. at -1.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_facevalleftbndgradtest.html'>ply_faceValLeftBndgradTest</a></td>
                 <td><a href='../module/ply_modg_basis_module.html'>ply_modg_basis_module</a></td>
                 <td>Function</td>
                 <td><p>Returns the value of the gradient of the dual Legendre polynomial at the
left boundary of the reference element, i.e. at -1.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_facevalleftbndgradtest_vec.html'>ply_faceValLeftBndgradTest_vec</a></td>
                 <td><a href='../module/ply_modg_basis_module.html'>ply_modg_basis_module</a></td>
                 <td>Function</td>
                 <td><p>Returns the value of the gradient of the dual Legendre polynomial at the
left boundary of the reference element, i.e. at -1.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_facevalleftbndtest.html'>ply_faceValLeftBndTest</a></td>
                 <td><a href='../module/ply_modg_basis_module.html'>ply_modg_basis_module</a></td>
                 <td>Function</td>
                 <td><p>Returns the value of the dual Legendre polynomial at the left
boundary of the reference element, i.e. at -1.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_facevalleftbndtest_vec.html'>ply_faceValLeftBndTest_vec</a></td>
                 <td><a href='../module/ply_modg_basis_module.html'>ply_modg_basis_module</a></td>
                 <td>Function</td>
                 <td><p>Returns the value of the dual Legendre polynomial at the left
boundary of the reference element, i.e. at -1.Vectorized version.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_facevalleftbndtestgrad.html'>ply_faceValLeftBndTestGrad</a></td>
                 <td><a href='../module/ply_modg_basis_module.html'>ply_modg_basis_module</a></td>
                 <td>Function</td>
                 <td><p>Returns the value of the derivaitve of the dual Legendre polynomial at the
left boundary of the reference element, i.e. at -1.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_facevalleftbndtestgrad_vec.html'>ply_faceValLeftBndTestGrad_vec</a></td>
                 <td><a href='../module/ply_modg_basis_module.html'>ply_modg_basis_module</a></td>
                 <td>Function</td>
                 <td><p>Returns the value of the derivaitve of the dual Legendre polynomial at the
left boundary of the reference element, i.e. at -1.Vectorized version.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_facevalrightbnddiffans.html'>ply_faceValRightBndDiffAns</a></td>
                 <td><a href='../module/ply_modg_basis_module.html'>ply_modg_basis_module</a></td>
                 <td>Function</td>
                 <td><p>Returns the value of the non-normalized differentiated Legendre polynomial
at the right boundary of the reference element, i.e. at +1.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_facevalrightbndgradtest.html'>ply_faceValRightBndgradTest</a></td>
                 <td><a href='../module/ply_modg_basis_module.html'>ply_modg_basis_module</a></td>
                 <td>Function</td>
                 <td><p>Returns the value of the gradient of dual Legendre polynomial at the right
boundary of the reference element, i.e. at +1.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_facevalrightbndgradtest_vec.html'>ply_faceValRightBndgradTest_vec</a></td>
                 <td><a href='../module/ply_modg_basis_module.html'>ply_modg_basis_module</a></td>
                 <td>Function</td>
                 <td><p>Returns the value of the gradient of dual Legendre polynomial at the right
boundary of the reference element, i.e. at +1. Vectorized version.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_facevalrightbndtest.html'>ply_faceValRightBndTest</a></td>
                 <td><a href='../module/ply_modg_basis_module.html'>ply_modg_basis_module</a></td>
                 <td>Function</td>
                 <td><p>Returns the value of the dual Legendre polynomial at the right
boundary of the reference element, i.e. at +1.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_facevalrightbndtest_vec.html'>ply_faceValRightBndTest_vec</a></td>
                 <td><a href='../module/ply_modg_basis_module.html'>ply_modg_basis_module</a></td>
                 <td>Function</td>
                 <td><p>Returns the value of the dual Legendre polynomial at the right
boundary of the reference element, i.e. at +1. Vectorized Version.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_facevalrightbndtestgrad.html'>ply_faceValRightBndTestGrad</a></td>
                 <td><a href='../module/ply_modg_basis_module.html'>ply_modg_basis_module</a></td>
                 <td>Function</td>
                 <td><p>Returns the value of the derivaitve of the dual Legendre polynomial at the right
boundary of the reference element, i.e. at +1.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_facevalrightbndtestgrad_vec.html'>ply_faceValRightBndTestGrad_vec</a></td>
                 <td><a href='../module/ply_modg_basis_module.html'>ply_modg_basis_module</a></td>
                 <td>Function</td>
                 <td><p>Returns the value of the derivaitve of the dual Legendre polynomial at the right
boundary of the reference element, i.e. at +1.vectoized version.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_fill_dynprojectarray.html'>ply_fill_dynProjectArray</a></td>
                 <td><a href='../module/ply_dynarray_project_module.html'>ply_dynarray_project_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Load settings to describe a projection method from a Lua table.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_fill_project_list.html'>ply_fill_project_list</a></td>
                 <td><a href='../module/ply_poly_project_module.html'>ply_poly_project_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Fill ups the bodys accroding to the DA.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_filter_element_load.html'>ply_filter_element_load</a></td>
                 <td><a href='../module/ply_filter_element_module.html'>ply_filter_element_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Loading parameters for the filtering from the configuration script.
This needs to be performed before any call of the actual transformation
<a href="../proc/ply_split_element_1d.html">ply_split_element_1D</a>.</p><a href="../proc/ply_filter_element_load.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_filter_element_oddfract.html'>ply_filter_element_oddfract</a></td>
                 <td><a href='../module/ply_filter_element_module.html'>ply_filter_element_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Filter a polynomial representation in elements in one dimension according
to its odd mode fraction.</p><a href="../proc/ply_filter_element_oddfract.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_filter_oddfract_1d.html'>ply_filter_oddfract_1D</a></td>
                 <td><a href='../module/ply_filter_element_module.html'>ply_filter_element_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Filter one-dimensional elements of degree element_degree.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_filter_oddfract_2d.html'>ply_filter_oddfract_2D</a></td>
                 <td><a href='../module/ply_filter_element_module.html'>ply_filter_element_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Filter two-dimensional elements of degree element_degree.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_filter_oddfract_3d.html'>ply_filter_oddfract_3D</a></td>
                 <td><a href='../module/ply_filter_element_module.html'>ply_filter_element_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Filter three-dimensional elements of degree element_degree.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_fpt_exec.html'>ply_fpt_exec</a></td>
                 <td><a href='../module/ply_polybaseexc_module.html'>ply_polyBaseExc_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Convert strip of coefficients of a modal representation in terms of
Legendre polynomials to modal coefficients in terms of Chebyshev
polynomials.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_fpt_exec_striped.html'>ply_fpt_exec_striped</a></td>
                 <td><a href='../module/ply_polybaseexc_module.html'>ply_polyBaseExc_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Convert coefficients of a modal representation in terms of Legendre
polynomials to modal coefficients in terms of Chebyshev polynomials.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_fpt_header_define.html'>ply_fpt_header_define</a></td>
                 <td><a href='../module/ply_fpt_header_module.html'>ply_fpt_header_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Define settings for the Fast Polynomial Transformation.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_fpt_header_display.html'>ply_fpt_header_display</a></td>
                 <td><a href='../module/ply_fpt_header_module.html'>ply_fpt_header_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Print the FPT settings to the log output.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_fpt_header_load.html'>ply_fpt_header_load</a></td>
                 <td><a href='../module/ply_fpt_header_module.html'>ply_fpt_header_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Read the FPT configuration options from the provided Lua script in
<code>conf</code>.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_fpt_header_out.html'>ply_fpt_header_out</a></td>
                 <td><a href='../module/ply_fpt_header_module.html'>ply_fpt_header_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Write FPT settings into a Lua table.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_fpt_init.html'>ply_fpt_init</a></td>
                 <td><a href='../module/ply_polybaseexc_module.html'>ply_polyBaseExc_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_fpt_single.html'>ply_fpt_single</a></td>
                 <td><a href='../module/ply_polybaseexc_module.html'>ply_polyBaseExc_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Convert strip of coefficients of a modal representation in terms of
Legendre polynomials to modal coefficients in terms of Chebyshev
polynomials.</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/ply_fptm2n.html'>ply_fptm2n</a></td>
                 <td><a href='../module/ply_legfpt_module.html'>ply_legFpt_module</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../interface/ply_fptn2m.html'>ply_fptn2m</a></td>
                 <td><a href='../module/ply_legfpt_module.html'>ply_legFpt_module</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_fxt_header_display.html'>ply_fxt_header_display</a></td>
                 <td><a href='../module/ply_fxt_header_module.html'>ply_fxt_header_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_fxt_header_load.html'>ply_fxt_header_load</a></td>
                 <td><a href='../module/ply_fxt_header_module.html'>ply_fxt_header_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Load settings to describe a projection method from a Lua table.</p><a href="../proc/ply_fxt_header_load.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_fxt_header_out.html'>ply_fxt_header_out</a></td>
                 <td><a href='../module/ply_fxt_header_module.html'>ply_fxt_header_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Write FXT settings into a Lua table.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_fxt_m2n_1d.html'>ply_fxt_m2n_1D</a></td>
                 <td><a href='../module/ply_fxt_module.html'>ply_fxt_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Convert modal data to nodal data in 1D using flpt.</p><a href="../proc/ply_fxt_m2n_1d.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_fxt_m2n_2d.html'>ply_fxt_m2n_2D</a></td>
                 <td><a href='../module/ply_fxt_module.html'>ply_fxt_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Convert modal data to nodal data in 2D using flpt.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_fxt_m2n_3d.html'>ply_fxt_m2n_3D</a></td>
                 <td><a href='../module/ply_fxt_module.html'>ply_fxt_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Convert modal data to nodal data in 3D using flpt.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_fxt_n2m_1d.html'>ply_fxt_n2m_1D</a></td>
                 <td><a href='../module/ply_fxt_module.html'>ply_fxt_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Convert nodal data to modal data using flpt.</p><a href="../proc/ply_fxt_n2m_1d.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_fxt_n2m_2d.html'>ply_fxt_n2m_2D</a></td>
                 <td><a href='../module/ply_fxt_module.html'>ply_fxt_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_fxt_n2m_3d.html'>ply_fxt_n2m_3D</a></td>
                 <td><a href='../module/ply_fxt_module.html'>ply_fxt_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_gauleg.html'>ply_gauleg</a></td>
                 <td><a href='../module/ply_legpolyprojection_module.html'>ply_LegPolyProjection_module</a></td>
                 <td>Subroutine</td>
                 <td><p>subroutine to create gauss points and weights for one-dimensional
integration on the interval [x1,x2].</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_gausslegpoints.html'>ply_gaussLegPoints</a></td>
                 <td><a href='../module/ply_space_integration_module.html'>ply_space_integration_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Create Gauss-Legendre integration points and weights for one-dimensional
integration on the interval [x1,x2].</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_get_quadpoints_faces.html'>ply_get_quadpoints_faces</a></td>
                 <td><a href='../module/ply_poly_project_module.html'>ply_poly_project_module</a></td>
                 <td>Subroutine</td>
                 <td><p>function to provide the coordinates from the quadrature points on the faces</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_get_quadpoints_faces_1d.html'>ply_get_quadpoints_faces_1d</a></td>
                 <td><a href='../module/ply_poly_project_module.html'>ply_poly_project_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_get_quadpoints_faces_2d.html'>ply_get_quadpoints_faces_2d</a></td>
                 <td><a href='../module/ply_poly_project_module.html'>ply_poly_project_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_init_fxt.html'>ply_init_fxt</a></td>
                 <td><a href='../module/ply_fxt_module.html'>ply_fxt_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Initialize the flpt data structure for fast legendre polynomial
transformation via the fxtpack.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_init_l2p.html'>ply_init_l2p</a></td>
                 <td><a href='../module/ply_l2p_module.html'>ply_l2p_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Initialize the transformations via L2 projections.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_init_legfpt.html'>ply_init_legFpt</a></td>
                 <td><a href='../module/ply_legfpt_module.html'>ply_legFpt_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Subroutine to initialize the fast polynomial transformation
 for Legendre expansion.</p><a href="../proc/ply_init_legfpt.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_init_modg_covolumecoeffs.html'>ply_init_modg_covolumeCoeffs</a></td>
                 <td><a href='../module/ply_modg_basis_module.html'>ply_modg_basis_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Integral of combination of all anzatz functions for
projection onto finer element</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_init_modg_multilevelcoeffs.html'>ply_init_modg_multilevelCoeffs</a></td>
                 <td><a href='../module/ply_modg_basis_module.html'>ply_modg_basis_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Integral of combination of all anzatz functions for
projection onto finer element</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_initqlegprojcoeff.html'>ply_initQLegProjCoeff</a></td>
                 <td><a href='../module/ply_legpolyprojection_module.html'>ply_LegPolyProjection_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Routine to initialize the projection coefficients for a usage in the
subsampling routine to project degrees of freedoms of a parent cell
to the degrees of freedoms of a child cell if the degrees of
freedoms are Q-Legendre polynomials.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_integrateleg.html'>ply_integrateLeg</a></td>
                 <td><a href='../module/ply_modg_basis_module.html'>ply_modg_basis_module</a></td>
                 <td>Function</td>
                 <td><p>Integrate the integrand function in Legendre basis, and represent the
integral again in the Legendre basis up to the maximal degree.</p><a href="../proc/ply_integrateleg.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_l.html'>ply_l</a></td>
                 <td><a href='../module/ply_polybaseexc_module.html'>ply_polyBaseExc_module</a></td>
                 <td>Function</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_l2_projection.html'>ply_l2_projection</a></td>
                 <td><a href='../module/ply_l2p_module.html'>ply_l2p_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Actual implementation of the matrix operation to change between nodal
and modal representations.</p><a href="../proc/ply_l2_projection.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_l2p_header_define.html'>ply_l2p_header_define</a></td>
                 <td><a href='../module/ply_l2p_header_module.html'>ply_l2p_header_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_l2p_header_display.html'>ply_l2p_header_display</a></td>
                 <td><a href='../module/ply_l2p_header_module.html'>ply_l2p_header_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_l2p_header_load.html'>ply_l2p_header_load</a></td>
                 <td><a href='../module/ply_l2p_header_module.html'>ply_l2p_header_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Load settings to describe a projection method from a Lua table.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_l2p_header_out.html'>ply_l2p_header_out</a></td>
                 <td><a href='../module/ply_l2p_header_module.html'>ply_l2p_header_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Write L2P settings into a Lua table.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_l2p_trafo_1d.html'>ply_l2p_trafo_1D</a></td>
                 <td><a href='../module/ply_l2p_module.html'>ply_l2p_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Transformation between modal and nodal values in 1D via L2 projection.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_l2p_trafo_2d.html'>ply_l2p_trafo_2D</a></td>
                 <td><a href='../module/ply_l2p_module.html'>ply_l2p_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Transformation between modal and nodal values in 2D via L2 projection.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_l2p_trafo_3d.html'>ply_l2p_trafo_3D</a></td>
                 <td><a href='../module/ply_l2p_module.html'>ply_l2p_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Transformation between modal and nodal values in 3D via L2 projection.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_l_int.html'>ply_l_int</a></td>
                 <td><a href='../module/ply_polybaseexc_module.html'>ply_polyBaseExc_module</a></td>
                 <td>Function</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_lagrange_1d.html'>ply_lagrange_1D</a></td>
                 <td><a href='../module/ply_lagrange_module.html'>ply_lagrange_module</a></td>
                 <td>Function</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_lagrange_define.html'>ply_lagrange_define</a></td>
                 <td><a href='../module/ply_lagrange_module.html'>ply_lagrange_module</a></td>
                 <td>Function</td>
                 <td><p>Define a new polynomial in the Lagrange basis.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_lagrange_eval.html'>ply_lagrange_eval</a></td>
                 <td><a href='../module/ply_lagrange_module.html'>ply_lagrange_module</a></td>
                 <td>Function</td>
                 <td><p>Evaluate a polynomial in the Lagrange basis at some point x.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_lagrange_mode_at.html'>ply_lagrange_mode_at</a></td>
                 <td><a href='../module/ply_lagrange_module.html'>ply_lagrange_module</a></td>
                 <td>Function</td>
                 <td><p>Evaluate the given Lagrangian mode (which is 1 at coord(mode) and 0 in
all other points) at a given point x.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_lambda.html'>ply_lambda</a></td>
                 <td><a href='../module/ply_polybaseexc_module.html'>ply_polyBaseExc_module</a></td>
                 <td>Function</td>
                 <td><p>\todo: as we use a relation of gamma, it might be better to use the
       gammln function provided by the numerical recipes, and just
       use the difference in an exponential function.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_legendre_1d.html'>ply_legendre_1D</a></td>
                 <td><a href='../module/ply_modg_basis_module.html'>ply_modg_basis_module</a></td>
                 <td>Function</td>
                 <td><p>Evaluate all 1D Legendre polynomials at a given set
of points up to the given degree.</p><a href="../proc/ply_legendre_1d.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_legser.html'>ply_legser</a></td>
                 <td><a href='../module/ply_legser_module.html'>ply_legser_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Subroutine to convert Chebyshev (A) to Legendre (B) coefficients.</p><a href="../proc/ply_legser.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../interface/ply_legtopnt_2d.html'>ply_legToPnt_2D</a></td>
                 <td><a href='../module/ply_legfpt_2d_module.html'>ply_legFpt_2D_module</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_legtopnt_2d_multvar.html'>ply_legToPnt_2D_multVar</a></td>
                 <td><a href='../module/ply_legfpt_2d_module.html'>ply_legFpt_2D_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Subroutine to transform Legendre expansion to point values
at Chebyshev nodes.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_legtopnt_2d_singvar.html'>ply_legToPnt_2D_singVar</a></td>
                 <td><a href='../module/ply_legfpt_2d_module.html'>ply_legFpt_2D_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Subroutine to transform Legendre expansion to point values
at Chebyshev nodes.</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/ply_legtopnt_3d.html'>ply_LegTopnt_3D</a></td>
                 <td><a href='../module/ply_legfpt_3d_module.html'>ply_legFpt_3D_module</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_legtopnt_3d_multvar.html'>ply_legToPnt_3D_multVar</a></td>
                 <td><a href='../module/ply_legfpt_3d_module.html'>ply_legFpt_3D_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Subroutine to transform Legendre expansion to point values
 at Chebyshev nodes.
VK: no multivar fashion of this routine is used anymore</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_legtopnt_3d_singvar.html'>ply_legToPnt_3D_singvar</a></td>
                 <td><a href='../module/ply_legfpt_3d_module.html'>ply_legFpt_3D_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_legtopnt_lobatto_single.html'>ply_legToPnt_lobatto_single</a></td>
                 <td><a href='../module/ply_legfpt_module.html'>ply_legFpt_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Subroutine to transform Legendre expansion to point values
at Chebyshev-Lobatto nodes.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_legtopnt_lobatto_vec.html'>ply_legToPnt_lobatto_vec</a></td>
                 <td><a href='../module/ply_legfpt_module.html'>ply_legFpt_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Vectorizing subroutine to transform Legendre expansion to point values
at Chebyshev-Lobatto nodes.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_legtopnt_single.html'>ply_legToPnt_single</a></td>
                 <td><a href='../module/ply_legfpt_module.html'>ply_legFpt_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Subroutine to transform Legendre expansion to point values
at Chebyshev nodes.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_legtopnt_vec.html'>ply_legToPnt_vec</a></td>
                 <td><a href='../module/ply_legfpt_module.html'>ply_legFpt_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Vectorizing subroutine to transform Legendre expansion to point values
at Chebyshev nodes.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_legval.html'>ply_legVal</a></td>
                 <td><a href='../module/ply_legpolyprojection_module.html'>ply_LegPolyProjection_module</a></td>
                 <td>Function</td>
                 <td><p>Evaluate a given set of Legendre polynomials a given set of 1D points.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_m.html'>ply_m</a></td>
                 <td><a href='../module/ply_polybaseexc_module.html'>ply_polyBaseExc_module</a></td>
                 <td>Function</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_m_int.html'>ply_m_int</a></td>
                 <td><a href='../module/ply_polybaseexc_module.html'>ply_polyBaseExc_module</a></td>
                 <td>Function</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_nodes_create.html'>ply_nodes_create</a></td>
                 <td><a href='../module/ply_nodes_module.html'>ply_nodes_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Initialize points with the Chebyshev quadrature points, 3D</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_nodes_surface_coords.html'>ply_nodes_surface_coords</a></td>
                 <td><a href='../module/ply_nodes_module.html'>ply_nodes_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Create the integration points on the surface of (cubical) elements.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_nodes_volume_coords.html'>ply_nodes_volume_coords</a></td>
                 <td><a href='../module/ply_nodes_module.html'>ply_nodes_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Create multidimensional points from given 1D set of nodes in the cubic
reference element.</p><a href="../proc/ply_nodes_volume_coords.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_nodeset_chebyloba.html'>ply_nodeset_chebyloba</a></td>
                 <td><a href='../module/ply_nodeset_module.html'>ply_nodeset_module</a></td>
                 <td>Function</td>
                 <td><p>Generates a given number of Chebyshev-Lobatto points on the unit interval
[-1;+1].</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_nodeset_chebyshev.html'>ply_nodeset_chebyshev</a></td>
                 <td><a href='../module/ply_nodeset_module.html'>ply_nodeset_module</a></td>
                 <td>Function</td>
                 <td><p>Generates a given number of Chebyshev points on the unit interval [-1;+1].</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/ply_nodeset_coords.html'>ply_nodeset_coords</a></td>
                 <td><a href='../module/ply_nodeset_module.html'>ply_nodeset_module</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_nodeset_legendre.html'>ply_nodeset_legendre</a></td>
                 <td><a href='../module/ply_nodeset_module.html'>ply_nodeset_module</a></td>
                 <td>Function</td>
                 <td><p>Compute Gauss-Legendre integration points on the interval [-1,1].</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/ply_pnttoleg_2d.html'>ply_pntToLeg_2D</a></td>
                 <td><a href='../module/ply_legfpt_2d_module.html'>ply_legFpt_2D_module</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_pnttoleg_2d_multvar.html'>ply_pntToLeg_2D_multVar</a></td>
                 <td><a href='../module/ply_legfpt_2d_module.html'>ply_legFpt_2D_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Subroutine to transform Legendre expansion to point values
at Chebyshev nodes.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_pnttoleg_2d_singvar.html'>ply_pntToLeg_2D_singVar</a></td>
                 <td><a href='../module/ply_legfpt_2d_module.html'>ply_legFpt_2D_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Subroutine to transform Legendre expansion to point values
at Chebyshev nodes.</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/ply_pnttoleg_3d.html'>ply_pntToLeg_3D</a></td>
                 <td><a href='../module/ply_legfpt_3d_module.html'>ply_legFpt_3D_module</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_pnttoleg_3d_multvar.html'>ply_pntToLeg_3D_multVar</a></td>
                 <td><a href='../module/ply_legfpt_3d_module.html'>ply_legFpt_3D_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Subroutine to transform Legendre expansion to point values
at Chebyshev nodes.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_pnttoleg_3d_singvar.html'>ply_pntToLeg_3D_singVar</a></td>
                 <td><a href='../module/ply_legfpt_3d_module.html'>ply_legFpt_3D_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Subroutine to transform Legendre expansion to point values
at Chebyshev nodes.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_pnttoleg_lobatto_single.html'>ply_pntToLeg_lobatto_single</a></td>
                 <td><a href='../module/ply_legfpt_module.html'>ply_legFpt_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Subroutine to transform point values at Chebyshev-Lobatto nodes to a
Legendre expansion.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_pnttoleg_lobatto_vec.html'>ply_pntToLeg_lobatto_vec</a></td>
                 <td><a href='../module/ply_legfpt_module.html'>ply_legFpt_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Vectorizing subroutine to transform point values at Chebyshev-Lobatto
nodes to a Legendre expansion.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_pnttoleg_single.html'>ply_pntToLeg_single</a></td>
                 <td><a href='../module/ply_legfpt_module.html'>ply_legFpt_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Subroutine to transform point values at Chebyshev nodes to a Legendre
expansion.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_pnttoleg_vec.html'>ply_pntToLeg_vec</a></td>
                 <td><a href='../module/ply_legfpt_module.html'>ply_legFpt_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Vectorizing subroutine to transform point values at Chebyshev nodes to a
Legendre expansion.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_point_tensor.html'>ply_point_tensor</a></td>
                 <td><a href='../module/ply_nodes_module.html'>ply_nodes_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Compute a multi-dimensional tensor for the given set of nodes.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_poly_project_fillbody.html'>ply_poly_project_fillbody</a></td>
                 <td><a href='../module/ply_poly_project_module.html'>ply_poly_project_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Fill the body of the projection with all required data,
ply_poly_project_define has to be used beforehand to set necessary header
information.</p><a href="../proc/ply_poly_project_fillbody.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../interface/ply_poly_project_m2n.html'>ply_poly_project_m2n</a></td>
                 <td><a href='../module/ply_poly_project_module.html'>ply_poly_project_module</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_poly_project_m2n_multivar.html'>ply_poly_project_m2n_multiVar</a></td>
                 <td><a href='../module/ply_poly_project_module.html'>ply_poly_project_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Convert nDoF modes to nodal values.</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/ply_poly_project_n2m.html'>ply_poly_project_n2m</a></td>
                 <td><a href='../module/ply_poly_project_module.html'>ply_poly_project_module</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_poly_project_n2m_multivar.html'>ply_poly_project_n2m_multiVar</a></td>
                 <td><a href='../module/ply_poly_project_module.html'>ply_poly_project_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Convert nodal values to nDoFs modes.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_poly_transformation.html'>ply_Poly_Transformation</a></td>
                 <td><a href='../module/ply_poly_transformation_module.html'>ply_poly_transformation_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Projection of polynomial data from parent elements to child elements.
The projection is done by a direct transformation of the modal
coeffiecients to another coordinate system with z=ax+b.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_prj_header_load.html'>ply_prj_header_load</a></td>
                 <td><a href='../module/ply_prj_header_module.html'>ply_prj_header_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Load settings to describe a projection method from a Lua table.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_prj_header_out.html'>ply_prj_header_out</a></td>
                 <td><a href='../module/ply_prj_header_module.html'>ply_prj_header_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Load settings to describe a projection method from a Lua table.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_prj_init_define.html'>ply_prj_init_define</a></td>
                 <td><a href='../module/ply_dynarray_project_module.html'>ply_dynarray_project_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Define a projection, without filling its body.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_projdatatochild.html'>ply_projDataToChild</a></td>
                 <td><a href='../module/ply_poly_transformation_module.html'>ply_poly_transformation_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Subroutine to project element data from a parent cell to its children.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_projdatatochild~2.html'>ply_projDataToChild</a></td>
                 <td><a href='../module/ply_legpolyprojection_module.html'>ply_LegPolyProjection_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Subroutine to project elemental data from a parent cell to one of
its children.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_qlegonedimcoeff.html'>ply_QLegOneDimCoeff</a></td>
                 <td><a href='../module/ply_legpolyprojection_module.html'>ply_LegPolyProjection_module</a></td>
                 <td>Function</td>
                 <td><p>Routine to create one-dimensional projection coefficient for a coarse
element to a fine element.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_qlegsqnorm.html'>ply_QLegSqNorm</a></td>
                 <td><a href='../module/ply_legpolyprojection_module.html'>ply_LegPolyProjection_module</a></td>
                 <td>Function</td>
                 <td><p>Function to calculate the squared L2-Norm of a given Legendre polynomial
on the reference element [-1,+1].</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_qpolyprojection.html'>ply_QPolyProjection</a></td>
                 <td><a href='../module/ply_legpolyprojection_module.html'>ply_LegPolyProjection_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Subsampling by L2-Projection of the Q-Tensorproduct Legendre polynomials.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_sample_adaptive.html'>ply_sample_adaptive</a></td>
                 <td><a href='../module/ply_sampling_adaptive_module.html'>ply_sampling_adaptive_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Sample data described by varsys in orig_mesh according to the tracking
object trackInst with adaptive refinements.</p><a href="../proc/ply_sample_adaptive.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_sample_data.html'>ply_sample_data</a></td>
                 <td><a href='../module/ply_sampling_module.html'>ply_sampling_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Sampling polynomial data from a given array and mesh to a new mesh with
a new data array, where just a single degree of freedom per element is
used.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_sampled_track_init.html'>ply_sampled_track_init</a></td>
                 <td><a href='../module/ply_sampled_tracking_module.html'>ply_sampled_tracking_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Initialize the sampled tracking entities.</p><a href="../proc/ply_sampled_track_init.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_sampled_track_output.html'>ply_sampled_track_output</a></td>
                 <td><a href='../module/ply_sampled_tracking_module.html'>ply_sampled_tracking_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Output sampled tracking data.</p><a href="../proc/ply_sampled_track_output.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_sampled_tracking_load.html'>ply_sampled_tracking_load</a></td>
                 <td><a href='../module/ply_sampled_tracking_module.html'>ply_sampled_tracking_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Load the configuration of sampled tracking objects.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_sampling_adaptive_load.html'>ply_sampling_adaptive_load</a></td>
                 <td><a href='../module/ply_sampling_adaptive_module.html'>ply_sampling_adaptive_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Load the configuration for adaptive subsampling.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_sampling_free_methoddata.html'>ply_sampling_free_methodData</a></td>
                 <td><a href='../module/ply_sampling_module.html'>ply_sampling_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Free previously allocated methodData of variable.</p><a href="../proc/ply_sampling_free_methoddata.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_sampling_load.html'>ply_sampling_load</a></td>
                 <td><a href='../module/ply_sampling_module.html'>ply_sampling_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This subroutine reads the sampling configuration from the Lua script
provided in conf and fills the sampling data in 'me' accordingly.</p><a href="../proc/ply_sampling_load.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_sampling_var_allocate.html'>ply_sampling_var_allocate</a></td>
                 <td><a href='../module/ply_sampling_varsys_module.html'>ply_sampling_varsys_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Allocate memory for a sampled variable.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_sampling_var_compute_elemdev.html'>ply_sampling_var_compute_elemdev</a></td>
                 <td><a href='../module/ply_sampling_varsys_module.html'>ply_sampling_varsys_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine computes for each element whether the solution in it is
considered to be deviating from the mean above the given threshold or
not. The logical result is stored in <code>var%deviates</code> for each element.</p><a href="../proc/ply_sampling_var_compute_elemdev.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_sampling_var_move.html'>ply_sampling_var_move</a></td>
                 <td><a href='../module/ply_sampling_varsys_module.html'>ply_sampling_varsys_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Move the variable data from source to destination.</p><a href="../proc/ply_sampling_var_move.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_sampling_varsys_for_track.html'>ply_sampling_varsys_for_track</a></td>
                 <td><a href='../module/ply_sampling_varsys_module.html'>ply_sampling_varsys_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Create a variable system for the given tracking instance.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_scalproddualleg.html'>ply_scalProdDualLeg</a></td>
                 <td><a href='../module/ply_modg_basis_module.html'>ply_modg_basis_module</a></td>
                 <td>Function</td>
                 <td><p>Function to calculate the scalar product between a Legendre polynomial
(ansatz function) and a dual Legendre polynomial (test function) on the
reference element [-1;+1].</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_scalproddualleg_vec.html'>ply_scalProdDualLeg_vec</a></td>
                 <td><a href='../module/ply_modg_basis_module.html'>ply_modg_basis_module</a></td>
                 <td>Function</td>
                 <td><p>Vectorized Function to calculate the scalar product between a Legendre polynomial
(ansatz function) and a dual Legendre polynomial (test function) on the
reference element [-1;+1] and
to calculate the scalar product between a Legendre polynomial
(ansatz function) and a differentiated dual Legendre polynomial (test
function) on the reference element [-1;+1].</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_scalprodduallegdiff.html'>ply_scalProdDualLegDiff</a></td>
                 <td><a href='../module/ply_modg_basis_module.html'>ply_modg_basis_module</a></td>
                 <td>Function</td>
                 <td><p>Function to calculate the scalar product between a Legendre polynomial
(ansatz function) and a differentiated dual Legendre polynomial (test
function) on the reference element [-1;+1].</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_scalprodleg.html'>ply_scalProdLeg</a></td>
                 <td><a href='../module/ply_modg_basis_module.html'>ply_modg_basis_module</a></td>
                 <td>Function</td>
                 <td><p>Function to calculate the L2 scalar product of a Legendre polynomial
with itself on the reference element [-1,+1].</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_split_element_1d.html'>ply_split_element_1D</a></td>
                 <td><a href='../module/ply_split_element_module.html'>ply_split_element_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Split one-dimensional elements of degree parent_degree into two elements
with polynomials of degree child_degree.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_split_element_1d_test.html'>ply_split_element_1D_test</a></td>
                 <td><a href='../module/ply_split_element_module.html'>ply_split_element_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Testing the 1D splitting.</p><a href="../proc/ply_split_element_1d_test.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_split_element_2d.html'>ply_split_element_2D</a></td>
                 <td><a href='../module/ply_split_element_module.html'>ply_split_element_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Split two-dimensional elements of degree parent_degree into four elements
with polynomials of degree child_degree.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_split_element_2d_test.html'>ply_split_element_2D_test</a></td>
                 <td><a href='../module/ply_split_element_module.html'>ply_split_element_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Testing the 2D splitting.</p><a href="../proc/ply_split_element_2d_test.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_split_element_3d.html'>ply_split_element_3D</a></td>
                 <td><a href='../module/ply_split_element_module.html'>ply_split_element_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Split three-dimensional elements of degree parent_degree into eight
elements with polynomials of degree child_degree.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_split_element_3d_test.html'>ply_split_element_3D_test</a></td>
                 <td><a href='../module/ply_split_element_module.html'>ply_split_element_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Testing the 3D splitting.</p><a href="../proc/ply_split_element_3d_test.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_split_element_init.html'>ply_split_element_init</a></td>
                 <td><a href='../module/ply_split_element_module.html'>ply_split_element_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Initialization of the module.
This needs to be performed before any call of the actual transformation
<a href="../proc/ply_split_element_1d.html">ply_split_element_1D</a>.</p><a href="../proc/ply_split_element_init.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_split_element_singled.html'>ply_split_element_singleD</a></td>
                 <td><a href='../module/ply_split_element_module.html'>ply_split_element_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Project a polynomial representation in elements in one dimension to its
 two halves in that direction.</p><a href="../proc/ply_split_element_singled.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_split_element_test.html'>ply_split_element_test</a></td>
                 <td><a href='../module/ply_split_element_module.html'>ply_split_element_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Testing routine for the functions of this module.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_split_legendre_matrix.html'>ply_split_legendre_matrix</a></td>
                 <td><a href='../module/ply_split_legendre_module.html'>ply_split_legendre_module</a></td>
                 <td>Function</td>
                 <td><p>Compute the transformation matrix for a projection to the left and right
 half-interval of Legendre polynomials for the given maximal number of
 modes.</p><a href="../proc/ply_split_legendre_matrix.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_split_legendre_test.html'>ply_split_legendre_test</a></td>
                 <td><a href='../module/ply_split_legendre_module.html'>ply_split_legendre_module</a></td>
                 <td>Subroutine</td>
                 <td><p>A small testing routine to check the functions of this module.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_subres_get_elemcolor.html'>ply_subres_get_elemcolor</a></td>
                 <td><a href='../module/ply_subresolution_module.html'>ply_subresolution_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Get the color of an element.</p><a href="../proc/ply_subres_get_elemcolor.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_subres_import_color.html'>ply_subres_import_color</a></td>
                 <td><a href='../module/ply_subresolution_module.html'>ply_subresolution_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Get the subresolution data for all elements for a given color and in the
requested format.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_subresolution_load.html'>ply_subresolution_load</a></td>
                 <td><a href='../module/ply_subresolution_module.html'>ply_subresolution_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Subroutine to load subresolution information for a given tree.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_subsampledata.html'>ply_subsampleData</a></td>
                 <td><a href='../module/ply_poly_transformation_module.html'>ply_poly_transformation_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_subsampledata~2.html'>ply_subsampleData</a></td>
                 <td><a href='../module/ply_legpolyprojection_module.html'>ply_LegPolyProjection_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Routine to subsample mesh information for one refinement level.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_test_transfer_1d.html'>ply_test_transfer_1d</a></td>
                 <td><a href='../module/ply_transfer_test_module.html'>ply_transfer_test_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Test for ply_transfer_dofs_1d.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_test_transfer_2d.html'>ply_test_transfer_2d</a></td>
                 <td><a href='../module/ply_transfer_test_module.html'>ply_transfer_test_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Test for ply_transfer_dofs_2d.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_test_transfer_3d.html'>ply_test_transfer_3d</a></td>
                 <td><a href='../module/ply_transfer_test_module.html'>ply_transfer_test_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Test for ply_transfer_dofs_3d.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_transfer_dofs.html'>ply_transfer_dofs</a></td>
                 <td><a href='../module/ply_transfer_module.html'>ply_transfer_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Small helping routine to wrap transfers in all allowed dimensions.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_transfer_dofs_1d.html'>ply_transfer_dofs_1D</a></td>
                 <td><a href='../module/ply_transfer_module.html'>ply_transfer_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Transfer of degrees of freedom from one polynomial to another in 1D.</p><a href="../proc/ply_transfer_dofs_1d.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_transfer_dofs_2d.html'>ply_transfer_dofs_2D</a></td>
                 <td><a href='../module/ply_transfer_module.html'>ply_transfer_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Transfer of degrees of freedom from one polynomial to another in 2D.</p><a href="../proc/ply_transfer_dofs_2d.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_transfer_dofs_3d.html'>ply_transfer_dofs_3D</a></td>
                 <td><a href='../module/ply_transfer_module.html'>ply_transfer_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Transfer of degrees of freedom from one polynomial to another in 3D.</p><a href="../proc/ply_transfer_dofs_3d.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_transfer_p_dim.html'>ply_transfer_P_dim</a></td>
                 <td><a href='../module/ply_transfer_module.html'>ply_transfer_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Transfer the polynomial in P representation from on dimension to
another one.</p><a href="../proc/ply_transfer_p_dim.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ply_transform_matrix.html'>ply_transform_matrix</a></td>
                 <td><a href='../module/ply_poly_transformation_module.html'>ply_poly_transformation_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Compute the transformation matrix for a projection to the left and right
half-interval of Legendre polynomials for the given maximal number of
modes.</p><a href="../proc/ply_transform_matrix.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../interface/positionofval.html'>positionofval</a></td>
                 <td><a href='../module/ply_dynarray_project_module.html'>ply_dynarray_project_module</a></td>
                 <td>Interface</td>
                 <td><p>return the position of a given value
in the array val, which is what you usually want to know.
it is the index of a given value</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/posofval_projection.html'>posofval_projection</a></td>
                 <td><a href='../module/ply_dynarray_project_module.html'>ply_dynarray_project_module</a></td>
                 <td>Function</td>
                 <td><p>the actual position of a given value in the dynamic array</p><a href="../proc/posofval_projection.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/postprocess_rhs_cubes.html'>postprocess_rhs_cubes</a></td>
                 <td><a href='../module/atl_compute_module.html'>atl_compute_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Applies the postprocessing step of the compute step.</p><a href="../proc/postprocess_rhs_cubes.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/preprocess_local_rhs_cubes.html'>preprocess_local_rhs_cubes</a></td>
                 <td><a href='../module/atl_compute_local_module.html'>atl_compute_local_module</a></td>
                 <td>Subroutine</td>
                 <td><p>should only evaluate sources</p><a href="../proc/preprocess_local_rhs_cubes.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/preprocess_modg_nerplanck_kernel.html'>preprocess_modg_nerplanck_kernel</a></td>
                 <td><a href='../module/atl_modg_nerplanck_kernel_module.html'>atl_modg_nerplanck_kernel_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/preprocess_rhs_cubes.html'>preprocess_rhs_cubes</a></td>
                 <td><a href='../module/atl_compute_module.html'>atl_compute_module</a></td>
                 <td>Subroutine</td>
                 <td><p>compute the right hand side of your discrete equation.</p><a href="../proc/preprocess_rhs_cubes.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/read_legpolyvar_modes.html'>read_legpolyvar_modes</a></td>
                 <td><a href='../module/atl_legpolyvar_module.html'>atl_legpolyvar_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/rk2_substep.html'>rk2_substep</a></td>
                 <td><a href='../module/atl_ssprk2_module.html'>atl_ssprk2_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Subroutine calculates a substep of the Runge-Kutta timestepping scheme.
Calls itself recursively for the finer levels until the finest level is reached.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/rk2_update.html'>rk2_update</a></td>
                 <td><a href='../module/atl_ssprk2_module.html'>atl_ssprk2_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Subroutine calculates the final update step of the Runge-Kutta method.
It is performing levelwise.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/rk4_substep.html'>rk4_substep</a></td>
                 <td><a href='../module/atl_rk4_module.html'>atl_rk4_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Subroutine calculates a substep of the Runge-Kutta timestepping scheme.
Calls itself recursively for the finer levels until the finest level is
reached.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/rktaylor_substep.html'>rktaylor_substep</a></td>
                 <td><a href='../module/atl_rktaylor_module.html'>atl_rktaylor_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Subroutine calculates a substep of the Runge-Kutta-Taylor timestepping scheme.
Calls itself recursively for the finer levels until the finest level is reached.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/rktaylor_update.html'>rktaylor_update</a></td>
                 <td><a href='../module/atl_rktaylor_module.html'>atl_rktaylor_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Subroutine calculates the final update step of the Runge-Kutta Taylor method.
It is performing levelwise.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/serializedata.html'>serializeData</a></td>
                 <td><a href='../module/atl_restart_module.html'>atl_restart_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This subroutine serializes the given data to perform a restart.</p><a href="../proc/serializedata.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/shear_estimate_2d.html'>shear_estimate_2d</a></td>
                 <td><a href='../module/atl_eqn_nvrstk_var_module.html'>atl_eqn_nvrstk_var_module</a></td>
                 <td>Function</td>
                 <td><p>Estimate the magnitude of shear terms.</p><a href="../proc/shear_estimate_2d.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/shear_estimate_3d.html'>shear_estimate_3d</a></td>
                 <td><a href='../module/atl_eqn_nvrstk_var_module.html'>atl_eqn_nvrstk_var_module</a></td>
                 <td>Function</td>
                 <td><p>Estimate the magnitude of shear terms.</p><a href="../proc/shear_estimate_3d.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/solve_admissible_state.html'>solve_admissible_state</a></td>
                 <td><a href='../module/atl_stabilize_module.html'>atl_stabilize_module</a></td>
                 <td>Function</td>
                 <td><p>Solve for admissible state of the conservative positivity preserving
limiter.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/solve_admissible_state_2d.html'>solve_admissible_state_2d</a></td>
                 <td><a href='../module/atl_stabilize_module.html'>atl_stabilize_module</a></td>
                 <td>Function</td>
                 <td><p>Solve for admissible state of the conservative positivity preserving limiter.</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/sortedposofval.html'>sortedposofval</a></td>
                 <td><a href='../module/ply_dynarray_project_module.html'>ply_dynarray_project_module</a></td>
                 <td>Interface</td>
                 <td><p>return the position of a given value
in the list 'sorted'. this is mainly for internal usage.
the sorted list is only a pointer list to the actual values
thus, in order to get the index of a given value, you
need to look up the entry in the sorted list.
this is done by the positionofval routine</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/sortposofval_projection.html'>sortposofval_projection</a></td>
                 <td><a href='../module/ply_dynarray_project_module.html'>ply_dynarray_project_module</a></td>
                 <td>Function</td>
                 <td><p>return the sorted position of a value in the given dynamic array</p><a href="../proc/sortposofval_projection.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../interface/sorttruncate.html'>sorttruncate</a></td>
                 <td><a href='../module/ply_dynarray_project_module.html'>ply_dynarray_project_module</a></td>
                 <td>Interface</td>
                 <td><p>fix the dynamic array, meaning:
store the array in the sorted order and cut
off the trailing empty entries</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/sorttruncate_da_projection.html'>sorttruncate_da_projection</a></td>
                 <td><a href='../module/ply_dynarray_project_module.html'>ply_dynarray_project_module</a></td>
                 <td>Subroutine</td>
                 <td><p>fixing the dynamic array</p><a href="../proc/sorttruncate_da_projection.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/stripmatprefix.html'>stripMatPrefix</a></td>
                 <td><a href='../module/atl_materialfun_module.html'>atl_materialFun_module</a></td>
                 <td>Function</td>
                 <td><p>Strips the prefix from material variables created by the solver when
adding material to the variable system.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/test_project_stabviscnumflux.html'>test_project_stabViscNumFlux</a></td>
                 <td><a href='../module/atl_modg_kernel_module.html'>atl_modg_kernel_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../interface/truncate.html'>truncate</a></td>
                 <td><a href='../module/ply_dynarray_project_module.html'>ply_dynarray_project_module</a></td>
                 <td>Interface</td>
                 <td><p>truncate the array, meaning
cut off the trailing empty entries</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/truncate_da_projection.html'>truncate_da_projection</a></td>
                 <td><a href='../module/ply_dynarray_project_module.html'>ply_dynarray_project_module</a></td>
                 <td>Subroutine</td>
                 <td><p>truncate the array after the last valid entry and hence cut off the empty
trailing empty entries</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/update_timestep_euler.html'>update_timestep_euler</a></td>
                 <td><a href='../module/atl_fwdeuler_module.html'>atl_fwdEuler_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Interface definition for levelwise updating of timestepping routine.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/update_timestep_imexrk.html'>update_timestep_imexrk</a></td>
                 <td><a href='../module/atl_imexrk_module.html'>atl_imexrk_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Levelwise update of IMEX Runge-Kutta</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/update_timestep_predcor_cerk4.html'>update_timestep_predcor_cerk4</a></td>
                 <td><a href='../module/atl_predcor_cerk4_module.html'>atl_predcor_cerk4_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Levelwise updating of runge kutta of order 4</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/update_timestep_rk4.html'>update_timestep_rk4</a></td>
                 <td><a href='../module/atl_rk4_module.html'>atl_rk4_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Levelwise updating of runge kutta of order 4</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/update_timestep_rktaylor.html'>update_timestep_rktaylor</a></td>
                 <td><a href='../module/atl_rktaylor_module.html'>atl_rktaylor_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Levelwise updating of runge kutta taylor method</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/update_timestep_ssprk2.html'>update_timestep_ssprk2</a></td>
                 <td><a href='../module/atl_ssprk2_module.html'>atl_ssprk2_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Levelwise updating of runge kutta of order 2</p></td>
               </tr>
			 </tbody></table>
             
        </div>
      </div>
      <hr>
    </div> <!-- /container -->
    <footer>
      <div class="container">
        <div class="row justify-content-between">
          <div class="col">
            <p>
              Ateles
 was developed by University of Siegen<br>              &copy; 2025 
<br /><small>35502fb74de3</small></p>
          </div>
          <div class="col">
            <p class="text-end">
              Documentation generated by
              <a href="https://github.com/Fortran-FOSS-Programmers/ford">FORD</a>
 on 2025-05-23T14:17:25.758960+0000             </p>
          </div>
        </div>
        <br>
      </div> <!-- /container -->
    </footer>
  </body>
</html>