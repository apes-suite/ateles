<!-- -*- mode: jinja2 -*- -->

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
      <meta name="description" content="Discontinuous Galerkin solver with explicit time stepping.">
    <meta name="author" content="University of Siegen" >
    <link rel="icon" href="../favicon.png">

    <title>ply_split_element_singleD &ndash; Ateles</title>

    <!-- Bootstrap -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet"
          integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"
            integrity="sha384-YvpcrYf0tY3lHB60NNkmXc5s9fDVZLESaAA55NDzOxhy9GkcIdslK1eN7N6jIeHz" crossorigin="anonymous"></script>
    <!-- Font Awesome -->
    <link href="../css/fontawesome.min.css" rel="stylesheet">
    <link href="../css/brands.min.css" rel="stylesheet">
    <link href="../css/regular.min.css" rel="stylesheet">
    <link href="../css/solid.min.css" rel="stylesheet">
    <link href="../css/v4-font-face.min.css" rel="stylesheet">
    <link href="../css/v4-shims.min.css" rel="stylesheet">
    <!-- MathJax -->
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        TeX: { equationNumbers: { autoNumber: "AMS" } }
      });
    </script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.9/MathJax.js?config=TeX-AMS-MML_HTMLorMML" async
            integrity="sha256-DViIOMYdwlM/axqoGDPeUyf0urLoHMN4QACBKyB58Uw=" crossorigin="anonymous"></script>
    <!-- Other scripts and stylesheets -->
    <link href="../css/local.css" rel="stylesheet">
    <link href="../css/pygments.css" rel="stylesheet">
    <script src="../js/svg-pan-zoom.min.js"></script>
  </head>

  <body>

    <!-- Fixed navbar -->
    <div class="container-fluid mb-sm-4 mb-xl-2">
      <nav class="navbar navbar-expand-lg navbar-dark bg-dark fixed-top">
        <div class="container">
          <a class="navbar-brand" href="../index.html">Ateles </a>
          <button type="button" class="navbar-toggler" data-bs-toggle="collapse" data-bs-target="#navbar"
                  aria-expanded="false" aria-controls="navbar" aria-label="Toggle navigation">
                  <span class="navbar-toggler-icon">
          </button>

          <div id="navbar" class="navbar-collapse collapse">
            <ul class="navbar-nav">
                <li class="nav-item"><a class="nav-link" href="../page/index.html">Documentation</a></li>
                  <li class="nav-item">
                    <a class="nav-link" href="../lists/files.html">Source Files</a>
                  </li>
                <li class="nav-item">
                  <a class="nav-link" href="../lists/modules.html">Modules</a>
                </li>
                <li class="nav-item">
                  <a class="nav-link" href="../lists/procedures.html">Procedures</a>
                </li>
                <li class="nav-item">
                  <a class="nav-link" href="../lists/absint.html">Abstract Interfaces</a>
                </li>
                <li class="nav-item">
                  <a class="nav-link" href="../lists/types.html">Derived Types</a>
                </li>
                <li class="nav-item">
                  <a class="nav-link" href="../lists/programs.html">Programs</a>
                </li>
            </ul>
              <div class="d-flex align-items-end flex-grow-1">
                <form action="../search.html" role="search" class="ms-auto">
                  <input type="text" class="form-control" aria-label="Search" placeholder="Search" name="q" id="tipue_search_input" autocomplete="off" required>
                </form>
              </div>
          </div><!--/.nav-collapse -->
        </div>
      </nav>
    </div>

    <div class="container">
  <div class="row">
    <h1>ply_split_element_singleD
      <small>Subroutine</small>
      
    </h1>
      <div class="container p-2 mb-4 bg-light border rounded-3">
    <div class="row align-items-center justify-content-between" id="info-bar">
      <div class="col">
        <ul class="list-inline" style="margin-bottom:0px;display:inline">

            <li class="list-inline-item" id="statements"><i class="fa fa-list-ol"></i>
              <a data-bs-toggle="tooltip" data-bs-placement="bottom" data-bs-html="true"
                 title=" 0.1% of total for procedures.">43 statements</a>
            </li>

            <li class="list-inline-item" id="source-file">
              <i class="fa fa-code"></i>
              <a href="../src/ply_split_element_module.f90"> Source File</a>
            </li>
        </ul>
      </div>
      <div class="col">
        <nav aria-label="breadcrumb">
          <ol class="breadcrumb justify-content-end mb-0">
                <li class="breadcrumb-item"><a href='../sourcefile/ply_split_element_module.f90.html'>ply_split_element_module.f90</a></li>
                <li class="breadcrumb-item"><a href='../module/ply_split_element_module.html'>ply_split_element_module</a></li>
            <li class="breadcrumb-item active" aria-current="page">ply_split_element_singleD</li>
          </ol>
        </nav>
      </div>
    </div>
  </div>
  <script>
    // Enable Bootstrap tooltips
    (function () {
      const tooltipTriggerList = document.querySelectorAll('[data-bs-toggle="tooltip"]')
      const tooltipList = [...tooltipTriggerList].map(tooltipTriggerEl => new bootstrap.Tooltip(tooltipTriggerEl))
    })();
  </script>

  </div>
  
  <div class="row">
    <div class="col-md-3 hidden-xs hidden-sm visible-md visible-lg">
      <div id="sidebar">
      <h3>Contents</h3>
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  


  </div>

    </div>
    
    <div class="col-md-9" id='text'>
    <h2>public  subroutine ply_split_element_singleD(nDims, inLen, outLen, parent_data, child_data, ignore)  
</h2>
    

    <p>Project a polynomial representation in elements in one dimension to its
 two halves in that direction.</p>
<p>For each parent element the projection on the two respective child elements
 (half intervals) are computed for one dimension.</p>
<div class="alert alert-info">
<p class="alert-title h4">Note</p>
<p>Preliminary data layout and interface planning.
 It might be that we should rather split the index into the direction
 in which we perform the operation and all the other directions normal
 to that. For a dense matrix this may allow the compiler to detect
 the matrix multiply. However, here for the triangular matrix it is not
 so sure, whether this would be possible.</p>
</div>
<div class="alert alert-info">
<p class="alert-title h4">Note</p>
<p>After discussions with Stephan Walter, it looks like the separate
 indices would most likely be better.
 Maybe, using explicit shaped arrays and therby allowing more dimensions
 in the input, while keeping the interface to two dimensions for all
 cases (the normal direction and all independent degrees of freedom).
 For vectorization on x86 it also is necessary to have a stride-1 access
 only in reading and writing.
 The rotation of data might not be the best option because of this.
 Instead, it may be that we need to have different routines for each
 direction.
 Or, maybe, we need to use the elements as first index and vectorize
 over those.</p>
</div>
<p>As we need to perform this operation in all dimensions, it would be good
 to shift the indices around. When doing this, we can stick to the same
 implementation for all directions, without the need to put any logic in
 here to decide on the current direction.
 In 3D we would end up with this chain:
 (x,y,z) -&gt; split_element for Z -&gt; (z,x,y)
         -&gt; split_element for Y -&gt; (y,z,x)
         -&gt; split_element for X -&gt; (x,y,z)
 Thus, the logic is that we perform the split on the last dimension, and
 cycle the indices in the output.</p>
<p>We can generalize this to arbitrary dimensions.
 In 2D it would look like this:
 (x,y) -&gt; split_element for Y -&gt; (y,x)
       -&gt; split_element for X -&gt; (x,y)
 And in 1D, we just need to perform one transformation:
 (x) -&gt; split_element for X -&gt; (x)</p>
<p>As we allow for a changed number of polynomial degrees in the input and
 output, we need to take care of different lengths for each direction.
 Thus, we need: the dimensionality, two 1D arrays with the length of this
 dimensionality to provide the number of degrees of freedom for each
 direction (once for the input, and once for the output).</p>
<p>We need: nDofs in the direction where the transformation is to be done
          and the nDofs for all normal directions.</p>


    <h3>Arguments</h3>
        <table class="table table-striped varlist">
    <thead>
      <tr>
        <th scope="col">Type</th>
<th scope="col">Intent</th><th scope="col">Optional</th>        <th scope="col">Attributes</th>
        <th scope="col"></th>
        <th scope="col">Name</th>
        <th scope="col"></th>
    </thead>
    <tbody>
        <tr>
            <td>
              <span class="anchor" id="variable-ndims~19"></span>
              integer,
            </td>
<td>intent(in)</td>
              <td></td>            <td>
              
            </td>
            <td>::</td>
            <td><strong>nDims</strong></td>
            <td>
                <p>Number of dimensions of the polynomial data.</p>
            </td>
        </tr>
        <tr>
            <td>
              <span class="anchor" id="variable-inlen~2"></span>
              integer,
            </td>
<td>intent(in)</td>
              <td></td>            <td>
              
            </td>
            <td>::</td>
            <td><strong>inLen</strong>(nDims)</td>
            <td>
                <p>Number degrees of freedom for each direction in parent_Data.</p>
<p>The first index of parent_data needs to have a length equal to the
product of all inLen components.
The splitting operation will be done in the last dimension.</p>
            </td>
        </tr>
        <tr>
            <td>
              <span class="anchor" id="variable-outlen"></span>
              integer,
            </td>
<td>intent(in)</td>
              <td></td>            <td>
              
            </td>
            <td>::</td>
            <td><strong>outLen</strong>(nDims)</td>
            <td>
                <p>Number degrees of freedom for each direction in child_Data.</p>
<p>The first index of child_data needs to have a length equal to the
product of all outLen components.
The data will be cyclicly exchanged. Thus, the last dimension in
parent_data corresponds to the first in one in child_data and all
other components are shifted once to the right.</p>
            </td>
        </tr>
        <tr>
            <td>
              <span class="anchor" id="variable-parent_data~3"></span>
              real(kind=rk),
            </td>
<td>intent(in)</td>
              <td></td>            <td>
              
            </td>
            <td>::</td>
            <td><strong>parent_data</strong>(:,:)</td>
            <td>
                <p>Polynomial representation in the parent elements.</p>
<p>The first index are the degrees of freedom in elements, the second index
are the elements.
In the first index the shape of data has to be in the form
(inLen(1), inLen(2), ... , inLen(nDims)).
The splitting operation is performed on the last dimension in that
data.</p>
            </td>
        </tr>
        <tr>
            <td>
              <span class="anchor" id="variable-child_data~3"></span>
              real(kind=rk),
            </td>
<td>intent(out)</td>
              <td></td>            <td>
              
            </td>
            <td>::</td>
            <td><strong>child_data</strong>(:,:)</td>
            <td>
                <p>Computed projection of the polynomial representation in the child
elements.</p>
<p>Again, the first index refers to the degrees of freedom, while the
second index are the elements. There need to be twice as many elements
as in the parent_data.
Left childs are stored in iChild = (iParent<em>2 - 1), and the right
childs in iParent</em>2.</p>
<p>In the first index the shape of the data has to be in the form
(outLen(1), outLen(2), ... , outLen(nDims)), the data is rotated
in comparison to parent_data and the splitted direction has to be
the first one in child_data (while it was the last in parent_data),
and all other dimensions are shifted by one to the right.</p>
            </td>
        </tr>
        <tr>
            <td>
              <span class="anchor" id="variable-ignore"></span>
              logical,
            </td>
<td>intent(in)</td>
              <td></td>            <td>
              
            </td>
            <td>::</td>
            <td><strong>ignore</strong></td>
            <td>
                <p>Whether to ignore high modes that exceed the target maximal polynomial
degree.</p>
<p>This can be used as a simple lowpass filter that cuts off the highest
modes in the parent elements prior to mapping to child elements.</p>
            </td>
        </tr>
    </tbody>
  </table>

    <br>


    
    

    
    



    
    
    </div>
  </div>

      <hr>
    </div> <!-- /container -->
    <footer>
      <div class="container">
        <div class="row justify-content-between">
          <div class="col">
            <p>
              Ateles
 was developed by University of Siegen<br>              &copy; 2025 
<br /><small>35502fb74de3</small></p>
          </div>
          <div class="col">
            <p class="text-end">
              Documentation generated by
              <a href="https://github.com/Fortran-FOSS-Programmers/ford">FORD</a>
 on 2025-05-23T14:17:25.758960+0000             </p>
          </div>
        </div>
        <br>
      </div> <!-- /container -->
    </footer>
  </body>
</html>